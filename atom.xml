<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-09T12:28:49.525Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>拒绝服务攻击</title>
    <link href="http://example.com/2022/05/03/%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/"/>
    <id>http://example.com/2022/05/03/%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/</id>
    <published>2022-05-03T09:29:41.088Z</published>
    <updated>2022-05-09T12:28:49.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="剧毒包型拒绝服务攻击"><a href="#剧毒包型拒绝服务攻击" class="headerlink" title="剧毒包型拒绝服务攻击"></a>剧毒包型拒绝服务攻击</h3><h4 id="碎片攻击"><a href="#碎片攻击" class="headerlink" title="碎片攻击"></a>碎片攻击</h4><p> IP首部有两个字节表示整个IP数据包的长度，所以IP数据包最长只能为0xFFFF，就是65535字<br> 节。如果有意发送总长度超过65535的IP碎片，一些老的系统内核在处理的时候就会出现问题<br> ，导致崩溃或者拒绝服务。另外，如果分片之间偏移量经过精心构造，一些系统就无法处理，<br> 导致死机。</p><h4 id="Ping-of-Death攻击"><a href="#Ping-of-Death攻击" class="headerlink" title="Ping of Death攻击"></a>Ping of Death攻击</h4><p> ping of death是利用ICMP协议的一种碎片攻击。攻击者发送一个长度超过65535的Echo Req<br> uest数据包，目标主机在重组分片的时候会造成事先分配的65535字节缓冲区溢出，系统通常<br> 会崩溃或挂起。</p><h4 id="Land攻击"><a href="#Land攻击" class="headerlink" title="Land攻击"></a>Land攻击</h4><p> 利用了TCP连接建立的三次握手过程，通过向一个目标计算机发送一个TCP SYN报文（连接<br> 建立请求报文）而完成对目标计算机的攻击。与正常的TCP SYN报文不同的是，LAND攻击报文的源IP地址和目的IP地址是相同的，都是目标计算机的IP地址。这样目标计算机接收到这个SYN报文后，就会向该报文的源地址发送一个ACK报文，并建立一个TCP连接控制结构（TCB），而该报文的源地址就是自己，因此，这个ACK报文就发给了自己。这样如果攻击者发送了足够多的SYN报文，则目标计算机的TCB可能会耗尽，最终不能正常服务。这也是一种DOS攻击。</p><h4 id="循环攻击"><a href="#循环攻击" class="headerlink" title="循环攻击"></a>循环攻击</h4><p>  在一个死循环中不停的发送一个ICMP/UDP的IP碎片，可以使Windows系统的机器死<br> 锁。</p><h3 id="风暴型拒绝服务攻击"><a href="#风暴型拒绝服务攻击" class="headerlink" title="风暴型拒绝服务攻击"></a>风暴型拒绝服务攻击</h3><h4 id="直接风暴型拒绝服务攻击"><a href="#直接风暴型拒绝服务攻击" class="headerlink" title="直接风暴型拒绝服务攻击"></a>直接风暴型拒绝服务攻击</h4><p>以多个随机的源主机地址向目的主机发送超大量的随机或特定的包，造成目标主机不能处理其他正常的包。</p><h5 id="Syn-Flood"><a href="#Syn-Flood" class="headerlink" title="Syn Flood"></a>Syn Flood</h5><p>攻击原理：依据tcp建立连接的三次握手。此攻击以多个随机的源主机地址向目的主机发送syn包，而在收到目的主机的syn＋ack包后并不回应，目的主机就为这些源主机建立大量的连接队列，由于没有收到ack一直维护这些连接队列，造成资源的大量消耗而不能向正常的请求提供服务。与之类似的攻击方式还有ackflood、s-ackflood、finflood、rstflood、tcpflood 。</p><h5 id="Http-Flood"><a href="#Http-Flood" class="headerlink" title="Http Flood"></a>Http Flood</h5><p>攻击原理：此攻击类型主要攻击目标为Web服务器上的网页访问服务，当发生攻击时攻击者向被攻击服务器大量高频的发送一个网页或多个网页的请求服务，使服务器忙于向攻击者提供响应资源从而导致不能想正常的合法用户提供请求响应服务。</p><h4 id="反射型拒绝服务攻击"><a href="#反射型拒绝服务攻击" class="headerlink" title="反射型拒绝服务攻击"></a>反射型拒绝服务攻击</h4><p>反射型的 DDoS 攻击是一种新的变种。攻击者并不直接攻击目标服务 IP，而是利用互联网的某些特殊服务开放的服务器，通过伪造被攻击者的 IP 地址、向有开放服务的服务器发送构造的请求报文，该服务器会将数倍于请求报文的回复数据发送到被攻击 IP（很多协议的请求包要远小于回复包，以一个字节的数据换十个字节的数据回来，这就是一种放大），从而对后者间接形成 DDoS 攻击。</p><h5 id="Ntp-Request-Flood"><a href="#Ntp-Request-Flood" class="headerlink" title="Ntp Request Flood"></a>Ntp Request Flood</h5><p>攻击原理：Ntp协议即为网络时间同步的udp协议，用于在分布式NTP服务器和客户端之间进行时间同步。NTP攻击，基于UDP协议，攻击者向NTP服务器发送大量的请求报文，占用服务器带宽使其阻塞，达到NTP攻击的目的。</p><h5 id="Udp-反射-Flood"><a href="#Udp-反射-Flood" class="headerlink" title="Udp 反射 Flood"></a>Udp 反射 Flood</h5><p>攻击原理：有时被保护服务器也有同外部服务器进行udp交互的需求，攻击者就会利用此交互对被保护服务器进行udp反射放大攻击。此攻击在短时间那冒充被攻击地址向外部公用的服务器发送大量的udp请求包，外部服务器收到虚假的udp请求就会回复大量的回应包给被攻击服务器地址，造成目标主机被保护服务器不能处理其他正常的交互流。</p><h2 id="僵尸网络"><a href="#僵尸网络" class="headerlink" title="僵尸网络"></a>僵尸网络</h2><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>类型：Syn Flood</p><p>攻击机：Kali</p><p>目标机：win7</p><p>方案：首先扫描网段，选择攻击目标，确认能够连通之后（简单地使用ping命令即可，或者检测是否未host状态）伪装自身ip，发起攻击，攻击者使用53端口，攻击端口为445端口（一个tcp端口，且大多数人都不会关闭），接下来发出攻击，目标主机会瘫痪，并无法响应，如果成效不佳，修改发包速度即可。</p><p> 步骤：</p><p>扫描网段：</p><p>​           <img src="/images/1651656101098.png" alt="1651656101098">                     </p><p>.2为网关，.135为攻击目标，.10为攻击机</p><p>Ping命令测试是否连接</p><p>  <img src="/images/1651656118160.png" alt="1651656118160"></p><p>扫描开放端口</p><p>  <img src="/images/1651656131091.png" alt="1651656131091"></p><p>终端中写出命令攻击</p><p>  <img src="/images/1651656138623.png" alt="1651656138623"></p><p>攻击后抓包结果：发包成功！</p><p>  <img src="/images/1651656145372.png" alt="1651656145372"></p><p>被攻击端查看分析更加细节的参数。</p><p><img src="/images/1651659917685.png" alt="1651659917685"></p><p>啊这 发现攻击端CPU资源占满了，尴尬了，应该是虚拟机建立时分配给kali机的资源太少了。</p><p><img src="/images/1651656161608.png" alt="1651656161608"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;拒绝服务攻击&quot;&gt;&lt;a href=&quot;#拒绝服务攻击&quot; class=&quot;headerlink&quot; title=&quot;拒绝服务攻击&quot;&gt;&lt;/a&gt;拒绝服务攻击&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>反序列化漏洞</title>
    <link href="http://example.com/2022/04/15/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2022/04/15/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-04-15T13:07:58.616Z</published>
    <updated>2022-04-15T13:07:58.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;反序列化漏洞&quot;&gt;&lt;a href=&quot;#反序列化漏洞&quot; class=&quot;headerlink&quot; title=&quot;反序列化漏洞&quot;&gt;&lt;/a&gt;反序列化漏洞&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>命令注入攻击</title>
    <link href="http://example.com/2022/04/15/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/"/>
    <id>http://example.com/2022/04/15/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/</id>
    <published>2022-04-15T13:03:24.014Z</published>
    <updated>2022-04-23T11:57:47.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令注入攻击"><a href="#命令注入攻击" class="headerlink" title="命令注入攻击"></a>命令注入攻击</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>命令执行漏洞是指服务器没有对执行的命令进行过滤，用户可以随意执行系统命令，命令执行漏洞属于高危漏洞之一<br>如PHP的命令执行漏洞主要是基于一些函数的参数过滤不足导致，可以执行命令的函数有system( )、exec( )、shell_exec( )、passthru( )、pcntl_execl( )、popen( )、proc_open( )等，当攻击者可以控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行攻击<br>PHP执行命令是继承WebServer用户的权限，这个用户一般都有权限向Web目录写文件，可见该漏洞的危害性相当大</p><h2 id="漏洞分类"><a href="#漏洞分类" class="headerlink" title="漏洞分类"></a>漏洞分类</h2><ul><li>代码层过滤不严</li></ul><p>商业应用的一些核心代码封装在二进制文件中，在web应用中通过system函数来调用：system(“/bin/program –arg $arg”);</p><ul><li>系统的漏洞造成命令注入</li></ul><p>bash破壳漏洞（CVE-2014-6271）</p><ul><li>调用的第三方组件存在代码执行漏洞</li></ul><p>如wordPress中用来处理图片的imageMagick组件<br>JAVA中的命令执行漏洞（struts2/ElasticsearchGroovy等）<br>ThinkPHP命令执行</p><h2 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h2><ul><li>php代码相关<br>eval()<br>assert()<br>preg_replace<br>call_user_func()<br>call_user_func_array()<br>create_function<br>array_map()</li><li>系统命令执行相关<br>system()<br>passthru()<br>exec()<br>pcntl_exec()<br>shell_exec()<br>popen()<br>proc_open()<br>`(反单引号)<br>ob_start()</li><li>特殊函数<br>phpinfo()<br>#这个文件里面包含了PHP的编译选项，启动的扩展、版本、服务器配置信息、环境变量、操作系统信息、path变量等非常重要的敏感配置信息<br>symlink()：<br>#一般是在linux服务器上使用的，为一个目标建立一个连接，在读取这个链接所连接的文件的内容，并返回内容<br>getenv<br>#获取一个环境变量的值</li></ul><p>​       putenv($a)<br>#添加$a到服务器环境变量，但环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态 </p><h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><ul><li>编码绕过</li><li>进制绕过</li><li>空格绕过</li><li><code>&gt;</code>,+绕过</li><li>关键词绕过</li><li>空变量绕过</li><li>使用花括号</li><li>长度绕过</li><li>get_defined_functions</li><li>字符数组</li><li>引号逃逸</li><li>无回显的命令执行</li><li>读文件命令</li></ul><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><ul><li>继承Web服务器程序的权限，去执行系统命令或读写文件</li><li>反弹shell</li><li>控制整个网站，甚至控制整个服务器</li></ul><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><ol><li>尽量少用执行命令的函数或者直接禁用</li><li>参数值尽量使用引号包括</li><li>在使用动态函数之前，确保使用的函数是指定的函数之一</li><li>在进入执行命令的函数/方法之前，对参数进行过滤，对敏感字符进行转义</li><li>对PHP语言来说，不能完全控制的危险函数最好不要使用</li></ol><p>参考文献：</p><p><a href="https://blog.csdn.net/LYJ20010728/article/details/117349106">https://blog.csdn.net/LYJ20010728/article/details/117349106</a></p><p> <a href="https://www.cnblogs.com/happystudyhuan/p/11458455.html">命令执行漏洞 - 再简单一点点 - 博客园 (cnblogs.com)</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;命令注入攻击&quot;&gt;&lt;a href=&quot;#命令注入攻击&quot; class=&quot;headerlink&quot; title=&quot;命令注入攻击&quot;&gt;&lt;/a&gt;命令注入攻击&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>文件包含漏洞</title>
    <link href="http://example.com/2022/04/15/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2022/04/15/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-04-15T13:01:26.030Z</published>
    <updated>2022-04-23T11:18:42.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p> 文件包含漏洞的产生原因是在通过 PHP 的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。 然而 PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。 </p><ul><li> <strong>php://input</strong>可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。从而导致任意代码执行。 </li><li> <strong>php://filter</strong>可以获取指定文件源码。当它与包含函数结合时，php://filter流会被当作php文件执行。所以我们一般对其进行编码，让其不执行。从而导致 任意文件读取。 </li><li> <strong>zip://</strong> 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。 </li><li> <strong>data://</strong> 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。 </li></ul><p><strong>存在漏洞的环境要求</strong></p><ul><li>allow_url_fopen=On(默认为On) 规定是否允许从远程服务器或者网站检索数据</li><li>allow_url_include=On(php5.2之后默认为Off) 规定是否允许include/require远程文件</li></ul><p><strong>常见的文件包含漏洞</strong></p><ul><li>include( )<br>当使用该函数包含文件时，只有代码执行到 include()函数时才将文件包含<br>进来，发生错误时之给出一个警告，继续向下执行。</li><li>include_once( )<br>功能与Include()相同，区别在于当重复调用同一文件时，程序只调用一次</li><li>require( )<br>require()与include()的区别在于require()执行如果发生错误，函数会输出<br>错误信息，并终止脚本的运行。</li><li>require_once( )<br>功能与require()相同，区别在于当重复调用同一文件时，程序只调用一次</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>本地文件包含漏洞</li></ul><p> 当被包含的文件在服务器本地时，就形成的本地文件包含漏洞。 </p><ul><li>远程文件包含漏洞 </li></ul><p>当php.ini 中的配置选项allow_url_fopen和allow_url_include为ON的话，则包含的文件可以</p><p>是第三方服务器中的文件，这样就形成了远程文件包含漏洞。</p><h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><p>可以通过<strong>page=xxx</strong>来打开相应的文件，此时漏洞点就暴露出来，此时我们可以尝试打开一些私密性的文件，以 <strong>/etc/passwd</strong> 和 <strong>/var/www/phpinfo.php</strong>文件为例，只要有足够的权限，在此处就可以打开想打开的文件。 </p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><p>大小写绕过 双写绕过等等</p><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><p>参考文献：<a href="https://blog.csdn.net/weixin_42277564/article/details/80641849">https://blog.csdn.net/weixin_42277564/article/details/80641849</a></p><p> <a href="https://blog.csdn.net/qq_42181428/article/details/87090539">(60条消息) CTF中文件包含漏洞总结_LetheSec的博客-CSDN博客_文件包含漏洞</a> </p><p> <a href="https://blog.csdn.net/weixin_43726831/article/details/102534850">(60条消息) DVWA靶机-文件包含漏洞(File Inclusion)_小边同学的博客-CSDN博客</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件包含漏洞&quot;&gt;&lt;a href=&quot;#文件包含漏洞&quot; class=&quot;headerlink&quot; title=&quot;文件包含漏洞&quot;&gt;&lt;/a&gt;文件包含漏洞&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>文件上传漏洞</title>
    <link href="http://example.com/2022/04/15/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2022/04/15/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-04-15T12:59:51.781Z</published>
    <updated>2022-04-22T01:24:18.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在文件上传的功能处，若服务端脚本语言未对上传的文件进行严格验证和过滤，导致恶意用户上传恶意的脚本文件时，就有可能获取执行服务端命令的能力，这就是文件上传漏洞。  文件上传漏洞对Web应用来说是一种非常严重的漏洞。一般情况下，Web应用都会允许用户上传一些文件，如头像、附件等信息，如果Web应该没有对用户上传的文件进行有效的检查过滤，那么恶意用户就会上传一句话木马等webshell，从而达到控制web网站的目的。</p><h2 id="文件过滤及绕过"><a href="#文件过滤及绕过" class="headerlink" title="文件过滤及绕过"></a>文件过滤及绕过</h2><h3 id="前端过滤"><a href="#前端过滤" class="headerlink" title="前端过滤"></a>前端过滤</h3><h4 id="检测原理"><a href="#检测原理" class="headerlink" title="检测原理"></a>检测原理</h4><p>如果浏览器页面没有刷新、或打开burp抓包没有抓到包、或者通过查看前端HTML代码等方式验证证明前端JS验证</p><h4 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h4><p>简单粗暴通过删除其HTML代码对应的JS代码即可。</p><h3 id="后端过滤"><a href="#后端过滤" class="headerlink" title="后端过滤"></a>后端过滤</h3><h4 id="后端过滤一般用到的函数"><a href="#后端过滤一般用到的函数" class="headerlink" title="后端过滤一般用到的函数"></a>后端过滤一般用到的函数</h4><p>1、trim() 去除字符串两边的空格<br>2、deldot() 删除文件名末尾的点号<br>3、strrchr() 反向截取字符串<br>4、strtolower() 转化为小写<br>5、str_ireplace() 替换字符串中的内容<br>6、substr() 获取子字符串<br>7、strrpos() 获取字符串的位置信息<br>8、fopen() 打开文件<br>9、fread() 读取文件<br>10、unpack() 函数从二进制字符串对数据进行解包</p><h4 id="MIME类型检测绕过"><a href="#MIME类型检测绕过" class="headerlink" title="MIME类型检测绕过"></a>MIME类型检测绕过</h4><p> 当用户上传文件到服务器端的时候，服务器端的程序会获取上传文件的MIME类型，然后用这个获取到的类型来和期望的MIME类型进行匹配，如果匹配不上则说明上传的文件不合法。   </p><p><strong>绕过方法</strong></p><p>因为服务端检测的是文件的MIME类型，而对这个MIME类型的值的获取是通过HTTP请求字段里的Content-Type字段，所以绕过的方法就是通过修改Content-Type的值，比如修改为image/jpeg；image/png；image/gif等等允许上传类型对应的MIME值；</p><h4 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h4><p>后端过滤函数中不包括，$file_ext = strtolower($life_ext);//转换为小写 且所有后缀名过滤都过滤</p><p><strong>绕过方法</strong></p><p>修改后缀名为大写</p><h4 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h4><p>后端过滤函数中不包含，$file_ext = trim($file_ext);//首尾去空 且所有后缀名过滤都过滤</p><p><strong>绕过方法</strong></p><p>修改后缀名增加空格</p><h4 id="点绕过"><a href="#点绕过" class="headerlink" title="点绕过"></a>点绕过</h4><p>后端过滤函数中不包括，$file_name = deldot($file_name);//删除文件名末尾的点 且所有后缀名过滤都过滤，利用Windows特性，会自动去掉后缀名中最后的“ . ”，可在后缀名中加“ . ”绕过。</p><p><strong>绕过方法</strong></p><p>修改后缀名中增加 . 号</p><h4 id="点-空格-点-绕过"><a href="#点-空格-点-绕过" class="headerlink" title="点 空格 点 绕过"></a>点 空格 点 绕过</h4><p>保存文件的时候没有重命名而使用原始的文件名，导致可以利用1.php. .（点+空格+点）来绕过，条件比较苛刻</p><p><strong>绕过方法</strong></p><p>修改后缀，利用 1.php. . （点+空格+点）来绕过</p><h4 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h4><p>后端处理函数中包含了 str_ireplace($deny_ext,“”,$file_name);</p><p><strong>绕过方法</strong></p><p>把后缀名更改为pphphp</p><h4 id="00截断"><a href="#00截断" class="headerlink" title="00截断"></a>00截断</h4><p>后端采用白名单判断，但图片的路径是直接拼接出，例如： $img_path = $_GET[‘save_path’].”/“.rand(10,99).date(“YmdHis”).”.”.$file_ext;</p><p><strong>绕过方法</strong></p><p>可以利用%00截断绕过（传入save_path参数时加上）；但是有条件 截断条件：php版本小于5.3.4，php的magic_quotes_gpc为OFF状态</p><p>0x00是十六进制表示方法，是ascii码为0的字符，在有些函数处理时，会把这个字符当作结束符，而%00，是url对ascii编码再加%处理，url反编码后一样。</p><h4 id="图片马绕过"><a href="#图片马绕过" class="headerlink" title="图片马绕过"></a>图片马绕过</h4><p>通过读写文件的前2个字节判断文件类型</p><p><strong>绕过方法</strong></p><p>上传图片马</p><p>getimagesize()-图片马： 通过getimagesizi获取图片文件的类型 </p><p>exif_imagetype()-图片马：获取图片中文件的类型，需要开启php的配置文件的php_exif模块，上传图片马</p><h4 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h4><p> 服务器程序根据一份文件后缀名名单来判断是否允许当前文件上传到服务器，只要上传的文件的类型能够和黑名单里面的类型匹配，那么就禁止该文件上传 </p><p><strong>绕过方法</strong>：</p><p>①文件名大小写绕过 用像AsP、PhP之类的文件名绕过黑名单检测</p><p>②名单列表绕过 用黑名单里没有的名单进行攻击，比如黑名单里没有asa或cer之类</p><p>③特殊文件名绕过 比如发送的http包里把文件名改成test.asp. 或test.asp_(下划线为空格)，这种命名方式在Windows系统里是不被允许的，所以需要在burp之类里进行修改，然后绕过验证后，会被Windows系统自动去掉后面的点和空格，但是主要Unix/Linux系统没有这个特性。</p><h4 id="二次渲染绕过"><a href="#二次渲染绕过" class="headerlink" title="二次渲染绕过"></a>二次渲染绕过</h4><p>文件上传成功后，经过二次渲染，所谓二次渲染就是重新在生成一次图片，容易把图片马中的PHP代码修改掉。</p><p><strong>绕过方法</strong></p><p>php代码不能放在最后，对于不同的图片，修改的位置还不一样</p><h4 id="htaccess绕过"><a href="#htaccess绕过" class="headerlink" title="htaccess绕过"></a>htaccess绕过</h4><p> 黑名单里拒绝了几乎所有有问题的后缀名，除了.htaccess；前提条件httpd.conf的两个开关设置要求：(1.mod_rewrite模块开启。2.AllowOverride All) </p><p><strong>绕过方法：</strong></p><p>第一步：先上传一个.htaccess文件（该目录的所有文件可以php文件执行），内容如下： SetHandler application/x-httpd-php</p><p>第二步：然后再上传一句话木马（后缀名修改为jpg）</p><h4 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h4><p>条件竞争，先将文件上传到服务器，然后判断文件后缀是否在白名单里，如果在则重命名，否则删除，因此可以上传1.php只需要在它删除之前访问即可，可以利用burp的intruder模块不断上传，然后我们不断的访问刷新该地址即可； 目的就是在文件还存在时执行一段php代码，比如新建一个文件，写入一句话。</p><p>代码：file_put_contents(‘webshell.php’,’<?php @eval($_POST[pass]); ?>‘);</p><h4 id="DATA绕过"><a href="#DATA绕过" class="headerlink" title="::$DATA绕过"></a>::$DATA绕过</h4><p>后端过滤函数中不包括，$file_ext = str_ireplace(‘::$DATA’, ‘’, $file_ext);//去除字符串::$DATA，后端没有对后缀名中的‘::$DATA’进行过滤，在php+windows的情况下，如果文件名+“::$DATA”会把::$DATA之后的数据当成文件流处理，不会检测后缀名. 且保持”::$DATA”之前的文件</p><p><strong>绕过方法</strong></p><p>利用Windows特性，可在后缀名中加“::$DATA”绕过</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><p>参考资料：<a href="https://blog.csdn.net/weixin_56218159/article/details/117536647">https://blog.csdn.net/weixin_56218159/article/details/117536647</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件上传漏洞&quot;&gt;&lt;a href=&quot;#文件上传漏洞&quot; class=&quot;headerlink&quot; title=&quot;文件上传漏洞&quot;&gt;&lt;/a&gt;文件上传漏洞&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>跨站请求伪造CSPF</title>
    <link href="http://example.com/2022/04/15/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0CSPF/"/>
    <id>http://example.com/2022/04/15/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0CSPF/</id>
    <published>2022-04-15T12:22:52.117Z</published>
    <updated>2022-04-21T14:49:06.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跨站请求伪造CSPF"><a href="#跨站请求伪造CSPF" class="headerlink" title="跨站请求伪造CSPF"></a>跨站请求伪造CSPF</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>   每次我们对网站进行身份验证或登录时，会话 cookie 都会存储在浏览器中。因此，每当我们向网站提出请求时，这些 cookie 就会自动发送到服务器，服务器通过匹配与服务器记录一起发送的 cookie 来识别我们。<br>       CSRF 攻击通常以链接的形式出现。我们可以在其他网站上点击它们或通过电子邮件接收它们。单击这些链接时，会向服务器发出不需要的恶意请求，而服务器认为我们发出了这个请求并对其进行了身份验证，然后攻击者就可以借用用户的名义做坏事啦~  </p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="GET型"><a href="#GET型" class="headerlink" title="GET型"></a>GET型</h3><h3 id="POST型"><a href="#POST型" class="headerlink" title="POST型"></a>POST型</h3><h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><p>​    </p><p>1、 抓取一个正常请求的数据包，如果没有Referer字段和token，那么极有可能存在CSRF漏洞<br>2、 如果有Referer字段，但是去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。<br>3、 利用工具进行CSRF检测。如：CSRFTESTER，CSRF REQUEST BUILDER等</p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ol><li> 检查Referer字段 ： HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。  但也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。 </li><li>  添加校验token ： 这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，其内容是一个伪随机数。当客户端通过窗体提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求。 </li><li>SameSite Cookie属性：谷歌提出了same-site cookies概念，same-site cookies 是基于 Chrome 和 Mozilla 开发者花了三年多时间制定的 IETF 标准。它是在原有的Cookie中，新添加了一个SameSite属性，它标识着在非同源的请求中，是否可以带上Cookie</li></ol><p>参考资料：<a href="https://blog.csdn.net/abu935009066/article/details/114366771">https://blog.csdn.net/abu935009066/article/details/114366771</a></p><p><a href="https://blog.csdn.net/whoim_i/article/details/103171778">https://blog.csdn.net/whoim_i/article/details/103171778</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;跨站请求伪造CSPF&quot;&gt;&lt;a href=&quot;#跨站请求伪造CSPF&quot; class=&quot;headerlink&quot; title=&quot;跨站请求伪造CSPF&quot;&gt;&lt;/a&gt;跨站请求伪造CSPF&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>跨站脚本攻击xss</title>
    <link href="http://example.com/2022/04/15/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BBxss/"/>
    <id>http://example.com/2022/04/15/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BBxss/</id>
    <published>2022-04-15T11:57:10.333Z</published>
    <updated>2022-04-20T06:26:32.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跨站脚本攻击xss"><a href="#跨站脚本攻击xss" class="headerlink" title="跨站脚本攻击xss"></a>跨站脚本攻击xss</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p> 恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页面时，嵌入Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。XSS攻击针对的是用户层面的攻击。 </p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h3><p>  存储型XSS，持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，插入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie </p><h3 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h3><p>  非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。反射型XSS大多数是用来盗取用户的Cookie信息。 </p><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p> 不经过后端，DOM-XSS漏洞是基于文档对象模型(Document Objeet Model,DOM)的一种漏洞，DOM-XSS是通过url传入参数去控制触发的，其实也属于反射型XSS。 </p><h2 id="漏洞探测"><a href="#漏洞探测" class="headerlink" title="漏洞探测"></a>漏洞探测</h2><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>尽可能找到一切用户可控并且能够输出在页面代码中的地方，比如下面这些：</p><ul><li>URL的每一个参数</li><li>URL本身</li><li>表单</li><li>搜索框</li></ul><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p> 关于XSS的代码审计主要就是从接收参数的地方和一些关键词入手。 </p><p> 也可以搜索类似<code>echo</code>这样的输出语句，跟踪输出的变量是从哪里来的，我们是否能控制，如果从数据库中取的，是否能控制存到数据库中的数据，存到数据库之前有没有进行过滤等等。 </p><p> 同理审计DOM型注入可以搜索一些js操作DOM元素的关键词进行审计。 </p><h2 id="xss攻击"><a href="#xss攻击" class="headerlink" title="xss攻击"></a>xss攻击</h2><h3 id="攻击载荷"><a href="#攻击载荷" class="headerlink" title="攻击载荷"></a>攻击载荷</h3><script>标签：<script>标签是最直接的XSS有效载荷, 脚本标记可以引用外部的JavaScript代码,也可以将代码插入脚本标记中    -----------------------------     <script>alert("hello")</script>   #弹出hello<pre><code> &lt;script&gt;alert(/hello/)&lt;/script&gt;   #弹出hello &lt;script&gt;alert(1)&lt;/script&gt;        #弹出1,对于数字可以不用引号 &lt;script&gt;alert(document.cookie)&lt;/script&gt;      #弹出cookie &lt;script src=http://xxx.com/xss.js&gt;&lt;/script&gt;  #引用外部的xss------------------------------</code></pre><p> <svg>标签：<br/>    ——————————<br/>     <svg onload="alert(1)"><br/>     &lt;svg onload=”alert(1)”//<br/>    ——————————<br/> <img/>标签：<br/>    ——————————<br/>     &lt;img  src=1  οnerrοr=alert(“hack”)&gt;<br/>     &lt;img  src=1  οnerrοr=alert(document.cookie)&gt;  #弹出cookie<br/>    ——————————</svg></svg></p><body>标签：    ------------------------------     <body οnlοad="alert(1)">     <body οnpageshοw="alert(1)">    ------------------------------<video>标签：    ------------------------------     <video οnlοadstart="alert(1)" src="/media/hack-the-planet.mp4">    ------------------------------<Style>标签：    ------------------------------     <style οnlοad=alert(1)>    ------------------------------<h3 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h3><ol><li>大小写绕过</li><li>双写型 &lt;sc&lt; script&gt;ript&gt;alert(“x”);&lt;/ script&gt; </li><li>换标签，比如过滤了script，就试一试img</li><li></li></ol><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><h3 id="DOM型XSS-1"><a href="#DOM型XSS-1" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>发现一个网站存在反射型XSS，当用户登录该网站时，我们通过诱使用户点击我们精心制作的恶意链接，来盗取用户的Cookie并且发送给我们，然后我们再利用盗取的Cookie以用户的身份登录该用户的网站。</p><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>参考文献： <a href="https://blog.csdn.net/weixin_40950781/article/details/100007103">(58条消息) DVWA学习之XSS（跨站脚本攻击）（超级详细）_litchi125的博客-CSDN博客_dvwa xss</a> </p></Style></video></video></body></body></body>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;跨站脚本攻击xss&quot;&gt;&lt;a href=&quot;#跨站脚本攻击xss&quot; class=&quot;headerlink&quot; title=&quot;跨站脚本攻击xss&quot;&gt;&lt;/a&gt;跨站脚本攻击xss&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SQL注入</title>
    <link href="http://example.com/2022/04/15/SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://example.com/2022/04/15/SQL%E6%B3%A8%E5%85%A5/</id>
    <published>2022-04-15T11:02:19.737Z</published>
    <updated>2022-05-09T12:08:04.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="一-SQL注入原理"><a href="#一-SQL注入原理" class="headerlink" title="一.SQL注入原理"></a>一.SQL注入原理</h2><p>  web 应用程序对用户输入的数据合法性没有过滤或者是判断，<strong>前端传入的参数</strong>是攻击者可以控制，并且**参数带入数据库的查询 **，攻击者可以通过构造恶意的 sql 语句来实现对数据库的任意操作。例如一般用户登录用的SQL语句为：SELECT * FROM user WHERE username=’admin’ AND password=’passwd’，此处admin和passwd分别为用户输入的用户名和密码，如果程序员没有对用户输入的用户名和密码做处理，就可以构造万能密码成功绕过登录验证，如用户输入’or 1#,SQL语句将变为：SELECT * FROM user WHERE username=’’or 1#’ AND password=’’，‘’or 1为TRUE，#注释掉后面的内容，所以查询语句可以正确执行。</p><p> sql注入漏洞攻击流程：注入点探测—信息获取—获取权限</p><h2 id="二-数据库"><a href="#二-数据库" class="headerlink" title="二.数据库"></a>二.数据库</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>在 MySQL5.0 版本后，MySQL 默认在数据库中存放一个information_schema的数据库，在该库中，我们需要记住三个表名，分别是 schemata，tables，columns。</p><ul><li>Schemata 表存储的是该用户创建的所有数据库的库名，需要记住该表中记录数据库名的字段名为 schema_name。</li><li>Tables 表存储该用户创建的所有数据库的库名和表名，要记住该表中记录数据库 库名和表名的字段分别是 table_schema 和 table_name</li><li>Columns 表存储该用户创建的所有数据库的库名、表名、字段名，要记住该表中记录数据库库名、表名、字段名为 table_schema、。</li></ul><h2 id="三-重要函数"><a href="#三-重要函数" class="headerlink" title="三.重要函数"></a>三.重要函数</h2><ul><li><p>Version()；当前 mysql 的版本</p></li><li><p> Database();当前网站使用的数据库</p></li><li><p>User();当前 MySQL 的用户</p></li><li><p> system_user(); 系统用户名</p></li><li><p>session_user();连接数据库的用户名</p></li><li><p>current_user;当前用户名</p></li><li><p>load_file();读取本地文件</p></li><li><p>length(str) : 返回给定字符串的长度，如 length(“string”)=6</p></li><li><p>substr(string,start,length) : 对于给定字符串string，从start位开始截取，截取length长度 ,如 substr(“chinese”,3,2)=“in”<br>substr()、stbstring()、mid() 三个函数的用法、功能均一致</p></li><li><p>concat(username)：将查询到的username连在一起，默认用逗号分隔<br>concat(str1,’’,str2)：将字符串str1和str2的数据查询到一起，中间用连接group_concat(username) ：将username数据查询在一起，用逗号连接</p></li><li><p>三种注释符号： </p><h1 id><a href="#" class="headerlink" title></a></h1><p> –空格 空格可以使用+代替 （url 编码%23 表示注释）<br> /**/</p></li></ul><h2 id="四-SQL注入的类型"><a href="#四-SQL注入的类型" class="headerlink" title="四.SQL注入的类型"></a>四.SQL注入的类型</h2><h3 id="按注入点类型分类"><a href="#按注入点类型分类" class="headerlink" title="按注入点类型分类"></a>按注入点类型分类</h3><h4 id="数字型注入点"><a href="#数字型注入点" class="headerlink" title="数字型注入点"></a>数字型注入点</h4><p> 类似结构 <a href="http://xxx.com/users.php?id=1">http://xxx.com/users.php?id=1</a> 基于此种形式的注入，一般被叫做数字型注入点，缘由是其注入点 id 类型为数字。</p><h4 id="字符型注入点"><a href="#字符型注入点" class="headerlink" title="字符型注入点"></a>字符型注入点</h4><p> 类似结构 <a href="http://xxx.com/users.php?name=admin">http://xxx.com/users.php?name=admin</a> 这种形式，其注入点 name 类型为字符类型，所以叫字符型注入点。 </p><p><img src="/C:/Users\ASUS\AppData\Roaming\Typora\typora-user-images\1650098909906.png" alt="1650098909906"><img src="/C:/Users\ASUS\AppData\Roaming\Typora\typora-user-images\1650098933704.png" alt="1650098933704"></p><h4 id="搜索型注入点"><a href="#搜索型注入点" class="headerlink" title="搜索型注入点"></a>搜索型注入点</h4><p>这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有 “keyword=关键字” 有的不显示在的链接地址里面，而是直接通过搜索框表单提交。此类注入点提交的 SQL 语句，其原形大致为：select * from 表名 where 字段 like ‘%关键字%’ 若存在注入。</p><h3 id="按数据提交的方式来分类"><a href="#按数据提交的方式来分类" class="headerlink" title="按数据提交的方式来分类"></a>按数据提交的方式来分类</h3><h4 id="GET注入"><a href="#GET注入" class="headerlink" title="GET注入"></a>GET注入</h4><p> 提交数据的方式是 GET , 注入点的位置在 GET 参数部分。 </p><h4 id="POST注入"><a href="#POST注入" class="headerlink" title="POST注入"></a>POST注入</h4><p> 使用 POST 方式提交数据，注入点位置在 POST <em>数据部分</em> 。</p><h4 id="Cookie注入"><a href="#Cookie注入" class="headerlink" title="Cookie注入"></a>Cookie注入</h4><p> HTTP 请求的时候会带上客户端的 Cookie, 注入点存在 Cookie 当中的某个字段中。 </p><h4 id="HTTP头部注入"><a href="#HTTP头部注入" class="headerlink" title="HTTP头部注入"></a>HTTP头部注入</h4><p> 注入点在 HTTP 请求头部的某个字段中。比如存在 User-Agent 字段中。严格讲的话，Cookie 其实应该也是算头部注入的一种形式。因为在 HTTP 请求的时候，Cookie 是头部的一个字段。 </p><h3 id="按照执行效果来分类"><a href="#按照执行效果来分类" class="headerlink" title="按照执行效果来分类"></a>按照执行效果来分类</h3><h4 id="基于布尔的盲注"><a href="#基于布尔的盲注" class="headerlink" title="基于布尔的盲注"></a>基于布尔的盲注</h4><p> 可以根据返回页面判断条件真假的注入。 </p><h4 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h4><p> 不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。 </p><h4 id="基于报错注入"><a href="#基于报错注入" class="headerlink" title="基于报错注入"></a>基于报错注入</h4><p> 页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。 </p><h4 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h4><p> 使用union的情况下的注入。 </p><h4 id="堆查询注入"><a href="#堆查询注入" class="headerlink" title="堆查询注入"></a>堆查询注入</h4><p> 可以同时执行多条语句的执行时的注入。 </p><h4 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h4><h4 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h4><h4 id="json注入"><a href="#json注入" class="headerlink" title="json注入"></a>json注入</h4><h4 id="DNSlog注入"><a href="#DNSlog注入" class="headerlink" title="DNSlog注入"></a>DNSlog注入</h4><h4 id="SQL-注入写入webshell"><a href="#SQL-注入写入webshell" class="headerlink" title="SQL 注入写入webshell"></a>SQL 注入写入webshell</h4><h4 id="limit注入"><a href="#limit注入" class="headerlink" title="limit注入"></a>limit注入</h4><h2 id="五-注入点探测"><a href="#五-注入点探测" class="headerlink" title="五.注入点探测"></a>五.注入点探测</h2><h3 id="判断是否存在注入"><a href="#判断是否存在注入" class="headerlink" title="判断是否存在注入"></a>判断是否存在注入</h3><p>引号判断： 无论字符型还是整型都会因为单引号个数不匹配而报错。 </p><h3 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h3><p> 总之数字型注入不需要使用单引号闭合前面的单引号就可以执行SQL语句，而字符型必须闭合前面的单引号，然后才可以执行SQL语句，同时也需要把后面的单引号闭合，而注释就是很好的一种闭合后面的单引号的方法。 方法不唯一。</p><ol><li>id=1’无（我觉得应该是异常的）异常      id=1and 1=1—+正确显示      id=1and1=2—+ 错误          ===&gt;数字注入</li><li>id=1‘异常          id=1’and‘1’=‘1—+正确               id=1‘and’1‘=’2–+错误          ===&gt;单引号字符型注入</li></ol><p>GET型注入很容易从URL中看出来，如图，网页的URL为：<a href="http://127.0.0.1/DVWA/vulnerabilities/sqli/?id=1%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E9%80%9A%E5%B8%B8%E4%BD%BF%E7%94%A8?%E6%9D%A5%E8%A1%A8%E7%A4%BAGET%E6%96%B9%E6%B3%95%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%EF%BC%8C%E8%80%8C%E4%BD%BF%E7%94%A8POST%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%8D%E4%BC%9A%E6%98%BE%E7%A4%BA%E5%88%B0URL%E4%B8%AD%E7%9A%84%EF%BC%8C%E5%9B%A0%E6%AD%A4URL%E4%B8%AD%E5%90%AB%E6%9C%89%EF%BC%9F%E8%AF%B4%E6%98%8E%E5%B0%B1%E6%98%AF%E4%BD%BF%E7%94%A8GET%E6%96%B9%E6%B3%95%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%EF%BC%8C">http://127.0.0.1/DVWA/vulnerabilities/sqli/?id=1，浏览器通常使用?来表示GET方法传递参数，而使用POST传递参数是不会显示到URL中的，因此URL中含有？说明就是使用GET方法传递参数，</a></p><h3 id="判断数据库类型"><a href="#判断数据库类型" class="headerlink" title="判断数据库类型"></a>判断数据库类型</h3><p>1’ or ‘ab’=’a+’b ————–MS SQLserver数据库，字符串连接，成功这返回永真条件<br>1’ or ‘ab’=‘a’’b —————Mysql数据库，字符串连接，成功这返回永真条件<br>1’ or ‘ab’=‘a’||’b ————-Oracle数据库，字符串连接，成功这返回永真条件</p><h3 id="确定数据库权限"><a href="#确定数据库权限" class="headerlink" title="确定数据库权限"></a>确定数据库权限</h3><h3 id="查数据库的库名，表名，列名以及相应的数据"><a href="#查数据库的库名，表名，列名以及相应的数据" class="headerlink" title="查数据库的库名，表名，列名以及相应的数据"></a>查数据库的库名，表名，列名以及相应的数据</h3><p>猜测字段数：order by 3#</p><p>判断显示位：union select 1,2,3#</p><p> 获取当数据库名称和当前连接数据库的用户:  union select user(),database() </p><p> 列出所有数据库 union select 1,schema_name from information_schema.Schemata#</p><p> 列出中所有的表 -1’ union select table_name,table_schema from information_schema.tables#</p><p> 列出（数据库：mysql表：user）中的数据   -1’ union select User,Password from mysql.user#</p><p><img src="/C:/Users\ASUS\AppData\Roaming\Typora\typora-user-images\1650110416731.png" alt="1650110416731"></p><p>3、还有就是Timing Attack测试，也就是时间盲注。通过简单的条件语句比如 and 1=2 是无法看出异常的。在MySQL中，有一个Benchmark() 函数，它是用于测试性能的。 Benchmark(count,expr) ，这个函数执行的结果，是将表达式 expr 执行 count 次 。<br>因此，利用benchmark函数，可以让同一个函数执行若干次，使得结果返回的时间比平时要长，通过时间长短的变化，可以判断注入语句是否执行成功。</p><h2 id="五-SQL实战"><a href="#五-SQL实战" class="headerlink" title="五.SQL实战"></a>五.SQL实战</h2><h2 id="六-SQL绕过"><a href="#六-SQL绕过" class="headerlink" title="六.SQL绕过"></a>六.SQL绕过</h2><h2 id="七-关于SQL注入的防御"><a href="#七-关于SQL注入的防御" class="headerlink" title="七.关于SQL注入的防御"></a>七.关于SQL注入的防御</h2><p>参考链接：<a href="https://blog.csdn.net/whoim_i/article/details/102733802">https://blog.csdn.net/whoim_i/article/details/102733802</a> </p><p><a href="https://blog.csdn.net/qq_42263820/article/details/110132955">https://blog.csdn.net/qq_42263820/article/details/110132955</a></p><p> <a href="https://caichuanqi.blog.csdn.net/article/details/109611296?spm=1001.2101.3001.6650.13&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-13.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-13.pc_relevant_default&utm_relevant_index=15">(57条消息) 网页是否存在SQL注入(单引号判断法)_菜鸟-传奇的博客-CSDN博客</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL注入&quot;&gt;&lt;a href=&quot;#SQL注入&quot; class=&quot;headerlink&quot; title=&quot;SQL注入&quot;&gt;&lt;/a&gt;SQL注入&lt;/h1&gt;&lt;h2 id=&quot;一-SQL注入原理&quot;&gt;&lt;a href=&quot;#一-SQL注入原理&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux基本命令记录</title>
    <link href="http://example.com/2022/03/31/Linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/03/31/Linux%E5%91%BD%E4%BB%A4/</id>
    <published>2022-03-31T02:02:16.264Z</published>
    <updated>2022-05-09T12:08:14.435Z</updated>
    
    <content type="html"><![CDATA[<p>==Linux命查询网址==  <a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a> </p><h1 id="关机开机"><a href="#关机开机" class="headerlink" title="关机开机"></a>关机开机</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 关机</span><br><span class="line">shutdown -h now</span><br><span class="line"># 开机</span><br><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure><h1 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;==Linux命查询网址==  &lt;a href=&quot;https://www.linuxcool.com/&quot;&gt;Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)&lt;/a&gt; &lt;/p&gt;
&lt;h1 id=&quot;关机开机&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>owasp top10之SQL注入</title>
    <link href="http://example.com/2022/03/31/owasp-top10%E4%B9%8BSQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://example.com/2022/03/31/owasp-top10%E4%B9%8BSQL%E6%B3%A8%E5%85%A5/</id>
    <published>2022-03-30T16:00:00.000Z</published>
    <updated>2022-03-31T12:32:09.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a>sql注入原理</h1><p>​       SQL 注入就是指 web 应用程序对用户输入的数据合法性没有过滤或者是判断，前端传入的参数是攻击者可以控制，并且参数带入数据库的查询，攻击者可以通过构造恶意的 sql 语句来实现对数据库的任意操作。 </p><p>​        在 MySQL5.0 版本后，MySQL 默认在数据库中存放一个information_schema的数据库，在该库中，我们需要记住三个表名，分别是 schemata，tables，columns。</p><ul><li>Schemata 表存储的是该用户创建的所有数据库的库名，需要记住该表中记录数据库名的字段名为 schema_name。</li><li> Tables 表存储该用户创建的所有数据库的库名和表名，要记住该表中记录数据库 库名和表名的字段分别是 table_schema 和 table_name.</li><li>Columns 表存储该用户创建的所有数据库的库名、表名、字段名，要记住该表中记录数据库库名、表名、字段名为 table_schema、table_name、columns_name。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sql注入原理&quot;&gt;&lt;a href=&quot;#sql注入原理&quot; class=&quot;headerlink&quot; title=&quot;sql注入原理&quot;&gt;&lt;/a&gt;sql注入原理&lt;/h1&gt;&lt;p&gt;​       SQL 注入就是指 web 应用程序对用户输入的数据合法性没有过滤或者是判断，前端传</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Paillier加密算法学习</title>
    <link href="http://example.com/2021/11/20/Paillier%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/11/20/Paillier%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-11-19T16:00:00.000Z</published>
    <updated>2021-11-20T11:55:45.111Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="Paillier"><a href="#Paillier" class="headerlink" title="Paillier"></a>Paillier</h1><h2 id="Paillier方案原理"><a href="#Paillier方案原理" class="headerlink" title="Paillier方案原理"></a>Paillier方案原理</h2><h3 id="1-加法同态加密定义"><a href="#1-加法同态加密定义" class="headerlink" title="1 加法同态加密定义"></a>1 加法同态加密定义</h3><p>在描述具体方案之前，我们先定义加法PHE。首先列举方案具有的所有算法。</p><ul><li><p>KeyGen()：密钥生成算法。用于产生加密数据的公钥PK（Public Key）和私钥SK（Secret Key），以及一些公开常数PP（Public Parameter）；</p></li><li><p>Encrypt()：加密算法。使用PK对用户数据Data进行加密，得到密文CT（Ciphertext）；</p></li><li><p>Decrypt()：解密算法。用于解密得到数据原文PT（Plaintext）。</p></li></ul><p>HE除了加解密以外，还具有在密文上进行处理的能力，所以还应拥有“处理”算法。对于加法PHE，支持的算法有同态加以及同态标量乘（标量乘法可看作多次加法）。</p><ul><li><p>Add()：同态加算法。输入两个CT进行同态加运算。</p></li><li><p>ScalaMul()：同态标量乘算法。输入一个CT和一个标量PT，计算CT的标量乘结果。</p></li></ul><h3 id="2-Paillier方案描述"><a href="#2-Paillier方案描述" class="headerlink" title="2 .Paillier方案描述"></a>2 .Paillier方案描述</h3><p>原版Paillier方案于论文[1]中提出，下面对方案进行描述：</p><p><strong>密钥生成</strong></p><ol><li>随机选择两个大素数p, q满足 g c d ( p q , ( p − 1 ) ( q − 1 ) ) = 1，且满足p,q长度相等</li><li>计算n = pq以及 <img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8hB7pmaTbXM9xDnwxYTmibO3k6mhNoVP6mD7TNcnNBpqiaa91aBTNrW0Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">= lcm(p-1,q-1)，这里lcm表示最小公倍数，|n|为n的比特长度</li><li>随机选择整数<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H89sk6o8IEInqj3YPViapbzmFsXxXAZExr4VBVKcdziaF4OFBgzUJY6crA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li><li>定义L函数：<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H88duCtibT0KPSXjiaOxgIIa2cTMt2gdA6NfkzaCgEUichRcsvbNazxdxeQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> ，计算<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8nMjJHFicBJln9gajkGicYAiamXNZvdrLTfvwPiaW7ibntv5GMlxTShjicl1g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol><p>公钥： (n，g)，私钥：(<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8hB7pmaTbXM9xDnwxYTmibO3k6mhNoVP6mD7TNcnNBpqiaa91aBTNrW0Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">,<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8plwcwOOVbHFzzwzicwhfWuMZ9Xz1c0abqL1HhM7mTMZ3NznHDEg7EgA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">)</p><p><strong>加密</strong></p><ol><li>输入明文消息m， 满足<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8p89kNv9SVEfDcUDGICcnU56Jk0icESDNpyx7G9GupQDAaEZCZM7wANw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li><li>选择随机数r满足<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8RYa4iaz6HDu2wwbc2sticLOfu2w1xExn1QsRibiavPIIQDeU7FXwJl0cibw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li><li>计算密文<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8KhydoxAfpcm24zykickB68GPuqumtvdibYiafVAF7RUDELEic6UjRktVXQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol><p><strong>解密</strong></p><ol><li>输入密文c，满足<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8UWJXDUFZENXyJRVrs0iaaFiatVibgzUMlia6H3yCbZDb1X6icOoZianDnd5Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li><li>计算明文消息<img src="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8uHCbDA5O9D7z9rl1ALuwHTVUQ30nA0iaaCle8lxaThBNCeXwKAe0Efw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol><p><strong>同态加</strong></p><ol><li>对于密文<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8micY5TBR2y9j9Mn9J19dH0uSbfhuD2RuRKqL9Tc9KfWSZyNoLNIEkmw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">和<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8pXz6JUtgfibcjy81chaQx8Iby1icpl1NIEmP6qicwEiaZIxTIqGs8Pf30g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">，计算<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8DllEv1LQ2UgqkuB1PicKvJq6kbXicfzibfC1NPJhcUGfdsCyWqM67yGgg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol><p><strong>同态标量乘</strong></p><ol><li>对于密文<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8micY5TBR2y9j9Mn9J19dH0uSbfhuD2RuRKqL9Tc9KfWSZyNoLNIEkmw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">和标量a，计算<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H81DeCmtbIva4QdQLegtcoBibhtCDLVQY7o0zCzBw0ia8pvFXFSFYQhN5A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol><h3 id="3-正确性和安全性"><a href="#3-正确性和安全性" class="headerlink" title="3 正确性和安全性"></a>3 正确性和安全性</h3><p><strong>加解密正确性</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8icKs31SZR0rYpjBGj5pg9nye1P2fkTiaaoiadFYia3HZAFQM4K2L2vibcbg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>同态加正确性</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8WKaRo6RdU2LibshmdKaf2v32rPwHu0A97044Z5SUv3aOxG4iagY2FWdw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>同态标量乘正确性</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLwibdEtUibY1DhlWbRuzz4H8XW4Smbg4MjGpDh7nHOjDehbib9UyDWYG3ePJvZicYIKWh8rvhlbW8rxA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>安全性</strong></p><p>Paillier方案满足加密方案的标准安全定义：语义安全，即在选择明文攻击下的密文的不可区分性（IND-CPA）。直观地说，就是密文不会泄露明文中的任意信息。方案安全性可以归约到判定性合数剩余假设（Decisional Composite Residuosity Assumption, DCRA），即给定一个合数n和整数z，判定z是否在n^2下是否是n次剩余是困难的。这个假设经过了几十年的充分研究，到目前为止还没有多项式时间的算法可以攻破，所以Paillier加密方案的安全性被认为相当可靠。</p><p>参考文献：</p><p><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1637379742&amp;ver=3447&amp;signature=B1*kCo1ank92hE*YaqYrBNQmZEnavW79AK-R3VmkNp87zTGjG9zI0lpQJy3F32dC2gTbBByTrDTsbaybTwTu*MnZTM5ydPy43zEEMvVPHtJTXZQtS2ZKDZXHRVzXFgju&amp;new=1">https://mp.weixin.qq.com/s?src=11&amp;timestamp=1637379742&amp;ver=3447&amp;signature=B1*kCo1ank92hE*YaqYrBNQmZEnavW79AK-R3VmkNp87zTGjG9zI0lpQJy3F32dC2gTbBByTrDTsbaybTwTu*MnZTM5ydPy43zEEMvVPHtJTXZQtS2ZKDZXHRVzXFgju&amp;new=1</a></p><p><a href="https://blog.csdn.net/qq_40589204/article/details/116310125?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-10-116310125.pc_agg_new_rank&amp;utm_term=paillier%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95&amp;spm=1000.2123.3001.4430">https://blog.csdn.net/qq_40589204/article/details/116310125?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-10-116310125.pc_agg_new_rank&amp;utm_term=paillier%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95&amp;spm=1000.2123.3001.4430</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;Paillier&quot;&gt;&lt;a href=&quot;#Paillier&quot; class=&quot;headerlink&quot; title=&quot;Paillier&quot;&gt;&lt;/a&gt;Paillier&lt;/h1&gt;&lt;h2 id=&quot;Paillier方案原理&quot;&gt;&lt;a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JS操作问题</title>
    <link href="http://example.com/2021/11/20/%E5%89%8D%E7%AB%AF%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/JS%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/11/20/%E5%89%8D%E7%AB%AF%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/JS%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98/</id>
    <published>2021-11-19T16:00:00.000Z</published>
    <updated>2021-11-20T11:55:50.831Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="JS操作问题"><a href="#JS操作问题" class="headerlink" title="JS操作问题"></a>JS操作问题</h1><h2 id="1-alert（）弹出框确认后，实现页面跳转"><a href="#1-alert（）弹出框确认后，实现页面跳转" class="headerlink" title="1.alert（）弹出框确认后，实现页面跳转"></a>1.alert（）弹出框确认后，实现页面跳转</h2><p><strong>代码实现：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;爱的平台&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./reset.css&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">    .love&#123;</span><br><span class="line">       color: brown;</span><br><span class="line">       font-size: 50px;</span><br><span class="line">       margin-top: 30px;</span><br><span class="line">       margin-left: 550px;</span><br><span class="line">    &#125;</span><br><span class="line">    .shuru&#123;</span><br><span class="line">        margin-top: 70px;</span><br><span class="line">       margin-left: 550px;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">   </span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;p class=&quot;love&quot;&gt;欢迎来到爱的抽奖平台！&lt;/p&gt;</span><br><span class="line">   &lt;form </span><br><span class="line">   method=&quot;post&quot; class=&quot;shuru&quot; name=&quot;shuru&quot;&gt;</span><br><span class="line">       &lt;span&gt;请输入爱的号码牌：&lt;/span&gt;</span><br><span class="line">       &lt;input type=&quot;text&quot; class=&quot;num&quot; name=&quot;num&quot;&gt;</span><br><span class="line">       &lt;input type=&quot;button&quot; class=&quot;queren&quot; onclick=&quot;hello()&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">   &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">         </span><br><span class="line">    function hello()&#123;</span><br><span class="line">        var info=1234;</span><br><span class="line">        if(document.forms[&quot;shuru&quot;][&quot;num&quot;].value==info)</span><br><span class="line">       &#123;       </span><br><span class="line">            alert(&quot;恭喜你获奖！！！&quot;);</span><br><span class="line">            window.location.href = &#x27;./baidu.html&#x27;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">        else</span><br><span class="line">            &#123;alert(&quot;很遗憾，您并没有获奖！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br><span class="line">    //   var sty=document.getElementById(&quot;BU&quot;).style;</span><br><span class="line">    //   sty.backgroundColor=&quot;blue&quot;;</span><br><span class="line">    //   sty.color=&quot;red&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>遇到的问题：</strong>之前提交按钮的类型是submit,出现一直无法正常弹出新页面的情况，一直是页面找不到，改为button之后，就可以正常弹出页面了。</p><p><strong>原因：</strong></p><h2 id="2-字符串替换"><a href="#2-字符串替换" class="headerlink" title="2.字符串替换"></a>2.字符串替换</h2><p><strong>js中是没有replaceAll方法的，那么如何实现替换所有匹配的字符串呢，即在js中实现replaceAll方法：</strong></p><p><strong>1. 使用具有全局标志g的正则表达式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;dogdogdog&quot;;</span><br><span class="line">var str2 = str.replace(/dog/g,&quot;cat&quot;);</span><br><span class="line">console.log(str2);</span><br></pre></td></tr></table></figure><p>实现替换全部匹配字符串，输出结果为：catcatcat。</p><p><strong>2. 使用另一种具有全局标志g的正则表达式的定义方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;dogdogdog&quot;;</span><br><span class="line">var str2 = str.replace(new RegExp(&quot;dog&quot;,&quot;gm&quot;),&quot;cat&quot;);</span><br><span class="line">console.log(str2);</span><br></pre></td></tr></table></figure><p>输出结果同上例。这里g表示执行全局匹配，m表示执行多次匹配。</p><p><strong>3. 给string对象添加原型方法replaceAll()</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.replaceAll = function(s1, s2) &#123;</span><br><span class="line">    return this.replace(new RegExp(s1, &quot;gm&quot;), s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以像使用replace方法一样使用replaceAll方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;dogdogdog&quot;;</span><br><span class="line">var str2 = str.replaceAll(&quot;dog&quot;, &quot;cat&quot;);</span><br><span class="line">console.log(str2);</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://www.cnblogs.com/henuyuxiang/p/11609088.html">js实现replaceAll方法 - 岁月淡忘了谁 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;JS操作问题&quot;&gt;&lt;a href=&quot;#JS操作问题&quot; class=&quot;headerlink&quot; title=&quot;JS操作问题&quot;&gt;&lt;/a&gt;JS操作问题&lt;/h1&gt;&lt;h2 id=&quot;1-alert（）弹出框确认后，实现页面跳转&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>密码学技术原理学习（一）</title>
    <link href="http://example.com/2021/09/08/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/09/08/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-09-07T16:00:00.000Z</published>
    <updated>2021-09-09T12:10:56.846Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="U盾"><a href="#U盾" class="headerlink" title="U盾"></a>U盾</h1><p><strong>简介</strong>：U盾，即工商银行2003年推出并获得国家专利的客户证书USBkey，是工行提供的办理网上银行业务的高级别安全工具。它外形酷似U盘，安全性能如一面盾牌，意为U型的盾牌，所以取名曰：“U盾”。它的作用是在办理网上银行业务时保护着网上银行资金安全，规避黑客、假网站、木马病毒等各种风险。 U盾是工商银行推出并获得国家专利的客户证书USBkey，是工行为您提供的办理网上银行业务的高级别安全工具。 U盾是用于网上银行电子签名和数字认证的工具，它内置微型智能卡处理器，采用1024位非对称密钥算法对网上数据进行加密、解密和数字签名，确保网上交易的保密性、真实性、完整性和不可否认性。</p><p><strong>工作原理</strong>：</p><p>​       U盾又作移动数字证书，它存放着你个人的数字证书，并不可读取。同样，银行也记录着你的数字证书。当你尝试进行网上交易时，银行会向你发送由时间字串，地址字串，交易信息字串，防重放攻击字串组合在一起进行加密后得到的字串A，你的U盾将跟据你的个人证书对字串A进行不可逆运算得到字串B，并将字串B发送给银行，银行端也同时进行该不可逆运算，如果银行运算结果和你的运算结果一致便认为你合法，交易便可以完成，如果不一致便认为你不合法，交易便会失败。<br>　　理论上，不同的字串A不会得出相同的字串B，即一个字串A对应一个唯一的字串B；但是字串B 和字串A无法得出你的数字证书，而且U盾具有不可读取性，所以任何人都无法获行你的数字证书。并且银行每次都会发不同的防重放字串（随机字串）和时间字串，所以当一次交易完成后，刚发出的B字串便不再有效。综上所述，理论上U盾是绝对安全的。</p><p><img src="/E:/git-blog\source\images\QQ截图20210908205640.png" alt="QQ截图20210908205640"></p><h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><p> <strong>简介</strong>：HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和<a href="https://baike.baidu.com/item/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/5294713">身份认证</a>保证了传输过程的安全性 [1] 。HTTPS 在HTTP 的基础下加入<a href="https://baike.baidu.com/item/SSL/320778">SSL</a>，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 <a href="https://baike.baidu.com/item/TCP/33012">TCP</a> 之间）。这个系统提供了身份验证与加密通讯方法。它被广泛用于<a href="https://baike.baidu.com/item/%E4%B8%87%E7%BB%B4%E7%BD%91/215515">万维网</a>上安全敏感的通讯，例如交易支付等方面。</p><p><strong>实现原理</strong>：</p><p>① 客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器；</p><p>② 服务器从算法列表中选择一种加密算法，并将它和一份包含<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>公用密钥的证书发送给<a href="https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF/101081">客户端</a>；该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个用作产生密钥的随机数；</p><p>③ 客户端对服务器的证书进行验证（有关验证证书，可以参考<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/212550">数字签名</a>），并抽取服务器的公用密钥；然后，再产生一个称作 pre_master_secret 的随机密码串，并使用服务器的公用密钥对其进行加密（参考非对称加 / 解密），并将加密后的信息发送给服务器 ；</p><p>④ 客户端与服务器端根据 pre_master_secret 以及客户端与服务器的随机数值独立计算出加密和 <a href="https://baike.baidu.com/item/MAC/173">MAC</a>密钥（参考 DH密钥交换算法）；</p><p>⑤ 客户端将所有握手消息的 MAC 值发送给服务器；</p><p>⑥ 服务器将所有握手消息的 MAC 值发送给客户端 。</p><h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><p><strong>简介</strong>：在密码学和计算机安全领域中，中间人攻击（Man-in-the-middle attack ，缩写：MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）。<br>       一个中间人攻击能成功的前提条件是攻击者能将自己伪装成每一个参与会话的终端，并且不被其他终端识破。中间人攻击是一个（缺乏）相互认证的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，SSL协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信任的数字证书认证机构颁发，并且能执行双向身份认证。</p><p>​      随着计算机通信网技术的不断发展，MITM攻击也越来越多样化。最初，攻击者只要将网卡设为混杂模式，伪装成<a href="https://wapbaike.baidu.com/item/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8">代理服务器</a>监听特定的流量就可以实现攻击，这是因为很多通信协议都是以明文来进行传输的，如HTTP、FTP、Telnet等。后来，随着<a href="https://wapbaike.baidu.com/item/%E4%BA%A4%E6%8D%A2%E6%9C%BA">交换机</a>代替<a href="https://wapbaike.baidu.com/item/%E9%9B%86%E7%BA%BF%E5%99%A8">集线器</a>，简单的嗅探攻击已经不能成功，必须先进行<a href="https://wapbaike.baidu.com/item/ARP%E6%AC%BA%E9%AA%97/2805503">ARP欺骗</a>才行。如今，越来越多的服务商（网上银行，邮箱登陆）开始采用加密通信，SSL(Secure Sockets Layer <a href="https://wapbaike.baidu.com/item/%E5%AE%89%E5%85%A8%E5%A5%97%E6%8E%A5%E5%B1%82">安全套接层</a>)是一种广泛使用的技术，HTTPS、FTPS等都是建立在其基础上的。</p><p><strong>实现原理</strong>:</p><p>解释如下图：</p><p><img src="/C:/Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210908194927456.png" alt="image-20210908194927456"></p><h1 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h1><p><strong>简介</strong>：RSA<a href="https://baike.baidu.com/item/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/11048976">公开密钥密码体制</a>是一种使用不同的加密密钥与解密密钥，“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制  。</p><p>在公开密钥密码体制中，加密密钥（即公开密钥）PK是公开信息，而解密密钥（即秘密密钥）SK是需要保密的。加密算法E和解密算法D也都是公开的。虽然解密密钥SK是由公开密钥PK决定的，但却不能根据PK计算出SK 。</p><p>正是基于这种理论，1978年出现了著名的RSA算法，它通常是先生成一对RSA密钥，其中之一是保密密钥，由用户保存；另一个为公开密钥，可对外公开，甚至可在网络服务器中注册。为提高保密强度，RSA密钥至少为500位长，一般推荐使用1024位。这就使加密的计算量很大。为减少计算量，在传送信息时，常采用传统加密方法与<a href="https://baike.baidu.com/item/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/8090774">公开密钥加密</a>方法相结合的方式，即信息采用改进的DES或IDEA对话密钥加密，然后使用RSA密钥加密对话密钥和信息摘要。对方收到信息后，用不同的密钥解密并可核对信息摘要  。RSA是被研究得最广泛的公钥算法，从提出到现在已近三十年，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。</p><p>一般来说，512位的密钥被视为不安全的；768位的密钥不用担心受到除了国家安全管理（NSA）外的其他事物的危害；1024位的密钥几乎是安全的。RSA在一些主要产品内部都有嵌入，像 Windows、网景 Navigator、 Quicken和 Lotus Notes  。</p><p><strong>实现原理</strong>：RSA公开密钥密码体制的原理是：根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p><p>RSA算法的具体描述如下： </p><p>（1）任意选取两个不同的大素数p和q计算乘积</p><p><img src="https://bkimg.cdn.bcebos.com/formula/f0dac18152076624d87832b62709895c.svg" alt="img"></p><p>（2）任意选取一个大整数e，满足</p><p><img src="https://bkimg.cdn.bcebos.com/formula/c33d8c66364a636b051d82f0ee202a36.svg" alt="img"></p><p> ，整数e用做加密钥（注意：e的选取是很容易的，例如，所有大于p和q的素数都可用） ；</p><p>（3）确定的解密钥d，满足</p><p><img src="https://bkimg.cdn.bcebos.com/formula/da8649c0078a0a842779394d64011776.svg" alt="img"></p><p> ，即</p><p><img src="https://bkimg.cdn.bcebos.com/formula/4dee3f4df52a81983db0e3c619f96058.svg" alt="img"></p><p> 是一个任意的整数；所以，若知道e和</p><p><img src="https://bkimg.cdn.bcebos.com/formula/679e809a0d964785d0aa4cfcb4218742.svg" alt="img"></p><p>，则很容易计算出d；</p><p>（4）公开整数n和e，秘密保存d；</p><p>（5）将明文m（m&lt;n是一个整数）加密成密文c，加密算法为 </p><p><img src="https://bkimg.cdn.bcebos.com/formula/5947116555169dc6fe9e3f5cdf347706.svg" alt="img"></p><p>（6）将密文c解密为明文m，解密算法为 </p><p><img src="https://bkimg.cdn.bcebos.com/formula/1a8b337167e4d4b2c23855d88ec4c67f.svg" alt="img"></p><p>然而只根据n和e（注意：不是p和q）要计算出d是不可能的。因此，任何人都可对明文进行加密，但只有授权用户（知道d）才可对密文解密 。</p><p><strong>参考资料</strong>：<a href="https://blog.csdn.net/fkedwgwy/article/details/4100522?ops_request_misc=%7B%22request_id%22:%22163107184416780262517111%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163107184416780262517111&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-4100522.first_rank_v2_pc_rank_v29&utm_term=U%E7%9B%BE&spm=1018.2226.3001.4187">(6条消息) U盾 _潇湘博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/superfjj/article/details/103983707?ops_request_misc=%7B%22request_id%22:%22163107290216780274192738%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163107290216780274192738&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-103983707.first_rank_v2_pc_rank_v29&utm_term=%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB&spm=1018.2226.3001.4187">(6条消息) 中间人攻击_程序那些事 -CSDN博客</a></p><p><a href="https://baike.baidu.com/item/RSA%E7%AE%97%E6%B3%95/263310">RSA算法_百度百科 (baidu.com)</a></p><p><a href="https://baike.baidu.com/item/https/285356">HTTPS_百度百科 (baidu.com)</a></p><p><a href="https://blog.csdn.net/qq_36522306/article/details/81053689?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=https&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-81053689.nonecase&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/qq_36522306/article/details/81053689?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=https&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-81053689.nonecase&amp;spm=1018.2226.3001.4187</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;U盾&quot;&gt;&lt;a href=&quot;#U盾&quot; class=&quot;headerlink&quot; title=&quot;U盾&quot;&gt;&lt;/a&gt;U盾&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;：U盾，即工商银行2003年推出并获得国家专利的客户</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记</title>
    <link href="http://example.com/2021/08/05/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/08/05/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-04T16:00:00.000Z</published>
    <updated>2021-10-09T12:21:30.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript学习笔记"><a href="#JavaScript学习笔记" class="headerlink" title="JavaScript学习笔记"></a>JavaScript学习笔记</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>类似于C语言。JavaScript 使用 Unicode 字符集，也可以使用 Base64 编码。</p><p><strong>注意：</strong>JavaScript对字母大小写敏感。</p><p>alter():浏览器弹出警示框</p><p>console.log(msg):浏览器控制台打印输出信息</p><p>prompt（info）：浏览器弹出输入框</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>声明变量: var age=10;</p><p><strong>注意：</strong>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>数值：Number (Infinity 表示无穷大，-Infinity表示无穷小，NaN表示非数值 isNaN（）判断是否是数字)</li></ul><p>发生“正向溢出”，就会返回<code>Infinity</code>。发生为“负向溢出”，这时会直接返回0。</p><p>JavaScript 提供<code>Number</code>对象的<code>MAX_VALUE</code>和<code>MIN_VALUE</code>属性，返回可以表示的具体的最大值和最小值。除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.MAX_VALUE // 1.7976931348623157e+308</span><br><span class="line">Number.MIN_VALUE // 5e-324</span><br></pre></td></tr></table></figure><p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值</p><p><strong>注意：</strong>JavaScript 内部，所有数字都是以64位浮点数形式储存，</p><ol><li><p>第1位：符号位，<code>0</code>表示正数，<code>1</code>表示负数</p></li><li><p>第2位到第12位（共11位）：指数部分</p></li><li><p>第13位到第64位（共52位）：小数部分（即有效数字）</p><p>精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示。</p><p>需要注意的是，<code>NaN</code>不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于<code>Number</code>.<code>NaN</code>不等于任何值，包括它本身.</p></li></ol><ul><li><p>布尔值：Boolean</p></li><li><p>字符串：String，<code>length</code>属性返回字符串的长度，JavaScript 原生提供两个 Base64 相关的方法。</p><ul><li><code>btoa()</code>：任意值转为 Base64 编码</li><li><code>atob()</code>：Base64 编码转为原来的值</li></ul></li><li><p>未定义：Undefined是一个表示”此处无定义”的原始值，转为数值时为<code>NaN</code>。</p></li><li><p>空值：Null，null是一个表示“空”的对象，转为数值时为0；</p></li><li><p>Symbol:</p><p>对象是最复杂的数据类型，又可以分成三个子类型:</p></li><li><p>狭义的对象：object，关于对象的引用，如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;&#125;;</span><br><span class="line">var o2 = o1;</span><br><span class="line"></span><br><span class="line">o1.a = 1;</span><br><span class="line">o2.a // 1</span><br><span class="line"></span><br><span class="line">o2.b = 2;</span><br><span class="line">o1.b // 2;</span><br><span class="line"></span><br><span class="line">var x = 1;</span><br><span class="line">var y = x;</span><br><span class="line"></span><br><span class="line">x = 2;</span><br><span class="line">y // 1</span><br></pre></td></tr></table></figure><p>这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。</p><p><strong>查看属性</strong>：<code>Object.keys</code>方法。</p><p><strong>删除属性</strong>：<code>delete</code>命令。删除成功后返回<code>true</code>。(只能删除对象本身的属性，无法删除继承的属性)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete obj.p // true</span><br></pre></td></tr></table></figure><p><strong>判断属性是否存在</strong>：in运算符，检查的是键名，不是键值，如果包含就返回<code>true</code>，否则返回<code>false</code>。它的左边是一个字符串，表示属性名，右边是一个对象。</p><p>注意：不能识别哪些属性是对象自身的，哪些属性是继承的。可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性。</p><p><strong>属性的历遍</strong>：<code>for...in</code>循环用来遍历一个对象的全部属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a: 1, b: 2, c: 3&#125;;</span><br><span class="line"></span><br><span class="line">for (var i in obj) &#123;</span><br><span class="line">  console.log(&#x27;键名：&#x27;, i);</span><br><span class="line">  console.log(&#x27;键值：&#x27;, obj[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，都是只想遍历对象自身的属性，所以使用<code>for...in</code>的时候，应该结合使用<code>hasOwnProperty</code>方法，在循环内部判断一下，某个属性是否为对象自身的属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123; name: &#x27;老张&#x27; &#125;;</span><br><span class="line"></span><br><span class="line">for (var key in person) &#123;</span><br><span class="line">  if (person.hasOwnProperty(key)) &#123;</span><br><span class="line">    console.log(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// name</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性（例如<code>toString</code>属性）。</li><li>它不仅遍历对象自身的属性，还遍历继承的属性。</li></ul><p><strong>操作同一个对象的多个属性</strong>：with语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">with (document.links[0])&#123;</span><br><span class="line">  console.log(href);</span><br><span class="line">  console.log(title);</span><br><span class="line">  console.log(style);</span><br><span class="line">&#125;</span><br><span class="line">// 等同于</span><br><span class="line">console.log(document.links[0].href);</span><br><span class="line">console.log(document.links[0].title);</span><br><span class="line">console.log(document.links[0].style);</span><br></pre></td></tr></table></figure><p>注意：<code>with</code>区块没有改变作用域，它的内部依然是当前作用域。这造成了<code>with</code>语句的一个很大的弊病，就是绑定对象不明确。这非常不利于代码的除错和模块化，建议不要使用<code>with</code>语句，可以考虑用一个临时变量代替<code>with</code>。</p></li><li><p>数组：array,本质上，数组属于一种特殊的对象。数组是一种动态的数据结构，可以随时增减数组的成员。<code>typeof</code>运算符会返回数组的类型是<code>object</code>。数组的键名就是整数0、1、2。（字符串是类似数组的对象）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br></pre></td></tr></table></figure><ol><li><strong>length属性</strong>，还可以用这个属性进行增删操作。</li><li><strong>in运算符</strong>：</li><li><strong>for…in,for,while,forEach循环历遍数组</strong></li></ol><p>注意：使用<code>delete</code>命令删除一个数组成员，会形成空位，并且不会影响<code>length</code>属性。所以，使用<code>length</code>属性进行数组遍历，一定要非常小心。如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过。如果某个位置是<code>undefined</code>，遍历的时候就不会被跳过。</p></li></ul><p><strong>方法：</strong>slice（），call（）</p><ul><li><p>函数(第一等公民)：function</p><p><strong>函数声明</strong>：</p><ol><li><p>function命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function print(s) &#123;</span><br><span class="line">  console.log(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var print = function(s) &#123;</span><br><span class="line">  console.log(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Function构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var add = new Function(</span><br><span class="line">  &#x27;x&#x27;,</span><br><span class="line">  &#x27;y&#x27;,</span><br><span class="line">  &#x27;return x + y&#x27;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><p><strong>函数属性和方法：</strong></p><ol><li>name属性：返回函数名，还可以获取参数函数的名字。</li><li>length属性：返回函数预期传入的参数个数，即函数定义之中的参数个数。</li><li>toString():返回一个字符串，内容是函数的源码。</li><li>arguments对象（非数组）：<code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，对象只有在函数体内部，才可以使用。通过<code>arguments</code>对象的<code>length</code>属性，可以判断函数调用时到底带几个参数。<code>arguments</code>对象带有一个<code>callee</code>属性，返回它所对应的原函数。</li></ol><p>注意：函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。因为，形式参数（<code>o</code>）的值实际是参数<code>obj</code>的地址，重新对<code>o</code>赋值导致<code>o</code>指向另一个地址，保存在原地址上的值当然不受影响。</p><p><strong>闭包</strong>：（….）注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p><p><strong>eval语句</strong>:<code>eval</code>命令接受一个字符串作为参数，并将这个字符串当作语句执行。</p><p><strong>注意</strong>：转换规则是除了下面六个值被转为<code>false</code>，其他值都视为<code>true</code>。</p><p><code>undefined</code>，<code>null</code>，<code>false</code>，<code>0</code>，<code>NaN</code>，<code>&quot;&quot;</code>或<code>&#39;&#39;</code>（空字符串）</p><p><strong>获取数据类型的方法：</strong></p><ul><li><code>typeof</code>运算符</li><li><code>instanceof</code>运算符</li><li><code>Object.prototype.toString</code>方法</li></ul><p><strong>类型转换方式：</strong></p><p><strong>转整数</strong>：parseInt（）<code>parseInt</code>的参数都是字符串，结果只返回字符串头部可以转为数字的部分。返回值只有两种可能，要么是一个十进制整数，要么是<code>NaN</code>。</p><p><strong>进制转换</strong>：<code>parseInt</code>方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，<code>parseInt</code>的第二个参数为10，即默认是十进制转十进制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&#x27;1000&#x27;, 2) // 8</span><br><span class="line">parseInt(&#x27;1000&#x27;, 6) // 216</span><br><span class="line">parseInt(&#x27;1000&#x27;, 8) // 512</span><br></pre></td></tr></table></figure><p><strong>浮点数转化</strong>：parseFloat（）方法用于将一个字符串转为浮点数。</p><p>转String：toString(),String(),将需要转换的变量直接使用+号凭借字符串，结果就是字符串了（即隐式转换）。</p><p>转Number:parseInt(),parseFloat(),Number(),使用算术运算转换为数值型（即隐式转换）</p><p>转Boolean:Boolean()</p><p><strong>数组转字符串：</strong> 结合join()与String()函数实现。</p><p>注意数据类型是可以变化的。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>算术运算符：（注意：不要直接判断浮点数是否相等）</p><p>递增递减运算符：</p><p>比较运算符：</p><p>逻辑运算符：（注意一下<strong>逻辑与短路运算</strong>，<strong>逻辑或短路运算</strong>）</p><p>赋值运算符：</p><p>运算符优先级：</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><ul><li><p>顺序结构</p></li><li><p>分支结构;</p></li></ul><ol><li><p>if语句</p><p>2.if-else</p></li></ol><p>​    3.三元表达式</p><p>​    4.switch(break)</p><p><strong>注意</strong>：<code>switch</code>语句后面的表达式，与<code>case</code>语句后面的表示式比较运行结果时，采用的是严格相等运算符（<code>===</code>），而不是相等运算符（<code>==</code>），这意味着比较时不会发生类型转换。</p><ul><li>循环结构：</li></ul><p>​      1.while循环</p><p>​      2.for循环</p><p>​      3.do…while循环</p><ul><li>跳转手段</li></ul><p>​      1.break语句</p><p>​     2.continue语句</p><p>​      3.标签</p><pre><code>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">  for (var i = 0; i &lt; 3; i++)&#123;</span><br><span class="line">    for (var j = 0; j &lt; 3; j++)&#123;</span><br><span class="line">      if (i === 1 &amp;&amp; j === 1) break top;</span><br><span class="line">      console.log(&#x27;i=&#x27; + i + &#x27;, j=&#x27; + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  //跳出双重循环</span><br><span class="line">  </span><br><span class="line">  foo: &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">  break foo;</span><br><span class="line">  console.log(&#x27;本行不会输出&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(2);    //跳出区块</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">  for (var i = 0; i &lt; 3; i++)&#123;</span><br><span class="line">    for (var j = 0; j &lt; 3; j++)&#123;</span><br><span class="line">      if (i === 1 &amp;&amp; j === 1) continue top;</span><br><span class="line">      console.log(&#x27;i=&#x27; + i + &#x27;, j=&#x27; + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;          //进入下一层外层循环</span><br></pre></td></tr></table></figure></code></pre><h2 id="JavaScript对象"><a href="#JavaScript对象" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h2><h2 id="JavaScript事件"><a href="#JavaScript事件" class="headerlink" title="JavaScript事件"></a>JavaScript事件</h2><p>HTML 事件是发生在 HTML 元素上的事情。当在 HTML 页面中使用 JavaScript 时， JavaScript 可以触发这些事件。例如页面加载完成、你点击个按钮、文本框输入了文字等等，都是HTML事件的案例。</p><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>onchange</td><td>HTML元素改变</td></tr><tr><td>onclick</td><td>用户点击HTML元素</td></tr><tr><td>onmouseover</td><td>用户在一个HTML元素上移动鼠标</td></tr><tr><td>onmouseout</td><td>用户在一个HTML元素上移开鼠标</td></tr><tr><td>onkeydown</td><td>用户按下键盘按键</td></tr><tr><td>onload</td><td>浏览器已完成页面的加载</td></tr><tr><td>onfocus</td><td>元素获取焦点是触发</td></tr><tr><td>onblur</td><td>元素失去焦点时触发</td></tr></tbody></table><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>Window 对象表示浏览器中打开的窗口。</p><p><strong>Window对象</strong></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>document</td><td>对 Document 对象的只读引用</td></tr><tr><td>history</td><td>对 History 对象的只读引用</td></tr><tr><td>location</td><td>用于窗口或框架的 Location 对象</td></tr><tr><td>name</td><td>设置或返回窗口的名称</td></tr></tbody></table><p><strong>history:</strong></p><ul><li>history.back() - 与在浏览器点击后退按钮相同</li><li>history.forward() - 与在浏览器中点击向前按钮相同</li><li>history.go(1/-1)<br>参数为1:等同于 history.forward()，<br>参数为-1，等同于 history.back()</li></ul><p><strong>location</strong>:(用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面，window.location 对象在编写时可不使用 window 这个前缀)</p><ul><li>replace(url) 转向到url网页地址</li><li>reload() 重新载入当前网址，如同按下刷新按钮</li><li>window.location.href：获取当前窗口正在浏览的网页地址</li></ul><p><strong>Window对象方法</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>alert()</td><td>显示带有一段消息和一个确认按钮的警告框</td></tr><tr><td>confirm()</td><td>显示带有一段消息以及确认按钮和取消按钮的对话框</td></tr><tr><td>prompt()</td><td>弹出的对话框，提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据</td></tr><tr><td>open()</td><td>用于新建另一个浏览器窗口，类似于浏览器菜单的新建窗口选项</td></tr><tr><td>close()</td><td>用于关闭当前窗口</td></tr><tr><td>setTimeout()</td><td></td></tr><tr><td>setInterval()</td><td></td></tr><tr><td>clearInterval()</td><td>取消由 setInterval() 设置的 timeout</td></tr><tr><td>clearTimeout()</td><td>取消由 setTimeout() 方法设置的 timeout</td></tr></tbody></table><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>（Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问。）</p><p>当浏览器载入 HTML 文档, 它就会成为 <strong>Document 对象</strong>，Document 对象是 HTML 文档的根节点，Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。</p><p>节点的类型有七种。</p><ul><li><code>Document</code>：整个文档树的顶层节点</li><li><code>DocumentType</code>：<code>doctype</code>标签（比如<code>&lt;!DOCTYPE html&gt;</code>）</li><li><code>Element</code>：网页的各种HTML标签（比如<code>&lt;body&gt;</code>、<code>&lt;a&gt;</code>等）</li><li><code>Attr</code>：网页元素的属性（比如<code>class=&quot;right&quot;</code>）</li><li><code>Text</code>：标签之间或标签包含的文本</li><li><code>Comment</code>：注释</li><li><code>DocumentFragment</code>：文档的片段</li></ul><p><img src="/C:/Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210929180551744.png" alt="image-20210929180551744"></p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>DOM 节点对象都继承了 Node 接口，拥有一些共同的属性和方法。</p><table><thead><tr><th>属性/方法</th><th>用法</th></tr></thead><tbody><tr><td>Node.prototype.nodeType</td><td>返回一个整数值，表示节点的类型。</td></tr><tr><td>Node.prototype.nodeName</td><td>返回节点的名称</td></tr><tr><td>Node.prototype.nodeValue</td><td>返回一个字符串，表示当前节点本身的文本值，该属性可读写。</td></tr><tr><td>Node.prototype.textContent</td><td>返回当前节点和它的所有后代节点的文本内容</td></tr><tr><td>Node.prototype.baseURI</td><td>返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。</td></tr><tr><td>Node.prototype.ownerDocument</td><td>返回当前节点所在的顶层文档对象，即<code>document</code>对象。</td></tr><tr><td>Node.prototype.nextSibling</td><td>返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回<code>null</code>。可以用来遍历所有子节点。</td></tr><tr><td>Node.prototype.previousSibling</td><td>返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回<code>null</code>。</td></tr><tr><td>Node.prototype.parentNode</td><td>返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点、文档节点和文档片段节点</td></tr><tr><td>Node.prototype.parentElement</td><td>返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回<code>null</code>。</td></tr><tr><td>Node.prototype.firstChild</td><td>返回当前节点的第一个子节点，如果当前节点没有子节点，则返回<code>null</code>。</td></tr><tr><td>Node.prototype.lastChild</td><td>返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回<code>null</code>。</td></tr><tr><td>Node.prototype.childNodes</td><td>返回一个类似数组的对象（<code>NodeList</code>集合），成员包括当前节点的所有子节点。</td></tr><tr><td>Node.prototype.isConnected</td><td>返回一个布尔值，表示当前节点是否在文档之中</td></tr><tr><td>Node.prototype.appendChild()</td><td>接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。如果参数节点是 DOM 已经存在的节点，<code>appendChild()</code>方法会将其从原来的位置，移动到新位置。</td></tr><tr><td>Node.prototype.hasChildNodes()</td><td>返回一个布尔值，表示当前节点是否有子节点。</td></tr><tr><td>Node.prototype.cloneNode()</td><td>用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</td></tr><tr><td>Node.prototype.insertBefore()</td><td>用于将某个节点插入父节点内部的指定位置。第一个参数是所要插入的节点<code>newNode</code>，第二个参数是父节点<code>parentNode</code>内部的一个子节点<code>referenceNode</code>。<code>newNode</code>将插在<code>referenceNode</code>这个子节点的前面。</td></tr><tr><td>Node.prototype.removeChild()</td><td>接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</td></tr><tr><td>Node.prototype.replaceChild()</td><td>用于将一个新的节点，替换当前节点的某一个子节点。第一个参数<code>newChild</code>是用来替换的新节点，第二个参数<code>oldChild</code>是将要替换走的子节点。返回值是替换走的那个节点<code>oldChild</code>。</td></tr><tr><td>Node.prototype.compareDocumentPosition()</td><td>返回一个六个比特位的二进制值，表示参数节点与当前节点的关系。</td></tr><tr><td>Node.prototype.contains()</td><td>返回一个布尔值，表示参数节点是否满足以下三个条件之一。参数节点为当前节点，参数节点为当前节点的子节点，参数节点为当前节点的后代节点。</td></tr><tr><td>Node.prototype.isEqualNode()</td><td>返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</td></tr><tr><td>Node.prototype.isSameNode()</td><td>返回一个布尔值，表示两个节点是否为同一个节点。</td></tr><tr><td>Node.prototype.normalize()</td><td>用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。</td></tr><tr><td>Node.prototype.getRootNode()</td><td>返回当前节点所在文档的根节点<code>document</code>，与<code>ownerDocument</code>属性的作用相同。</td></tr></tbody></table><h3 id="NodeList-HTMLCollection"><a href="#NodeList-HTMLCollection" class="headerlink" title="NodeList,HTMLCollection"></a>NodeList,HTMLCollection</h3><h3 id="ParentNode-ChildNode"><a href="#ParentNode-ChildNode" class="headerlink" title="ParentNode,ChildNode"></a>ParentNode,ChildNode</h3><h3 id="查找HTML元素方法"><a href="#查找HTML元素方法" class="headerlink" title="查找HTML元素方法"></a>查找HTML元素方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>document.getElementById()</td><td>返回对拥有指定 id 的第一个对象的引用。</td></tr><tr><td>document.getElementsByClassName()</td><td>返回文档中所有指定类名的元素集合，作为 NodeList 对象</td></tr><tr><td>document.getElementsByTagName()</td><td>返回带有指定标签名的对象集合</td></tr><tr><td>document.getElementsByName()</td><td>返回带有指定名称的对象集合</td></tr></tbody></table><h3 id="查看属性"><a href="#查看属性" class="headerlink" title="查看属性"></a>查看属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(h1.getAttribute(&quot;class&quot;))</span><br></pre></td></tr></table></figure><h3 id="修改HTML内容和属性"><a href="#修改HTML内容和属性" class="headerlink" title="修改HTML内容和属性"></a>修改HTML内容和属性</h3><p>修改内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(id).innerHTML= HTML;</span><br><span class="line">document.getElementById(&quot;myimg&quot;).src=&quot;x1.jpg&quot;;</span><br></pre></td></tr></table></figure><p>修改属性：</p><p>1.HTML属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方式1:</span><br><span class="line">document.getElementById(id).attribute=新属性值;</span><br><span class="line"></span><br><span class="line">方式2:</span><br><span class="line">document.getElementById(id).setAttribute(属性名，属性值);</span><br></pre></td></tr></table></figure><p>修改CSS：</p><p>语法:<br>document.getElementById(id).style.property=新样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;myli&quot;).style.color=&quot;blue&quot;; </span><br><span class="line">document.getElementById(&quot;myli&quot;).style.fontFamily=&quot;微软雅黑&quot;; </span><br><span class="line">document.getElementById(&quot;myli&quot;).style.fontSize=&quot;24px&quot;;</span><br></pre></td></tr></table></figure><h3 id="创建新的HTML元素"><a href="#创建新的HTML元素" class="headerlink" title="创建新的HTML元素"></a>创建新的HTML元素</h3><h3 id="替换HTML元素"><a href="#替换HTML元素" class="headerlink" title="替换HTML元素"></a>替换HTML元素</h3><h3 id="删除HTML元素"><a href="#删除HTML元素" class="headerlink" title="删除HTML元素"></a>删除HTML元素</h3><h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><h3 id="1-关于call-函数的应用："><a href="#1-关于call-函数的应用：" class="headerlink" title="1.关于call()函数的应用："></a>1.关于call()函数的应用：</h3><p>用于绑定this；如果出现了函数被覆盖的情况下，可以使用call实现原生函数调用。</p><h3 id="2-将类似数组的对象转为真正的数组："><a href="#2-将类似数组的对象转为真正的数组：" class="headerlink" title="2.将类似数组的对象转为真正的数组："></a>2.将类似数组的对象转为真正的数组：</h3><p>1.使用call（）；</p><p>2.<code>slice()</code>方法；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call(&#123; 0: &#x27;a&#x27;, 1: &#x27;b&#x27;, length: 2 &#125;)</span><br><span class="line">// [&#x27;a&#x27;, &#x27;b&#x27;]</span><br><span class="line"></span><br><span class="line">Array.prototype.slice.call(document.querySelectorAll(&quot;div&quot;));</span><br><span class="line">Array.prototype.slice.call(arguments);</span><br></pre></td></tr></table></figure><h3 id="3-进制转换"><a href="#3-进制转换" class="headerlink" title="3.进制转换"></a>3.进制转换</h3><p>十进制转其他进制：tostring()</p><p>其他进制转十进制：parseInt()</p><h3 id="4-插入文本"><a href="#4-插入文本" class="headerlink" title="4.插入文本"></a>4.插入文本</h3><p>1.使用createTextNode添加文本节点</p><p>2.修改textContent属性值</p><p>参考资料：</p><p><a href="https://wangdoc.com/javascript/">https://wangdoc.com/javascript/</a></p><p><a href="https://www.runoob.com/js/js-tutorial.html">JavaScript 教程 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://blog.csdn.net/m0_55221239/article/details/115313923">(8条消息) Web前端：JavaScript最强总结 附详细代码 （带常用案例！）_BudingCode的博客-CSDN博客_web前端案例代码</a></p><p><a href="https://movie.blog.csdn.net/article/details/82817457">(8条消息) JavaScript学习笔记（三）Js正则、DOM_一叶知秋-CSDN博客</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript#%E6%95%99%E7%A8%8B">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript#%E6%95%99%E7%A8%8B</a></p><p><a href="https://zh.javascript.info/">https://zh.javascript.info/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript学习笔记&quot;&gt;&lt;a href=&quot;#JavaScript学习笔记&quot; class=&quot;headerlink&quot; title=&quot;JavaScript学习笔记&quot;&gt;&lt;/a&gt;JavaScript学习笔记&lt;/h1&gt;&lt;h2 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSS3基础学习记录</title>
    <link href="http://example.com/2021/07/29/CSS3%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2021/07/29/CSS3%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2021-07-28T16:00:00.000Z</published>
    <updated>2021-10-02T13:52:42.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS3基础学习记录"><a href="#CSS3基础学习记录" class="headerlink" title="CSS3基础学习记录"></a>CSS3基础学习记录</h1><h2 id="1-css样式"><a href="#1-css样式" class="headerlink" title="1.css样式"></a>1.css样式</h2><h3 id="1-1内联样式"><a href="#1-1内联样式" class="headerlink" title="1.1内联样式"></a>1.1内联样式</h3><p>eg.<code>&lt;p style=&quot;color:red;&quot;&gt;helio&lt;/p&gt;</code></p><p>开发时尽量不要使用，维护代价大。</p><h3 id="1-2内部样式表"><a href="#1-2内部样式表" class="headerlink" title="1.2内部样式表"></a>1.2内部样式表</h3><p>将样式编写到head中的style标签里面,然后通过选择器来选择元素更改样式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">   &lt;title&gt;</span><br><span class="line">   测试</span><br><span class="line">   &lt;/title&gt;</span><br><span class="line">   &lt;style&gt;</span><br><span class="line">   p&#123;</span><br><span class="line">   color: green;</span><br><span class="line">   font-size: 50px;</span><br><span class="line">   &#125;</span><br><span class="line">   &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p>缺点：只能对一个网页起作用，它的样式不能跨网页起作用。</p><h3 id="1-3-外部样式表"><a href="#1-3-外部样式表" class="headerlink" title="1.3.外部样式表"></a>1.3.外部样式表</h3><p>将CSS样式编写到一个外部的css文件中，然后通过link标签来引入css文件。</p><p>eg.<code>&lt;link rel=&quot;stylesheet&quot; herf=&quot;./style.css&quot;&gt;</code></p><h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h2><ol><li><p>注释: <code>/*这是注释*/</code></p></li><li><p>基本语法：</p><p>选择器{声明块}（声明块包含属性和属性值）</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p&#123;</span><br><span class="line">   color: green;</span><br><span class="line">   font-size: 50px;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-1选择器"><a href="#2-1选择器" class="headerlink" title="2.1选择器"></a>2.1选择器</h3><p><strong>常用选择器</strong></p><ul><li><p>元素选择器 <code>p&#123; color: green;&#125;</code></p></li><li><p>id选择器<code>#对象ID&#123;color: green;&#125;</code></p></li><li><p>类选择器<code>.对象类名&#123;color: green;&#125;</code></p></li><li><p>通配选择器<code>*&#123;color: green;&#125;</code></p></li></ul><p><strong>复合选择器</strong></p><ul><li><p>交集选择器:例如<code>div. red&#123;color: green;&#125;</code></p><p><code>.a.b.c&#123;color: green;&#125;</code></p></li><li><p>并集选择器：例如<code>hq,span&#123;color:green;&#125;</code></p><p>或者<code>#b1,.p1&#123;color: green;&#125;</code></p></li></ul><p><strong>关系选择器</strong></p><p>（父元素，子元素，祖先元素，后代元素，兄弟元素）</p><ul><li>子元素选择器:语法：父元素&gt;子元素,eg.<code>div.box&gt;span&#123;color: green;&#125;</code></li><li>后代元素选择器：语法：祖先 后代eg.<code>div span&#123;color: green;&#125;</code></li><li>兄弟元素选择器：<code>p+span&#123;color: green;&#125;</code>PS:+是指选择紧挨着的一个进行操作<code>p~span&#123;color: green;&#125;</code>PS:~是指选择所有符合条件的进行操作</li></ul><p><strong>属性选择器</strong></p><p><code>[属性]&#123;color: green;&#125;</code>选择带有属性的</p><p><code>[属性=a]&#123;color: green;&#125;</code>选择属性为a的</p><p><code>[属性^=a]&#123;color: green;&#125;</code>选择属性以a开始的</p><p><code>[属性$=a]&#123;color: green;&#125;</code>选择属性以a结束的</p><p><strong>伪类选择器</strong></p><p>用来描述元素的特殊状态,比如第一个元素，被点击的元素，鼠标移入的元素，一般以：开头。例如<code>:not</code>,</p><p><code>ul&gt;li:not(:nth-of-type(3))&#123;color: green;&#125;</code></p><p>例如：</p><p>（以下排序是根据所有子元素进行排序）</p><p><code>ul&gt;li:first-child&#123;color: green;&#125;</code>第一个子类且是li</p><p><code>ul&gt;li:last-child&#123;color: green;&#125;</code>最后一个子类且是li</p><p><code> ul&gt;li:nth&#123;color: green;&#125;</code>第n个元素</p><p>特殊值：</p><p> n:0到正无穷</p><p>2n或even：偶数位的元素</p><p>2n+1或odd: 奇数位的元素</p><p>（以下排序是根据同类型中进行排序）</p><p><code>:first-of-type</code></p><p><code>:last-of-type</code></p><p><code>:nth-of-type</code></p><p>(以下是关于链接的伪类)</p><p><code>:link</code>:表示正常的链接，用来表示没访问过的链接</p><p><code>:visited</code>:访问过的链接，只能修改链接的颜色</p><p><code>:hover</code>:用来表示鼠标移入的状态</p><p><code>:active</code>:用来表示鼠标所点击的状态</p><p><strong>伪元素选择器</strong></p><p>表示页面中不真实存在的元素，以::开头。</p><p>eg.p::first-letter{color: green;}</p><p>::first-letter 表示第一个字母</p><p>::first-line  表示第一行</p><p>::selection  表示选中的内容</p><p>::before 表示元素的开始</p><p>::after  表示元素的最后</p><p>before和after必须和content结合使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p::before&#123;</span><br><span class="line">   content: &#x27;&quot;&#x27;;</span><br><span class="line">   &#125;</span><br><span class="line">   p::after&#123;</span><br><span class="line">   content: &#x27;&quot;&#x27;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;everyone&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/C:/Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210729194615179.png" alt="image-20210729194615179"></p><p><strong>选择器的权重（即优先级）</strong></p><ol><li>内联样式 ， 权重为1000</li><li>id选择器 ，  权重为100</li><li>类和伪类选择器 ，权重为10</li><li>元素选择器  ，权重为  1</li><li>通配选择器 ，权重为0</li><li>继承的样式，没有优先级</li></ol><p> 比较优先级时，需要将所有选择器的优先级进行相加计算（分组选择器是单独计算的），最后优先级越高，优先相似，不过选择器的累加不会超过其最大数量级，例如，类选择器再高也不会超过id选择器。如果优先级相等，则优先使用位置靠下的样式。</p><p>在某个样式后面加！important，则该样式拥有最高优先级。</p><p><strong>补充：像素相关单位：</strong></p><p>px，百分比,em,rem</p><p><strong>补充：颜色相关单位：</strong></p><p>颜色名，RGB值（语法：rgb（255，50，90）），RGBA值（最后一位表示透明度，1为完全不透明，0为完全透明，5为半透明，语法：rgb(255，0，0，1)），十六进制的RGB值，HSL值（H色相，S饱和度，L亮度），HSLA值</p><h2 id="3-继承"><a href="#3-继承" class="headerlink" title="3.继承"></a>3.继承</h2><p>我们为一个元素设置的样式同样也会应用到它的后代上。但并表示所有的样式都会被继承，比如背景相关，布局相关的。</p><h2 id="4-布局"><a href="#4-布局" class="headerlink" title="4.布局"></a>4.布局</h2><p><strong>文档流</strong></p><p>网页是一个多层的结构，最底下的一层即为文档流，文档流是网页的基础，我们所创建的元素默认都是在文档流中进行排列的。所有元素共有2种形态：在文档流中和脱离文档流的。</p><h3 id="4-1盒子模型"><a href="#4-1盒子模型" class="headerlink" title="4.1盒子模型"></a>4.1盒子模型</h3><p>css将页面的所有元素都设置为了一个矩形的盒子，网页布局即将不同的盒子摆放到不同的位置。每一个盒子都由以下几个部分组成：</p><p><strong>内容区（content）：</strong></p><p>width，height，background-color</p><p><strong>边框（border）：</strong></p><p>border-width，border-color，border-style</p><p>简写格式：border:solid  10px  red(无顺序要求)或者border-top:solid  10px  red</p><p>对于四个边框，四个值就是控制 上，右，下，左，三个值就是控制上，左右，下，两个值就是控制上下，左右，一个值就是控制上下左右；除此之外，还可以使用border-xxx-width来控制某一个边，xxx可以是top,right,bottom,left。</p><p><strong>内边距(padding):</strong></p><p>padding-top,padding-right,padging-bottom,padding-left</p><p>或者直接使用padding:20px 10px 10px 10px</p><p>注意：内边距的大小将会影响盒子的大小(盒子的可见框大小由内容区，内边距，边框决定，计算盒子的大小的时候，需要将三者相加)</p><p><strong>外边距(margin):</strong></p><p>margin-top,margin-left,margin-bottom，margin-right</p><p>外边距不会影响盒子可见框的大小，但是外边距会影响盒子的位置。</p><p><strong>水平方向布局：</strong></p><p>margin-left+border-left+padding-left+width+padding-right+border-right+margin-right必须等于父元素的内容区宽度，如果不满足，则称过度约束，等式自动调整（没有auto的情况，浏览器会调整margin-right使得等式成立，如果有auto的值，则会自动调整auto的那个值（width,margin-right,margin-right都可以设置，例如width：auto;）使得等式成立）</p><p><strong>垂直方向的布局</strong>：</p><p>默认情况下，父元素由内容撑开，子元素是指父元素中排列，如果子元素的大小超过了父元素，则子元素会从父元素中溢出，可以使用overflow属性来设置父元素如何处理溢出的子元素。overflow:hidden(visible,hidden,scroll生成滚动条，auto根据需要生成滚动条，overflow-x,overflow-y)</p><p>补充：相邻的垂直方向的外边距会发生重叠现象，兄弟元素的重叠（都是正值）会取两者外边距之间的较大值，（一正一负）取两者之和，（都为负）取两者之中绝对值较大的。父子元素的重叠，子元素会传递给父元素，一般会影响页面布局，需要处理。</p><p><strong>行内元素的盒模型</strong></p><p>行内元素不支持设置宽度和高度，可以设置padding，border，margin，但不会影响页面布局。</p><p>补充：</p><p><strong>display</strong>属性用来设置元素显示的类型，属性值为inline则为行元素，block设置块元素，inline-block设置行内块元素，table将元素设置为一个表格，none使得元素不在页面显示，我们可以通过使用display来使得行元素可以设置宽度和高度。</p><p>visibility属性用来设置元素的显示状态，visible为默认值，使得元素在页面正常显示，hidden使得元素在页面隐藏不显示，但依旧占据页面位置。</p><p><strong>盒子的尺寸</strong></p><p>box-sizing可以用来设置盒子尺寸的计算方式，可选border-box（高度和宽度是盒子可见框的大小）,content-box(默认值，高度宽度就是盒子content的大小)</p><p><strong>修饰</strong></p><p><em>轮廓</em>：outline：设置轮廓，不会影响页面布局</p><p><em>阴影</em>：box-shadow:设置元素阴影效果，不会影响页面布局（格式例如box-shadow：10px 10px 50px red，第一个值表示水平偏移，第二个值为垂直偏移,第三个值为模糊半径，第四个值为颜色）</p><p><em>圆角</em>：border-radius，border-top-left-radius，border-top-right-radius，border-bottom-left-radius，border-bottom-right-radius.（格式例如：border-top-left-radius：50px 50px,第一个值为水平方向半径，第二个值为垂直方向的半径）</p><p>注意：border-radius：50%；就是一个圆形。</p><h3 id="4-2浏览器的默认样式"><a href="#4-2浏览器的默认样式" class="headerlink" title="4.2浏览器的默认样式"></a>4.2浏览器的默认样式</h3><p>通常情况下，浏览器都会为我们的元素设置以下默认样式，但是默认样式的存在会影响页面的布局，因此在编写网页时，我们通常要去除浏览器的默认样式。</p><ul><li><p>通过*{margin:0;padding:0；}来清除样式，但是存在清除不干净的情况；</p></li><li><p>最好可以通过引入reset.css或者normalize.css文件来彻底清除默认样式。</p></li></ul><h3 id="浮动——float"><a href="#浮动——float" class="headerlink" title="浮动——float"></a>浮动——float</h3><p><strong>作用：</strong>通过浮动可以使得一个元素向其父元素的左右移动，不过该浮动元素不会超过前面其他的浮动元素。（浮动元素默认不会从父元素中移出）通过浮动可以制作水平方向的布局。浮动元素不会盖住文字，因此可以利用浮动来设置文字环绕。</p><p><strong>属性：</strong>float</p><p><strong>属性值：</strong></p><p>none默认值，不浮动</p><p>left 元素向左移动</p><p>right 元素向右移动</p><p><strong>注意：</strong>元素设置浮动以后，水平等式不需要强制成立，而且元素会从文档流脱离，不占用文档流位置，所以下边还在文档流中的元素会自动向上移动。浮动元素不会超过它上边的兄弟元素，最多和它一样高。浮动元素会影响其他元素，如果想要浮动元素对当前元素不影响，那么可以对当前元素设置clear属性（属性值left 清除左侧浮动元素的影响，right 清除右侧浮动元素的影响  ，both 清除两侧中最大影响的那侧）</p><p>脱离文档流的特点：</p><p>块元素并不独占一行，和行元素一样，宽高默认有内容撑开。</p><h3 id="解决高度坍塌的问题"><a href="#解决高度坍塌的问题" class="headerlink" title="解决高度坍塌的问题"></a>解决高度坍塌的问题</h3><p><strong>引起原因</strong>：浮动布局时，子元素脱离文档流，无法撑起父元素的高度，导致父元素高度丢失，其下的元素自动上移，导致页面布局混乱。</p><p><strong>解决办法：</strong></p><p>1.父元素高度写死；</p><p>2.利用BFC（块级格式化环境）：BFC是一个CSS中的隐含属性，我们可以为一个元素开启BFC，开启BFC之后该元素会变成一个独立的布局区域。</p><p>开启BFC后元素特点：1.开启BFC的元素不会被浮动元素覆盖；2.开启BFC的元素子元素和父元素外边距不会重叠；3.开启BFC的元素可以包含浮动的子元素</p><p>开启BFC的方式：1.设置元素的浮动；2、将元素设置为行内块元素；3.将父元素的overflow设置一个非visible的值（常用的方式overflow：hidden）</p><p>3.利用clear属性：</p><p>3.1给浮动元素设置一个兄弟元素，设置兄弟元素的clear属性。</p><p>3.2利用伪元素，给浮动元素的::after元素设置一个clear属性，并转换为块元素，这样就不用将表象上的问题使用结构的方法来解决。</p><h3 id="解决外边距重叠问题"><a href="#解决外边距重叠问题" class="headerlink" title="解决外边距重叠问题"></a>解决外边距重叠问题</h3><p>当我们调节子元素的外边距时，父元素的外边距也会跟着变化。例如，我们想让位于父元素上方的子元素移到父元素的下方，一般情况下，我们可以设置子元素的外边距，但是这样会使得父元素整体也往下移动，无法达到预想效果。</p><p><strong>解决办法：</strong></p><p>1.给父元素的伪类::before设置为{content：“”；display：table；}</p><p><strong>注意：</strong>clearfix::before,.clearfix::after{contenet:’’;dispaly:table;clear:both;}这个样式可以解决高度坍塌和外边距重叠的问题，当遇到这些问题的时候，可以直接使用它。只需要在父元素的类上加一个class =“clearfix”,然后使用该样式即可。</p><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>一种更加高级的布局手段。通过定位可以将元素摆放到页面的任意位置</p><p><strong>方法：</strong>使用position属性来设置定位。</p><p>position属性可选值：</p><p><strong>static</strong> 默认值，元素是静止的没有开启定位；</p><p>**relative **开启元素的相对定位,相对定位是参照于元素在文档流中的位置进行定位的（如果不设置偏移量，元素不会发生任何变化）；以下是偏移量的设置：</p><ul><li><p>top:10px,是指定位元素和定位位置上边的距离</p></li><li><p>bottom:10px,是指定位元素和定位位置下边的距离</p></li><li><p>left:10px,是指定位元素和定位位置左侧的距离</p></li><li><p>right:10px,是指定位元素和定位位置右侧的距离</p></li></ul><p>注意：相对定位会提升元素的层级，<strong>但不会使元素脱离文档流</strong>，也就是说，相对定位不会改变元素的性质，块还是块，行内还是行内。</p><p><strong>absolute</strong>开启元素的绝对定位，（开启绝对定位后，如果不设置偏移量，元素的位置不会发生变化）绝对定位是相对于其<em>包含块</em>【正常情况下，包含块是离当前元素最近的祖先块元素，绝对定位的包含块就是离它最近开启了定位的祖先元素，如果所有的祖先元素都没有开启定位，那么根元素html就是它的包含块】进行定位的</p><p>注意：绝对定位会使元素提升一个层级，<strong>开启绝对定位后，元素会从文档流中脱离</strong>，所以绝对定位会改变元素的性质，行内变成块，块的宽高被内容撑开</p><p><strong>fixed</strong> 开启与那是的固定定位,也是一种特殊的绝对定位，性质基本和绝对定位一样。唯一不同的是，固定定位永远参考于浏览器的视口进行定位。</p><p>注意：固定定位的元素不会随着网页的滚动条滚动。</p><p><strong>sticky</strong> 开启元素的粘滞定位，和相对定位的特点基本一致，不同的是粘滞定位可以在元素到达某个位置是将其固定，不再随滚动条滚动，但是它的兼容性不是特别好</p><h3 id="绝对定位元素的位置"><a href="#绝对定位元素的位置" class="headerlink" title="绝对定位元素的位置"></a>绝对定位元素的位置</h3><p>水平方向需要满足：包含块的内容区宽度=left+margin-left+border-left+padding-left+width+padding-right+border-right+margin-right+right.当发生过度约束时，如果9个值中没有auto【margin width left right 都可以设置auto】，那么将会自动调整right值以使得等式满足</p><p>垂直方向的布局：需要满足 包含块的高度=top+margin-top、bottom+padding-top、bottomborder-top、bottom+hight</p><p><strong>垂直水平居中的设置方式：</strong>top/right/top/bottom=0,margin=auto</p><p><strong>元素的层级</strong></p><p>对于开启了定位的元素，我们可以通过z-index属性来设置元素的层级，z-index需要一个整数作为一个层级，值越大元素层级越高，越优先显示。</p><p>注意：如果元素层级一样。则优先显示靠下的元素；祖先元素的层级再高，也不会盖住后代元素。</p><h2 id="5-字体"><a href="#5-字体" class="headerlink" title="5.字体"></a>5.字体</h2><p><strong>字体样式</strong></p><p><strong>color：</strong>字体颜色</p><p><strong>font-size</strong> 字体大小：（单位：px；em 相当于当前元素的一个font-size；rem 相当于根元素的一个font-size）</p><p>**font-weight:**narmal(默认不加粗)，bold(加粗)</p><p>**font-style:**normal(默认正常的)，italic（斜体）</p><p>**font-familiy **字体族（字体格式），可选择如下：</p><p>（他们都是指定字体类别，浏览器会自动使用该类别下的字体）</p><ul><li><p>serif 衬线字体类</p></li><li><p>sans-serif 非衬线字体类</p></li><li><p>monospace 等宽字体类</p><p>注意：font-fimily可以指定多个字体，第一个无法使用就使用第二个。当用户没有该字体时，我们可以通过@font-face{font-family：“ ”；src:url();}来使得一些偏僻的字体，客户也能使用。但是使用@font-face时需要考虑到加载速度和版权，字体格式问题。</p></li></ul><p><strong>line-hight：</strong>行高可以是指定的一个大小（单位px）;也可以是一个整数，如果是整数的话，行高将会是字体的指定倍数。我们可以通过设置行高与高的值相同，可以达到使单行文字垂直居中的目的。</p><p><strong>字体的简写属性</strong>：</p><p>直接通过font来设置字体相关的所以属性，格式：font: font-style  font-weight 字体大小/行高 字体族（ font-style  font-weight行高可以省略不写，不写使用默认样式）</p><p><strong>图标字体</strong></p><p>因为网页中经常需要使用一些图标，直接使用图片来引用的化，一来图片本身比较大，二来使用起来也非常的不灵活。所以我们使用图标时，我们可以将图标设置为字体，然后通过font-face的形式来对图标进行引入。</p><p><strong>fontawesome使用步骤：</strong></p><ol><li><p>下载<a href="https://fontawesome.com/%EF%BC%88%E4%BE%8B%E5%A6%82iconfont%E5%9B%BE%E6%A0%87%E5%BA%93%EF%BC%8C%E4%BD%86%E6%98%AFsang%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%89%88%E6%9D%83%E9%97%AE%E9%A2%98%EF%BC%89">https://fontawesome.com/（例如iconfont图标库，但是sang需要注意版权问题）</a></p></li><li><p>解压</p></li><li><p>将css和wedfonts移动到项目中</p></li><li><p>利用link将all.css引入到网页中</p></li><li><p>使用图标字体</p><ul><li>直接通过类名来使用图标字体 例如：<code>&lt;i class=“fas/fab fa-ball”&gt;&lt;/i&gt;</code>  fas和fab是类名， fa-ball是图标名称。同时我们还可以利用style设置大小颜色等</li><li>通过伪元素来使用，li::before{ content:”\f1b0”;font-familiy:’Font Awesome 5 Free’ ;font-weight:900;margin-right:10px;}</li><li>通过实体来实现,&amp;#x后面接图标的编码，例如<code>&lt;span class=&quot;fas&quot;&gt;&amp;#xf0f3;&lt;/span&gt;</code></li></ul></li></ol><p><strong>文本样式</strong>：</p><p>**text-align:**表示文本的对齐方式，可选值 left（左侧对齐），right（右侧对齐），center（居中对齐），justfy(两端对齐)</p><p>**vertical-align:**表示文本的垂直对齐，可选值baseline（默认值，基线对齐）top(顶部对齐)，bottom（底部对齐），middle（居中对齐），还可以直接指定值，例如vertical-align:10px</p><p>**text-decoration:**可选值 none(默认值) underline(下划线) overline(上划线)，格式：text-decoration:underline red(不过需要注意，颜色对于IE浏览器不支持)</p><p>**white-space:**设置网页如何处理空白，可选值 normal（正常），nowrap（不换行），pre（保留空白）</p><p>注意：关于将溢出文字以省略号的形式表达出来的方式</p><p>{width：200px;</p><p>white-space:nowrap;</p><p>overflow:hidden;</p><p>text-overflow:ellipsis;}</p><p>text-overflow:ellipsis;表示将溢出的文字以省略号的形式表达出来。</p><h2 id="6-背景图"><a href="#6-背景图" class="headerlink" title="6.背景图"></a>6.背景图</h2><p><strong>设置方式</strong>：<strong>background-image：url(”路径“)</strong></p><p>注意：如果背景图片小于元素。则背景图片会自动在元素中平铺，直至元素铺满；如果背景图片大于元素，将会有一部分图片无法显示；</p><p><strong>具体形式设置：</strong></p><p><strong>background-repeat</strong>属性用来设置背景的重复方式，可选值 repeat（默认值，背景会沿着x和y轴重复，直至铺满；repeat-x 沿着x值重复，repeat-y 沿着y轴重复  no-repeat：背景图片不重复）</p><p><strong>background-position</strong>属性用来设置背景图片的位置.通过top left  right bottom  center几个方位词来表示位置，例如background-position：left center(注意 使用方位次必须使用2个，如果使用1个，我们将默认第二个为center)；除此之外，我们还可以通过偏移量来指定背景图片的位置,需要2个值，水平方向偏移量，垂直方向偏移量，例如：background-position：50px，50px.</p><p><strong>background-clip</strong>属性实现背景与边框的设置 ，可选值 border-box(默认值，背景会出现在边框的下边) padding-box （背景不会出现在边框上，只会出现在内容区和内边距）content-box （背景只会出现在内容区）</p><p><strong>background-origin</strong>属性用于更改背景图片偏移量的计算原点，可选值 padding-box(默认值 ，background-position从内边距开始计算；）content-box（背景图的偏移量从内容区开始计算)，border-box（背景图片的偏移量从边框处开始计算）</p><p><strong>background-size</strong>属性用于设置背景图的尺寸，例如：background-size:50px 50px;如果只写一个值，那么第二个值默认auto；特殊的background-size:cover 表示自动铺满，background-size:contain表示图片比例不变，让图片在元素中完整显示；</p><p><strong>background-attachment</strong>属性用于控制背景图片是否跟随元素移动，可选值 scroll （默认值，背景图片会跟随元素移动） fixed（背景图片会固定在页面中，不会跟随元素移动）</p><p><strong>注意</strong>所有背景相关的属性都可以直接通过background：来设置，并且没有顺序要求，也没有哪个属性是必须写的，但是需要注意的是background-size必须写在background-position的后边，并且必须使用/隔开。而且background-origin background-clip两个样式如果写的话，orgin要在clip的后面。</p><p><strong>雪碧图</strong>：可以一次性将多个图片加载完成，降低请求次数，加快访问熟读速度，解决图片闪烁问题，也称为CSS-Sprite。</p><h2 id="7-渐变"><a href="#7-渐变" class="headerlink" title="7.渐变"></a>7.渐变</h2><p>渐变本身是图片，需要通过background-image来设置，</p><p><strong>线性渐变</strong>：使用方法：background-image：linear-gradient（red,yellow）表示以红色开头，黄色结尾的渐变（默认从上到下，如果存在第一个属性值，且值使用to left ,to right,to bottom,to top,xxxdeg，turn ,则表示渐变方向）；</p><p>注意：颜色可以使用多种,默认每种颜色平均分配。但是我们可以手动指定渐变的颜色分布情况，例如：background-image：linear-gradient（red 50px,yellow 100px）数值指定渐变起始位置。</p><p>background-image：repeating-linear-gradient（red 50px,yellow 100px）表示可以平铺的线性渐变</p><p><strong>径向渐变</strong>：</p><p>即让渐变拥有放射性的效果。默认情况下渐变的形状根据元素的形状而定，但是我们也可以手动设置，以改变渐变大小 形状与位置，语法background-image：radial-gradient（大小 at 位置，颜色 位置， 颜色 位置，颜色 位置）位置大小可以省略。</p><h2 id="8-表格"><a href="#8-表格" class="headerlink" title="8.表格"></a>8.表格</h2><p>除去常见的宽高，边框等设置，一些列出的是一些特殊的使用：</p><p>border-spacing：10px ;用于设置边框之间的距离，如果将其变为0的话，双线边框可以变为单线边框。</p><p>border-collapse:collapse；可以设置边框的合并。使双线边框可以变为单线边框。</p><p>我们还可以通过伪类来使表格的单数行和双数行使用不一样的颜色，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tbody tr:nth-child(odd)</span><br><span class="line">&#123;</span><br><span class="line">background-color:bfa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tbody是tr的父元素，由系统自动创建。</p><p><em>关于表格内文字的居中问题，我们可以使用vertical-align属性来和text-align属性设置，所以我们可以将一些元素设置为table（display：table-cell），然后使用vertical-align:midddle来实现居中。</em></p><h2 id="关于居中问题"><a href="#关于居中问题" class="headerlink" title="关于居中问题"></a>关于居中问题</h2><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ul><li>1.**（文本）使用vertical-align:**表示文本的垂直对齐，可选值baseline（默认值，基线对齐）top(顶部对齐)，bottom（底部对齐），middle（居中对齐），还可以直接指定值，例如vertical-align:10px</li><li>2.<strong>将行高与内容区的高设置为相同的。</strong></li></ul><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><ul><li><p>2.**（文本）使用text-align:**表示文本的对齐方式，可选值 left（左侧对齐），right（右侧对齐），center（居中对齐），justfy(两端对齐)</p></li><li><p>2.<strong>子元素在父元素中居中</strong>：将子元素与父元素的宽度设为一致的，然后将子元素设置text-align：center，就可以实现子元素的内容在父元素中水平居中。</p></li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><strong>cursor规则</strong>是设定网页浏览时用户鼠标指针的样式，也就是鼠标的图形形状。cursor：pointer设定鼠标的形状为一只伸出食指的手，这也是绝大多数浏览器里面鼠标停留在网页链接上方时候的样式<br>另外可以选择其他鼠标指针样式，常用的有default 箭头，crosshair 十字，progress 箭头和沙漏等等；</p><p><strong>解决页面缩小时，页面布局改变的问题</strong>：</p><p>1.给body加上一个min-width最小宽度，以px为单位，当页面缩小时，如果达到所设置的最小宽度，body的宽度不再改变，超出的部分会使用横向滚动条显示，其内所有元素的布局不会受到影响；</p><p>2.使用百分比设置宽度，这样在页面缩放时，页面各元素也会跟着缩放，宽度占比不变，不过前提是在设置CSS样式之前，先给body和HTML这两个元素设置宽度为100%，避免后面出错。</p><p>3.<strong>对于脱离文档流的元素（例如使用了绝对定位的元素）</strong>，由于我做的浮动是绝对定位（position:absolute），在外边加一个div层（给它一个父级），外边的div层加上相对（position:relative），然后再去调整子级的位置（top，left等）。</p><p>参考资料：</p><p><a href="https://www.bilibili.com/video/BV1XJ411X7Ud">https://www.bilibili.com/video/BV1XJ411X7Ud</a></p><p><a href="https://www.w3school.com.cn/h.asp">https://www.w3school.com.cn/h.asp</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS3基础学习记录&quot;&gt;&lt;a href=&quot;#CSS3基础学习记录&quot; class=&quot;headerlink&quot; title=&quot;CSS3基础学习记录&quot;&gt;&lt;/a&gt;CSS3基础学习记录&lt;/h1&gt;&lt;h2 id=&quot;1-css样式&quot;&gt;&lt;a href=&quot;#1-css样式&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python插入requests包时出现Requirement already satisfied问题</title>
    <link href="http://example.com/2021/07/28/Python%E6%8F%92%E5%85%A5requests%E5%8C%85%E6%97%B6%E5%87%BA%E7%8E%B0Requirement%20already%20satisfied%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/07/28/Python%E6%8F%92%E5%85%A5requests%E5%8C%85%E6%97%B6%E5%87%BA%E7%8E%B0Requirement%20already%20satisfied%E9%97%AE%E9%A2%98/</id>
    <published>2021-07-28T02:44:16.988Z</published>
    <updated>2021-07-28T02:46:52.458Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>记录一下PyCharm3.7插入requests包时出现的问题</p><span id="more"></span><h1 id="Python插入requests包时出现Requirement-already-satisfied问题"><a href="#Python插入requests包时出现Requirement-already-satisfied问题" class="headerlink" title="Python插入requests包时出现Requirement already satisfied问题"></a>Python插入requests包时出现Requirement already satisfied问题</h1><p>上网上查了一下，发现好多出现这个问题的原因都是在自己电脑上安装python的时候有其他python版本的残留，然后我在自己电脑里面查了一下，发现我有一个PyCharm2.x和一个PyCharm3.x的文件，尝试网上的教程来，发现还是不行，甚至出现了其他的问题，弄了好久还是没解决，我怀疑可能是之前下载时文件没归类，有些零散的原因，于是我直接把他们都删了，再重新安装下载了PyCharm3.7。</p><p>重新打开cmd，以管理员身份运行，输入<code>pip install requests</code></p><p>发现还是出现了一下问题（我寻思着，难道我还是没删干净）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Requirement already satisfied: requests in e:\python\lib\site-packages (2.26.0)</span><br><span class="line">Requirement already satisfied: urllib3&lt;1.27,&gt;=1.21.1 in e:\python\lib\site-packages (from requests) (1.26.6)</span><br><span class="line">Requirement already satisfied: idna&lt;4,&gt;=2.5; python_version &gt;= &quot;3&quot; in e:\python\lib\site-packages (from requests) (3.2)</span><br><span class="line">Requirement already satisfied: charset-normalizer~=2.0.0; python_version &gt;= &quot;3&quot; in e:\python\lib\site-packages (from requests) (2.0.3)</span><br><span class="line">Requirement already satisfied: certifi&gt;=2017.4.17 in e:\python\lib\site-packages (from requests) (2021.5.30)</span><br><span class="line">You are using pip version 19.0.3, however version 21.1.3 is available.</span><br><span class="line">You should consider upgrading via the &#x27;python -m pip install --upgrade pip&#x27; command.</span><br></pre></td></tr></table></figure><p>于是我按照他的提示重新输入<code>python -m pip install --upgrade pip</code></p><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collecting pip</span><br><span class="line">  Using cached https://files.pythonhosted.org/packages/47/ca/f0d790b6e18b3a6f3bd5e80c2ee4edbb5807286c21cdd0862ca933f751dd/pip-21.1.3-py3-none-any.whl</span><br><span class="line">Installing collected packages: pip</span><br><span class="line">  Found existing installation: pip 19.0.3</span><br><span class="line">    Uninstalling pip-19.0.3:</span><br><span class="line">      Successfully uninstalled pip-19.0.3</span><br><span class="line">Successfully installed pip-21.1.3</span><br></pre></td></tr></table></figure><p>之后再重新输入<code>pip install requests</code></p><p>发现结果还是有问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Requirement already satisfied: requests in e:\python\lib\site-packages (2.26.0)</span><br><span class="line">Requirement already satisfied: urllib3&lt;1.27,&gt;=1.21.1 in e:\python\lib\site-packages (from requests) (1.26.6)</span><br><span class="line">Requirement already satisfied: certifi&gt;=2017.4.17 in e:\python\lib\site-packages (from requests) (2021.5.30)</span><br><span class="line">Requirement already satisfied: idna&lt;4,&gt;=2.5 in e:\python\lib\site-packages (from requests) (3.2)</span><br><span class="line">Requirement already satisfied: charset-normalizer~=2.0.0 in e:\python\lib\site-packages (from requests) (2.0.3)</span><br></pre></td></tr></table></figure><p>于是我再尝试了一下网上的教程，输入<code>pip install --target=e:/python/lib/site-packages requests</code></p><p>然后我终于成功了！！！！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Collecting requests</span><br><span class="line">  Using cached requests-2.26.0-py2.py3-none-any.whl (62 kB)</span><br><span class="line">Collecting charset-normalizer~=2.0.0</span><br><span class="line">  Using cached charset_normalizer-2.0.3-py3-none-any.whl (35 kB)</span><br><span class="line">Collecting urllib3&lt;1.27,&gt;=1.21.1</span><br><span class="line">  Using cached urllib3-1.26.6-py2.py3-none-any.whl (138 kB)</span><br><span class="line">Collecting idna&lt;4,&gt;=2.5</span><br><span class="line">  Using cached idna-3.2-py3-none-any.whl (59 kB)</span><br><span class="line">Collecting certifi&gt;=2017.4.17</span><br><span class="line">  Using cached certifi-2021.5.30-py2.py3-none-any.whl (145 kB)</span><br><span class="line">Installing collected packages: urllib3, idna, charset-normalizer, certifi, requests</span><br><span class="line">Successfully installed certifi-2021.5.30 charset-normalizer-2.0.3 idna-3.2 requests-2.26.0 urllib3-1.26.6</span><br><span class="line">WARNING: Target directory e:\python\lib\site-packages\certifi already exists. Specify --upgrade to force replacement.</span><br><span class="line">WARNING: Target directory e:\python\lib\site-packages\certifi-2021.5.30.dist-info already exists. Specify --upgrade to force replacement.</span><br><span class="line">WARNING: Target directory e:\python\lib\site-packages\charset_normalizer already exists. Specify --upgrade to force replacement.</span><br><span class="line">WARNING: Target directory e:\python\lib\site-packages\charset_normalizer-2.0.3.dist-info already exists. Specify --upgrade to force replacement.</span><br><span class="line">WARNING: Target directory e:\python\lib\site-packages\idna already exists. Specify --upgrade to force replacement.</span><br><span class="line">WARNING: Target directory e:\python\lib\site-packages\idna-3.2.dist-info already exists. Specify --upgrade to force replacement.</span><br><span class="line">WARNING: Target directory e:\python\lib\site-packages\requests already exists. Specify --upgrade to force replacement.</span><br><span class="line">WARNING: Target directory e:\python\lib\site-packages\requests-2.26.0.dist-info already exists. Specify --upgrade to force replacement.</span><br><span class="line">WARNING: Target directory e:\python\lib\site-packages\urllib3 already exists. Specify --upgrade to force replacement.</span><br><span class="line">WARNING: Target directory e:\python\lib\site-packages\urllib3-1.26.6.dist-info already exists. Specify --upgrade to force replacement.</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;记录一下PyCharm3.7插入requests包时出现的问题&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>python爬虫基础学习</title>
    <link href="http://example.com/2021/07/28/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/07/28/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-07-27T16:00:00.000Z</published>
    <updated>2021-07-28T11:53:27.797Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>​        网络爬虫是一种按照一定的规则，自动地抓取万维网信息的<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F/13831935">程序</a>或者<a href="https://baike.baidu.com/item/%E8%84%9A%E6%9C%AC/1697005">脚本</a>。理论上，只要浏览器能够访问的数据，都可以通过爬虫获取。爬虫也可以应用在搜索引擎上，蜘蛛从索引区出发爬取网页，将抓取到的网页放到临时库进行处理，清除不符合规则的数据，然后将符合规则的数据在索引区中进行分类，归档，排序，最终将结果返回给用户。</p><span id="more"></span><h1 id="python爬虫基础学习"><a href="#python爬虫基础学习" class="headerlink" title="python爬虫基础学习"></a>python爬虫基础学习</h1><h2 id="爬虫的合法性"><a href="#爬虫的合法性" class="headerlink" title="爬虫的合法性"></a>爬虫的合法性</h2><p>我们可以通过查看<strong>Robots协议</strong>（也称为爬虫协议）来确保其合法性，一般网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。它是国际互联网界通行的道德规范，虽然没有写入法律，但是每一个爬虫都应该遵守这项协议。<br>例如 豆瓣的网址：<a href="https://book.douban.com/">https://book.douban.com/</a></p><p>​        我们可以查询到他的robots协议（网址为<a href="https://book.douban.com/robots.txt%EF%BC%89%EF%BC%8C%E5%85%B6%E4%B8%AD%E8%A7%84%E5%AE%9A%E4%BA%86%E9%A1%B5%E9%9D%A2%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%88%AC%E5%8F%96%EF%BC%9A">https://book.douban.com/robots.txt），其中规定了页面是否可以爬取：</a></p><p>​        以下就是豆瓣的robots协议内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: /subject_search</span><br><span class="line">Disallow: /search</span><br><span class="line">Disallow: /new_subject</span><br><span class="line">Disallow: /service/iframe</span><br><span class="line">Disallow: /j/</span><br><span class="line">Sitemap: http://www.douban.com/sitemap_index.xml</span><br><span class="line">Sitemap: http://www.douban.com/sitemap_updated_index.xml</span><br><span class="line"></span><br><span class="line">User-agent: Wandoujia Spider</span><br><span class="line">Disallow: /</span><br></pre></td></tr></table></figure><h2 id="爬虫基本流程"><a href="#爬虫基本流程" class="headerlink" title="爬虫基本流程"></a>爬虫基本流程</h2><p>目的：爬取书籍《小时候》的作者，出版社，定价，内容简介</p><ol><li><p>准备工作</p><p>通过浏览器查看分析网页，点开源代码，找到所需爬取信息的位置，需要一些前端知识。</p></li><li><p>获取数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">base_url=&#x27;https://book.douban.com/subject/35476387/?icn=index-latestbook-subject&#x27;</span><br><span class="line">headers=&#123;</span><br><span class="line">    &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36 Edg/92.0.902.55&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">response=requests.get(base_url,headers=headers)</span><br><span class="line">print(response.content.decode(&#x27;utf-8&#x27;))</span><br></pre></td></tr></table></figure><p>通过以上代码就可以实现获取页面源代码</p></li><li><p>解析内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">base_url=&#x27;https://book.douban.com/subject/35476387/?icn=index-latestbook-subject&#x27;</span><br><span class="line">headers=&#123;</span><br><span class="line">    &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36 Edg/92.0.902.55&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">response=requests.get(base_url,headers=headers)</span><br><span class="line"></span><br><span class="line">bs=BeautifulSoup(response.content.decode(&#x27;utf-8&#x27;),&#x27;html.parser&#x27;)</span><br><span class="line"></span><br><span class="line">info=bs.find_all(&#x27;div&#x27;, &#123;&quot;class&quot;: &quot;&quot;,&quot;id&quot;:&quot;info&quot;&#125;)    #确定作者，出版社，定价的位置</span><br><span class="line">info1=bs.find_all(&#x27;div&#x27;, &#123;&quot;class&quot;: &quot;intro&quot;&#125;)  #确定简介的位置</span><br><span class="line">info=str(info)</span><br><span class="line">#利用正则表达式确定查找标准</span><br><span class="line">find_writer=re.compile(r&#x27;&lt;a class=&quot;&quot; href=&quot;/search/%E6%A1%91%E6%A0%BC%E6%A0%BC&quot;&gt;(.*?)&lt;/a&gt;&#x27;)</span><br><span class="line">find_pub=re.compile(r&#x27;&lt;span class=&quot;pl&quot;&gt;出版社:&lt;/span&gt; (.*?)&lt;br/&gt;&#x27;)</span><br><span class="line">find_pri=re.compile(r&#x27;&lt;span class=&quot;pl&quot;&gt;定价:&lt;/span&gt; (.*?)&lt;br/&gt;&#x27;)</span><br><span class="line">#得出查找对象</span><br><span class="line">re_writer=re.findall(find_writer,info)</span><br><span class="line">re_pub=re.findall(find_pub,info)</span><br><span class="line">re_pri=re.findall(find_pri,info)</span><br><span class="line">#打印查找对象</span><br><span class="line">print(&#x27;作者：&#x27;,re_writer[0])</span><br><span class="line">print(&#x27;出版社：&#x27;,re_pub[0])</span><br><span class="line">print(&#x27;定价：&#x27;,re_pri[0])</span><br><span class="line">print(&#x27;简介：&#x27;,info1[1].text.replace(&#x27; &#x27;,&#x27;\n&#x27;))  </span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">作者： 桑格格</span><br><span class="line">出版社： 北京十月文艺出版社</span><br><span class="line">定价： 79</span><br><span class="line">简介： </span><br><span class="line">★桑格格《小时候》全新编订版，在旧版图文叙事的基础上，增加近15万字篇幅。</span><br><span class="line">★一部跳跃、魔幻、爆笑、忧伤的女孩成长记，带领我们穿越到世界年纪还小的时候。</span><br><span class="line">★一座封存记忆的纯真博物馆，一颗拒绝长大的童心，历经忧伤、动荡、裂变，内心的纯真依旧完好无损。</span><br><span class="line">★四川话版的“麦兜故事”，花椒般活色生香的小人物群像，无数人的成长记忆。</span><br><span class="line">★小时候永远消失了，但关于小时候的记忆，却始终治愈我们。</span><br><span class="line">★易烊千玺、李娟、史航、何小竹一致推荐。</span><br><span class="line">·</span><br><span class="line">桑格格的半自传体长篇小说。全书用混合着四川方言的口语写成，以2258个词条讲述了一个女娃子从蹒跚学步到二十多岁闯荡大城市的成长经历。</span><br><span class="line">本书以时间为轴，一个成都女童的主观世界跳跃着展开：从乡下寄养到厂区子弟，从牙牙学语到呼朋引伴，从幼儿园到恋爱，从被大人守护到守护大人……</span><br><span class="line">小时候的人和事，被桑格格以散点叙事的方式娓娓道来，如同儿童记忆特有的前后颠倒和琐碎，妙趣盎然，还有几分淡淡的梦幻色彩。</span><br><span class="line">这是一本大部头的小人书，举重若轻，在令读者捧腹之余，不经意地划过了二十多年的时间——那是一个被时间吞噬了的消失的时代，但这个孩子的鲜活形象和她的童心，却映射在时代的变迁之中。</span><br></pre></td></tr></table></figure><p><strong>替换字符常用方法：</strong></p><ul><li><p>re.sub(pattern, repl, string, count=0, flags=0)方法：pattern表示正则表达式中的模式字符串；repl被替换的字符串（既可以是字符串，也可以是函数）；string表示要被处理的，要被替换的字符串；count表示匹配的次数, 默认是全部替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">st = &quot;hello 2019&quot;</span><br><span class="line">st = re.sub(&quot;([0-9]+)&quot;,&quot;maymay&quot;,st)</span><br><span class="line">print(st)</span><br></pre></td></tr></table></figure><p>结果为：<code>hello maymay</code></p></li><li><p>str.replace(old, new[, max])方法：old 是将被替换的子字符串。new 是新字符串，用于替换old子字符串。max是可选字符串, 替换不超过 max 次。</p></li><li><p>str.strip([chars])方法：去除字符串前面和后面的所有设置的字符串chars，默认为空格。</p></li></ul></li><li><p>保存数据</p></li></ol><p>未完待续</p><p>参考网址：</p><p><a href="https://www.bilibili.com/video/BV12E411A7ZQ?p=22">https://www.bilibili.com/video/BV12E411A7ZQ?p=22</a></p><p><a href="https://blog.csdn.net/qq_40558166/article/details/102868801?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162717841016780261987353%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162717841016780261987353&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-102868801.pc_search_all_es&amp;utm_term=python%E7%88%AC%E8%99%AB&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/qq_40558166/article/details/102868801?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162717841016780261987353%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162717841016780261987353&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-102868801.pc_search_all_es&amp;utm_term=python%E7%88%AC%E8%99%AB&amp;spm=1018.2226.3001.4187</a></p><p><a href="https://blog.csdn.net/lwgkzl/article/details/85544871?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162746758016780366583265%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162746758016780366583265&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-85544871.pc_search_result_before_js&amp;utm_term=sub+replace&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/lwgkzl/article/details/85544871?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162746758016780366583265%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162746758016780366583265&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-85544871.pc_search_result_before_js&amp;utm_term=sub+replace&amp;spm=1018.2226.3001.4187</a></p><p>正则表达式参考链接：<a href="https://www.zhihu.com/question/48219401/answer/742444326">(4 条消息) 你是如何学会正则表达式的？ - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​        网络爬虫是一种按照一定的规则，自动地抓取万维网信息的&lt;a href=&quot;https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F/13831935&quot;&gt;程序&lt;/a&gt;或者&lt;a href=&quot;https://baike.baidu.com/item/%E8%84%9A%E6%9C%AC/1697005&quot;&gt;脚本&lt;/a&gt;。理论上，只要浏览器能够访问的数据，都可以通过爬虫获取。爬虫也可以应用在搜索引擎上，蜘蛛从索引区出发爬取网页，将抓取到的网页放到临时库进行处理，清除不符合规则的数据，然后将符合规则的数据在索引区中进行分类，归档，排序，最终将结果返回给用户。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>HTML学习笔记</title>
    <link href="http://example.com/2021/07/23/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/07/23/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-22T16:00:00.000Z</published>
    <updated>2021-09-30T09:19:57.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML学习笔记"><a href="#HTML学习笔记" class="headerlink" title="HTML学习笔记"></a>HTML学习笔记</h1><p>首先，HTML 指的是超文本标记语言 ，HTML文档包含HTML标签和纯文本，我们通过HTML文档来描述网页。Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容。</p><span id="more"></span><h2 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h2><ol><li><p><code>&lt;header&gt;/&lt;/header&gt;</code>：表示头部，<code>&lt;header&gt;</code>里面不能包含另一个<code>&lt;header&gt;</code>或<code>&lt;footer&gt;</code>。</p></li><li><p><code>&lt;footer&gt;/&lt;/footer&gt;</code>：表示尾部，<code>&lt;footer&gt;</code>不能嵌套，即内部不能放置另一个<code>&lt;footer&gt;</code>，也不能放置<code>&lt;header&gt;</code>。</p></li><li><p><code>&lt;main&gt;/&lt;/main&gt;</code>：表示主题,一个页面只能有一个<code>&lt;main&gt;</code>。</p></li><li><p><code>&lt;article&gt;/&lt;/article&gt;</code>:一个网页可以包含一个或多个<code>&lt;article&gt;</code>，比如包含多篇文章</p></li><li><p><code>&lt;aside&gt;/&lt;/aside&gt;</code>:用来放置与网页或文章主要内容间接相关的部分。网页级别的<code>&lt;aside&gt;</code>，可以用来放置侧边栏，但不一定就在页面的侧边；文章级别的<code>&lt;aside&gt;</code>，可以用来放置评论或注释。</p></li><li><p><code>&lt;section&gt;/&lt;/section&gt;</code>:表示一个含有主题的独立部分，通常用在文档里面表示一个章节，比如<code>&lt;article&gt;</code>可以包含多个<code>&lt;section&gt;</code>。<code>&lt;section&gt;</code>总是多个一起使用，一个页面不能只有一个<code>&lt;section&gt;</code>。</p></li><li><p><code>&lt;nav&gt;/&lt;/nav&gt;</code>:用于放置页面或文档的导航信息,一般来说，<code>&lt;nav&gt;</code>往往放置在<code>&lt;header&gt;</code>里面，另外，一个页面可以有多个<code>&lt;nav&gt;</code>，比如一个用于站点导航，另一个用于文章导航。</p></li><li><p><code>&lt;h1&gt; - &lt;h6&gt;</code>：表示标题，   eg.<code>&lt;h1&gt;这是标题&lt;/h1&gt;</code></p></li><li><p><code>&lt;hgroup&gt;/&lt;/hgroup&gt;</code>:如果主标题包含多级标题（比如带有副标题），那么可以使用<code>&lt;hgroup&gt;</code>标签，将多级标题放在其中。注意，<code>&lt;hgroup&gt;</code>只能包含<code>&lt;h1&gt;</code>~`</p><h6>`，不能包含其他标签。<p></p></h6></li><li><p><code>&lt;br&gt;</code>:换行。</p></li><li><p><code>&lt;div&gt;/&lt;/div&gt;</code>:分块。</p></li><li><p><code>&lt;span&gt;/&lt;/span&gt;</code>:行内元素，用于选中文字，没有实际意义。</p></li><li><p><code>&lt;p&gt;/&lt;/p&gt;</code>:表示段落,eg.<code>&lt;p&gt;这是段落&lt;/p&gt;</code>，lore自动生成英文文本。</p></li><li><p><code>水平线</code>：eg.<code>&lt;hr&gt;</code></p></li><li><p><code>注释</code>:eg.<code>&lt;!-- 这是注释 --&gt;</code></p></li><li><p><strong>列表</strong>：</p><ul><li><p>无序列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">   &lt;li&gt;结构&lt;/li&gt;</span><br><span class="line">   &lt;li&gt;表现&lt;/li&gt;</span><br><span class="line">   &lt;li&gt;行为&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></li><li><p>有序列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">   &lt;li&gt;结构&lt;/li&gt;</span><br><span class="line">   &lt;li&gt;表现&lt;/li&gt;</span><br><span class="line">   &lt;li&gt;行为&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure></li><li><p>定义列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">  &lt;dt&gt;结构&lt;/dt&gt;</span><br><span class="line">  &lt;dd&gt;结构表示网页的结构&lt;/dd&gt;</span><br><span class="line">  &lt;dd&gt;结构表示网页的结构&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>超链接</strong>：</p><p>eg.<code>&lt;a href=&quot;http://www.w3school.com.cn&quot;&gt; 这是链接&lt;/a&gt;</code>，它可以嵌套除本身之外的其他任何标签。</p><p>ps:在 href 属性中指定链接的地址，target属性指定超链接打开的位置（_self ：在当前界面打开， _blank:在新都界面打开）</p><p>特别用法：<code>&lt;a href=&quot;#&quot;&gt;回到顶部&lt;/a&gt;</code></p><p>​                   <code> &lt;a href=&quot;ID&quot;&gt;回到id=ID的位置&lt;/a&gt;</code></p><p>​                   当还没有确定href值的时候，可以用<code>javascript:;</code>做为href的占位符使用。</p></li><li><p><strong>图像</strong>：</p><p>eg.<code>&lt;img src=&quot;w3school.jpg&quot; width=&quot;104&quot; height=&quot;142&quot; /&gt;</code></p><p>ps:图像的名称和尺寸是以属性的形式提供的。如果高度和宽度只改变一个，那么另一个会等比例缩放。而且alt属性值为图片的描述，这种情况下不会显示，有的浏览器在图片加载不出来的时候会显示。搜索引擎可以通过alt内容来识别图片，查询图片。</p><p>图片格式：</p><ul><li><p>jpeg(jpg)：支持的颜色比较丰富，不支持动图，透明效果，一般用来显示照片。</p></li><li><p>gif：支持的颜色比较少，支持动图透明效果，一般用于颜色单一的图片，动图。</p></li><li><p>png：支持的颜色丰富，支持复杂透明，不支持动图，专为网页而生。</p></li><li><p>webp：谷歌推出的专门用来表示网页中图片的一种格式，具备其他图片的优点，文件小。缺点：兼容性不好。</p></li><li><p>base64：将图片使用base64编码，将图片转换成字符，通过字符的形式引入图片，一般都是用于一些需要和网页一起加载的图片。</p><p>总之，效果一样，用小的；效果不一样，用效果好的。</p></li></ul></li><li><p><strong>内联框架</strong>：用于向当前页面引入其他页面</p><p><code>&lt;iframe src=&quot;其他页面的网址&quot; width=&#39;900&#39; height=&#39;900&#39; frameborder=0&gt;&lt;/iframe&gt;</code></p><p>frameborder指框架的边框。</p></li><li><p><strong>音频视频</strong>：</p><ul><li><p><code>&lt;audio src=“ ” controls&gt;&lt;/audio&gt;</code>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;audio controls&gt;</span><br><span class="line">    对不起，您的浏览器不支持该文件</span><br><span class="line">    &lt;source src=&quot; &quot;&gt;</span><br><span class="line">    &lt;source src=&quot; &quot;&gt;</span><br><span class="line">    &lt;source src=&quot; &quot;&gt;</span><br><span class="line">&lt;/audio&gt;</span><br></pre></td></tr></table></figure><p>或者<code>&lt;embed src=&quot; &quot; type=&quot;&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;</code></p></li></ul><p>controls属性可以使用户控制音频，不加默认不可控制</p><p>autoplay属性控制打开时自动播放（但是当前好多浏览器不能支持自动播放）</p><p>loop属性控制循环播放</p><ul><li>```<video controls>  <source src=" ">  <source src=" "></video>使用方法和audio相似<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">**21.表格**</span><br><span class="line"></span><br><span class="line">普通表格</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><tr><td>    a1    </td><td>    a1    </td><td>    a1    </td></tr><tr><td>    a1    </td><td>    a1    </td><td>    a1    </td></tr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">通过在td中使用colspan属性来横向合并单元格，使用rowspan纵向合并单元格，例如`&lt;td colspan=&quot;2&quot;&gt;a&lt;/td&gt;`表示横向合并两个单元格。</span><br><span class="line"></span><br><span class="line">长表格</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;日期&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;收入&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;支出&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;合计&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/thead&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;2000.1.1&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;20&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;10&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;10&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;2000.1.1&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;20&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;10&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;10&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;&lt;tr&gt;</span><br><span class="line">            &lt;td&gt;2000.1.1&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;20&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;10&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;10&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">    &lt;tfoot&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;合计&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;100&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/tfoot&gt;</span><br></pre></td></tr></table></figure></table></li></ul></li></ol><p><strong>22.输入框</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=“搜索” class=&quot;box2&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>23.按钮</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type=&quot;bottom&quot; name=&quot;确定&quot;  class=&quot;box3&quot;&gt;   搜索&lt;/button&gt;</span><br></pre></td></tr></table></figure><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>在现实生活中，表单用于提交数据，在网页中，表单用于将本地的数据提交给远程的服务器；</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><code>accept-charset</code>：服务器接受的字符编码列表，使用空格分隔，默认与网页编码相同。</li><li><code>action</code>：服务器接收数据的 URL。</li><li><code>autocomplete</code>：如果用户没有填写某个控件，浏览器是否可以自动填写该值。它的可能取值分别为<code>off</code>（不自动填写）和<code>on</code>（自动填写）。</li><li><code>method</code>：提交数据的 HTTP 方法，可能的值有<code>post</code>（表单数据作为 HTTP 数据体发送），<code>get</code>（表单数据作为 URL 的查询字符串发送），<code>dialog</code>（表单位于<code>&lt;dialog&gt;</code>内部使用）。</li><li><code>enctype</code>：当<code>method</code>属性等于<code>post</code>时，该属性指定提交给服务器的 MIME 类型。可能的值为<code>application/x-www-form-urlencoded</code>（默认值），<code>multipart/form-data</code>（文件上传的情况），<code>text/plain</code>。</li><li><code>name</code>：表单的名称，应该在网页中是唯一的。注意，如果一个控件没有设置<code>name</code>属性，那么这个控件的值就不会作为键值对，向服务器发送。</li><li><code>novalidate</code>：布尔属性，表单提交时是否取消验证。</li><li><code>target</code>：在哪个窗口展示服务器返回的数据，可能的值有<code>_self</code>（当前窗口），<code>_blank</code>（新建窗口），<code>_parent</code>（父窗口），<code>_top</code>（顶层窗口），<code>&lt;iframe&gt;</code>标签的<code>name</code>属性（即表单返回结果展示在<code>&lt;iframe&gt;</code>窗口）。</li></ul><p><strong>创建表单</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;服务器的地址&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--创建文本框用于输入数据--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;文本&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--换行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--密码框--&gt;</span></span><br><span class="line">    密码框 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;密码&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--提交按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮的内容&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--单选按钮，只有当name值相同的时候才能实现单选的效果,并且需要明确value的值来实现对所选按钮的辨别,checked 属性可以将单选按钮设置为默认选择项--&gt;</span></span><br><span class="line">    单选按钮 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;选择&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;选择&quot;</span> <span class="attr">value</span>=<span class="string">&quot;b&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--多选框--&gt;</span></span><br><span class="line">    对选框 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--下拉列表，通过selected来设置默认选择项--&gt;</span></span><br><span class="line">    下拉列表 <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>选项一<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>选项二<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>选项三<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HTML其他标签可查阅以下链接:<a href="https://wangdoc.com/html/">HTML 教程 - 网道 (wangdoc.com)</a></p><h2 id="常用全局属性"><a href="#常用全局属性" class="headerlink" title="常用全局属性"></a>常用全局属性</h2><ol><li><p><strong>id</strong>:属性是元素在网页内的唯一标识符,在最前面加上<code>#</code>，放到 URL 中作为锚点，定位到该元素在网页内部的位置。eg.<code>&lt;p id=&quot;p1&quot;&gt;&lt;/p&gt;</code></p></li><li><p><strong>class</strong>:用来对网页元素进行分类。如果不同元素的<code>class</code>属性值相同，就表示它们是一类的。元素可以同时具有多个 class，它们之间使用空格分隔。eg.<code>&lt;p class=&quot;p1 p2 p3&quot;&gt;&lt;/p&gt;</code></p></li><li><p><strong>title</strong>:用来为元素添加附加说明。大多数浏览器中，鼠标悬浮在元素上面时，会将<code>title</code>属性值作为浮动提示，显示出来。</p></li><li><p><strong>tabindex</strong>:当使用Tab进行网页浏览时，可以控制网页焦点转移的顺序；如果tabindex属性值为负整数，则该元素可以获得焦点（比如使用 JavaScript 的<code>focus()</code>方法），但不参与 Tab 键对网页元素的遍历。这个值通常是<code>-1</code>。如果是0，则该元素参与 Tab 键的遍历，顺序由浏览器指定，通常是按照其在网页里面出现的位置。如果是正整数，则网页元素按照从小到大的顺序（1、2、3、……），参与 Tab 键的遍历。</p><p>一般将属性值设为0；</p><p>详细内容参考链接：<a href="https://wangdoc.com/html/attribute.html">网页元素的属性 - HTML 教程 - 网道 (wangdoc.com)</a></p></li><li><p><strong>accesskey</strong>:设置网页快捷键。eg.<code>&lt;button accesskey=&quot;s&quot;&gt;提交&lt;/button&gt;</code>,其中button的快捷键就是s,不过实际操作时，要配合功能键，例如 Windows 系统的功能键时Alt,所以快捷键是<code>Alt + 字符键s</code></p></li><li><p><strong>style</strong>:指定当前元素的 CSS 样式.eg.<code>&lt;p style=&quot;color: red;&quot;&gt;hello&lt;/p&gt;</code></p></li><li><p><strong>hidden</strong>:一个布尔属性，表示当前的网页元素不再跟页面相关，因此浏览器不会渲染这个元素，所以就不会在网页中看到它。CSS 的可见性设置，高于<code>hidden</code>属性。eg.<code>&lt;p hidden&gt;隐藏&lt;/p&gt;</code></p><p><strong>对于布尔属性，即属性值是一个布尔值，只有“打开”和“关闭”两种情况。这时属性值可以省略，只要添加了属性名，就表示打开该属性。</strong></p></li><li><p><strong>lang</strong>:指定网页元素使用的语言.eg.<code>&lt;p lang=&quot;en&quot;&gt;this is English&lt;/p&gt;</code>      <code>&lt;p lang=&quot;zh&quot;&gt;这是中文&lt;/p&gt;</code></p></li><li><p><strong>dir</strong>:表示文字的阅读方向,属性值如下：</p><ul><li><p><code>ltr</code>：从左到右阅读，比如英语。</p></li><li><p><code>rtl</code>：从右到左阅读，阿拉伯语、波斯语、希伯来语都属于这一类。</p></li><li><p><code>auto</code>：浏览器根据内容的解析结果，自行决定。</p></li></ul></li><li><p><strong>contenteditable</strong>:HTML 网页的内容默认是用户不能编辑，<code>contenteditable</code>属性允许用户修改内容。它有两个可能的值。该类型不是布尔类型，而是枚举类型，因此书写时需要带上属性值。</p><ul><li><code>true</code>或空字符串：内容可以编辑</li><li><code>false</code>：不可以编辑</li></ul></li><li><p><strong>spellcheck</strong>:表示编辑时是否打开拼写检查，有true/false两种属性值，但它不是布尔类型，而是枚举类型。</p></li><li><p>**data-**：用于放置自定义数据。如果没有其他属性或元素合适放置数据，就可以放在<code>data-</code>属性。eg.<code>&lt;a href=&quot;#&quot; class=&quot;tooltip&quot; data-tip=&quot;this is the tip!&quot;&gt;链接&lt;/a&gt;</code>,上面代码中，<code>data-tip</code>用于放置链接的提示文字。</p></li><li><p><strong>事件处理属性</strong>：用于响应用户的动作。</p></li></ol><p>注意：没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。<code>&lt;br&gt;</code> 就是没有关闭标签的空元素（<code>&lt;br&gt;</code> 标签定义换行）。在开始标签中添加斜杠，比如 <code>&lt;br /&gt;</code>，是关闭空元素的正确方法</p><p>参考链接：</p><p><a href="https://wangdoc.com/html/encode.html">HTML 字符编码 - HTML 教程 - 网道 (wangdoc.com)</a></p><p><a href="https://wangdoc.com/html/">HTML 教程 - 网道 (wangdoc.com)</a></p><p><a href="https://www.w3school.com.cn/tags/html_ref_standardattributes.asp">HTML 全局属性 (w3school.com.cn)</a></p><p><a href="https://www.w3school.com.cn/tags/index.asp">HTML 标签参考手册 (w3school.com.cn)</a></p><p><a href="https://www.runoob.com/tags/ref-byfunc.html">https://www.runoob.com/tags/ref-byfunc.html</a></p><p><a href="https://www.w3school.com.cn/html/html_jianjie.asp">HTML 简介 (w3school.com.cn)</a></p><p><a href="https://www.bilibili.com/video/BV1XJ411X7Ud?from=search&seid=2964603063875200421">【尚硅谷】Web前端零基础入门HTML5+CSS3基础教程丨初学者从入门到精通_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;HTML学习笔记&quot;&gt;&lt;a href=&quot;#HTML学习笔记&quot; class=&quot;headerlink&quot; title=&quot;HTML学习笔记&quot;&gt;&lt;/a&gt;HTML学习笔记&lt;/h1&gt;&lt;p&gt;首先，HTML 指的是超文本标记语言 ，HTML文档包含HTML标签和纯文本，我们通过HTML文档来描述网页。Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>python基础学习</title>
    <link href="http://example.com/2021/07/19/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/07/19/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-07-19T10:06:41.000Z</published>
    <updated>2021-07-22T07:59:48.048Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此博客为个人笔记，记录了个人认为常用的知识点</p><span id="more"></span><h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h2><h3 id="1-1-单行注释"><a href="#1-1-单行注释" class="headerlink" title="1.1.单行注释"></a>1.1.单行注释</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#这是一个单行注释</span><br></pre></td></tr></table></figure><h3 id="1-2-多行注释"><a href="#1-2-多行注释" class="headerlink" title="1.2.多行注释"></a>1.2.多行注释</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">这是多行注释</span><br><span class="line">这是多行注释</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><h2 id="2-输入与输出"><a href="#2-输入与输出" class="headerlink" title="2.输入与输出"></a>2.输入与输出</h2><h3 id="2-1-输入："><a href="#2-1-输入：" class="headerlink" title="2.1.输入："></a>2.1.输入：</h3><p>函数<code>input（）</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=input()</span><br></pre></td></tr></table></figure><h3 id="2-2-输出："><a href="#2-2-输出：" class="headerlink" title="2.2.输出："></a>2.2.输出：</h3><p>函数<code>print()</code><br>输出字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;hello world!&#x27;)</span><br><span class="line">print(&#x27;hello&#x27;,&#x27;world!&#x27;)</span><br></pre></td></tr></table></figure><p>输出变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(name)</span><br></pre></td></tr></table></figure><h3 id="2-3-输出格式化："><a href="#2-3-输出格式化：" class="headerlink" title="2.3.输出格式化："></a>2.3.输出格式化：</h3><table><thead><tr><th>格式符号</th><th>转换</th></tr></thead><tbody><tr><td>%s</td><td>字符串</td></tr><tr><td>%d</td><td>有符号的十进制整数</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%c</td><td>字符</td></tr><tr><td>%u</td><td>无符号十进制整数</td></tr><tr><td>%o</td><td>八进制整数</td></tr><tr><td>%x</td><td>十六进制整数（小写ox）</td></tr><tr><td>%X</td><td>十六进制整数（大写OX）</td></tr><tr><td>%e</td><td>科学计数法（小写e）</td></tr><tr><td>%E</td><td>科学计数法（大写E）</td></tr><tr><td>%g</td><td>%f和%e的简写</td></tr><tr><td>%G</td><td>%f和%E的简写</td></tr></tbody></table><h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h2><p><img src="/E:/软件\typora\图片\QQ图片20210722130814.png" alt="数据类型"></p><p><strong>python定义变量时无需指定变量类型</strong><br>检查数据类型的方法： <code>type()</code></p><h2 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4.运算符"></a>4.运算符</h2><p>4.1算术运算符<br>4.2比较运算符<br>4.3辅助运算符<br>4.4位运算符<br>4.5逻辑运算符<br>4.6成员运算符<br>4.7各类运算符的优先级</p><h2 id="5-条件判断语句"><a href="#5-条件判断语句" class="headerlink" title="5.条件判断语句"></a>5.条件判断语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name=int(input())</span><br><span class="line">if name&lt;4:</span><br><span class="line">    name-=2</span><br><span class="line">elif name&lt;7:</span><br><span class="line">    name+=2</span><br><span class="line">else:</span><br><span class="line">    name-=4</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure><h2 id="6-循环语句"><a href="#6-循环语句" class="headerlink" title="6.循环语句"></a>6.循环语句</h2><h3 id="6-1-for循环"><a href="#6-1-for循环" class="headerlink" title="6.1.for循环"></a>6.1.for循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for letter in &quot;hello&quot;:   #案例1</span><br><span class="line">    print(letter)</span><br><span class="line">name=[&#x27;tom&#x27;,&#x27;tony&#x27;,&#x27;sherry&#x27;]  #案例2</span><br><span class="line">for myname in name:</span><br><span class="line">    print(&#x27;hello&#x27;,myname)</span><br><span class="line">number=[0,1,2,3,4,5,6,7,8,9]  #案例3</span><br><span class="line">for num in range(0,10,2):</span><br><span class="line">    print(num)</span><br></pre></td></tr></table></figure><p>以上代码输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">h</span><br><span class="line">e</span><br><span class="line">l</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">hello tom</span><br><span class="line">hello tony</span><br><span class="line">hello sherry</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="6-2while循环"><a href="#6-2while循环" class="headerlink" title="6.2while循环"></a>6.2while循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=1</span><br><span class="line">while a&lt;4:</span><br><span class="line">    print(&#x27;hello&#x27;)</span><br><span class="line">    a+=1</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h2 id="7-函数"><a href="#7-函数" class="headerlink" title="7.函数"></a>7.函数</h2><h3 id="7-1一般函数格式"><a href="#7-1一般函数格式" class="headerlink" title="7.1一般函数格式"></a>7.1一般函数格式</h3><p><code>def</code> 和 <code>return</code> 为关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def sum1(num1,num2):  #求两数和</span><br><span class="line">    print(num1+num2)</span><br><span class="line">sum1(1,2)</span><br></pre></td></tr></table></figure><p>结果为<br><code>3</code></p><h3 id="7-2函数带有不定长参数"><a href="#7-2函数带有不定长参数" class="headerlink" title="7.2函数带有不定长参数"></a>7.2函数带有不定长参数</h3><p>第一种方式：在参数前加<code>*</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def print_user_info( name ,  age  , sex = &#x27;男&#x27; , * hobby):</span><br><span class="line">    # 打印用户信息</span><br><span class="line">    print(&#x27;昵称：&#123;&#125;&#x27;.format(name) , end = &#x27; &#x27;)</span><br><span class="line">    print(&#x27;年龄：&#123;&#125;&#x27;.format(age) , end = &#x27; &#x27;)</span><br><span class="line">    print(&#x27;性别：&#123;&#125;&#x27;.format(sex) ,end = &#x27; &#x27; )</span><br><span class="line">    print(&#x27;爱好：&#123;&#125;&#x27;.format(hobby))</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line"># 调用 print_user_info 函数</span><br><span class="line">print_user_info( &#x27;小明&#x27; , 25, &#x27;男&#x27;, &#x27;打篮球&#x27;,&#x27;打羽毛球&#x27;,&#x27;跑步&#x27;)</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">昵称：小明 年龄：25 性别：男 爱好：(&#x27;打篮球&#x27;, &#x27;打羽毛球&#x27;, &#x27;跑步&#x27;)</span><br></pre></td></tr></table></figure><p>通过输出的结果可以知道，<code>* hobby</code> 是可变参数，且 hobby 其实就是一个 tuple （元祖）。<br>第二种方式：在参数前加<code>**</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def print_user_info( name ,  age  , sex = &#x27;男&#x27; , ** hobby ):</span><br><span class="line">    # 打印用户信息</span><br><span class="line">    print(&#x27;昵称：&#123;&#125;&#x27;.format(name) , end = &#x27; &#x27;)</span><br><span class="line">    print(&#x27;年龄：&#123;&#125;&#x27;.format(age) , end = &#x27; &#x27;)</span><br><span class="line">    print(&#x27;性别：&#123;&#125;&#x27;.format(sex) ,end = &#x27; &#x27; )</span><br><span class="line">    print(&#x27;爱好：&#123;&#125;&#x27;.format(hobby))</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line"># 调用 print_user_info 函数</span><br><span class="line">print_user_info( name = &#x27;小明&#x27; , age = 25 , sex = &#x27;男&#x27;, hobby = (&#x27;打篮球&#x27;,&#x27;打羽毛球&#x27;,&#x27;跑步&#x27;))</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">昵称：小明 年龄：25 性别：男 爱好：&#123;&#x27;hobby&#x27;: (&#x27;打篮球&#x27;, &#x27;打羽毛球&#x27;, &#x27;跑步&#x27;)&#125;</span><br></pre></td></tr></table></figure><p><code>** hobby</code>是关键字参数，且 hobby 就是一个 dict （字典）<br><strong>关键字参数使用起来简单，不容易参数出错，那么有些时候，我们定义的函数希望某些参数强制使用关键字参数传递，这时候只需要将将强制关键字参数放到某个<em>参数或者单个</em>后面就能达到这种效果,例如：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def print_user_info( name , *, age, sex = &#x27;男&#x27; ):</span><br><span class="line">    print(&#x27;昵称：&#123;&#125;&#x27;.format(name) , end = &#x27; &#x27;)</span><br><span class="line">    print(&#x27;年龄：&#123;&#125;&#x27;.format(age) , end = &#x27; &#x27;)</span><br><span class="line">    print(&#x27;性别：&#123;&#125;&#x27;.format(sex))</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line"># 调用 print_user_info 函数</span><br><span class="line">print_user_info( name = &#x27;小明&#x27; ,age = 25 , sex = &#x27;男&#x27; )</span><br><span class="line"></span><br><span class="line"># 这种写法会报错，因为 age ，sex 这两个参数强制使用关键字参数</span><br><span class="line">#print_user_info( &#x27;小明&#x27; , 25 , &#x27;男&#x27; )</span><br><span class="line">print_user_info(&#x27;小明&#x27;,age=&#x27;22&#x27;,sex=&#x27;男&#x27;)</span><br></pre></td></tr></table></figure><h3 id="7-3匿名函数"><a href="#7-3匿名函数" class="headerlink" title="7.3匿名函数"></a>7.3匿名函数</h3><p>基本语法：lambda [arg1 [,arg2,…..argn]]:expression<br><strong>注意：lambda 函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum = lambda num1 , num2 : num1 + num2;</span><br><span class="line">print( sum( 1 , 2 ) )</span><br></pre></td></tr></table></figure><p>结果为：<code>3</code></p><h2 id="8-数据结构"><a href="#8-数据结构" class="headerlink" title="8.数据结构"></a>8.数据结构</h2><p>列表、字典、集合是可变对象，这意味着它们可以在创建后修改。另一方面，整数、浮点数、布尔值、字符串甚至元组都是不可变的对象。</p><h3 id="8-1-列表-List"><a href="#8-1-列表-List" class="headerlink" title="8.1.列表(List)"></a>8.1.列表(List)</h3><p><strong>创建列表</strong><br><code>alist=[&#39;name&#39;,&#39;sex&#39;,&#39;age&#39;]</code></p><ul><li>列表中的每个元素都是可变的；</li><li>列表中的元素是有序的，也就是说每个元素都有一个位置,因此列表中元素可以重复；</li><li>列表中可以容纳 Python 中的任何对象。</li></ul><p><strong>访问列表元素</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alist=[&#x27;name&#x27;,&#x27;sex&#x27;,&#x27;age&#x27;]</span><br><span class="line">print(alist[0])  #正索引访问</span><br><span class="line">print(alist[-1])  #负索引访问</span><br><span class="line">print(alist[-3])  #负索引访问</span><br><span class="line">print(alist[0:2])  #切片访问</span><br></pre></td></tr></table></figure><p>结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name</span><br><span class="line">age</span><br><span class="line">name</span><br><span class="line">[&#x27;name&#x27;, &#x27;sex&#x27;]</span><br></pre></td></tr></table></figure><p>由结果可知，切片后的结果仍为列表<br><strong>添加列表值</strong></p><ul><li>append()，在列表末尾添加一个元素</li><li>insert()，在指定的特定位置将元素添加到列表<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alist=[&#x27;name&#x27;,&#x27;sex&#x27;,&#x27;age&#x27;]</span><br><span class="line">alist.append(&quot;num&quot;)</span><br><span class="line">print(alist)</span><br><span class="line">alist.insert(2,&#x27;grade&#x27;)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>结果为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;name&#x27;, &#x27;sex&#x27;, &#x27;age&#x27;, &#x27;num&#x27;]</span><br><span class="line">[&#x27;name&#x27;, &#x27;sex&#x27;, &#x27;grade&#x27;, &#x27;age&#x27;, &#x27;num&#x27;]</span><br></pre></td></tr></table></figure></li></ul><p><strong>删除列表值</strong></p><ul><li>remove()，从列表中删除与给定值匹配的第一个匹配项</li><li>pop()，当我们要从列表中移除指定索引处的元素时使用。但是，如果我们不提供索引值，最后一个元素将从列表中删除<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alist=[&#x27;num&#x27;,&#x27;name&#x27;,&#x27;sex&#x27;,&#x27;age&#x27;,&#x27;grade&#x27;]</span><br><span class="line">alist.remove(&#x27;sex&#x27;)</span><br><span class="line">print(alist)</span><br><span class="line">alist.pop()</span><br><span class="line">print(alist)</span><br><span class="line">alist.pop(1)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>结果为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;num&#x27;, &#x27;name&#x27;, &#x27;age&#x27;, &#x27;grade&#x27;]</span><br><span class="line">[&#x27;num&#x27;, &#x27;name&#x27;, &#x27;age&#x27;]</span><br><span class="line">[&#x27;num&#x27;, &#x27;age&#x27;]</span><br></pre></td></tr></table></figure></li></ul><p><strong>排序列表</strong><br>使用<code>sort()</code>函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alist=[3,2,1,7,4]</span><br><span class="line">alist.sort()  #从小到大</span><br><span class="line">print(alist)</span><br><span class="line">alist.sort(reverse=True)  #从大到小</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 7]</span><br><span class="line">[7, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure><p>但是当对包含字符串元素的列表进行排序时，我们知道字符串值是使用字符串中字符的ASCII值排序的。字符串中的每个字符都有一个与其关联的整数值。我们使用这些值对字符串进行排序。<br>在比较两个字符串时，我们只是从一开始比较每个字符的整数值。如果在两个字符串中遇到相同的字符，我们只需比较下一个字符，直到找到两个不同的字符。当然，这是内部完成的，所以你不必担心！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alist=[&#x27;aa&#x27;,&#x27;ba&#x27;,&#x27;ab&#x27;]</span><br><span class="line">alist.sort()  #从小到大</span><br><span class="line">print(alist)</span><br><span class="line">alist.sort(reverse=True)  #从大到小</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;aa&#x27;, &#x27;ab&#x27;, &#x27;ba&#x27;]</span><br><span class="line">[&#x27;ba&#x27;, &#x27;ab&#x27;, &#x27;aa&#x27;]</span><br></pre></td></tr></table></figure><p><strong>合并列表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alist=[1,2,3]</span><br><span class="line">blist=[4,5]</span><br><span class="line">clist=alist+blist</span><br><span class="line">print(clist)</span><br></pre></td></tr></table></figure><p>结果为：<br><code>[1, 2, 3, 4, 5]</code><br><strong>列表解析</strong><br>主要方便对列表中的每一个元素进行操作，然后形成一个新的列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alist=[1,2,3]</span><br><span class="line">square=[x**2 for x in alist]   #将列表中每一个元素求平方，然后存入一个新的列表</span><br><span class="line">print(square)</span><br></pre></td></tr></table></figure><p>结果为：<br><code>[1, 4, 9]</code><br><strong>堆栈与队列</strong><br>可以使用列表来创建堆栈和队列</p><ul><li>栈是一个元素列表，其中元素的添加或删除是从列表的末尾开始的，先进后出。即使用<code>append()</code>和<code>pop()</code>函数来实现增加和删除操作</li><li>队列是一个元素列表，其中元素的添加发生在列表的末尾，而元素的删除则发生在列表的前面，先进先出。使用<code>append()</code>和<code>pop(0)</code>函数来实现增加和删除操作</li></ul><h3 id="8-2-元组-Tuple"><a href="#8-2-元组-Tuple" class="headerlink" title="8.2.元组(Tuple)"></a>8.2.元组(Tuple)</h3><p>元组与列表非常相似，只不过有一个区别，它们是不可变的。这意味着一旦生成元组，就不能添加、删除或编辑任何值。<br><strong>创建元组</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atuple=(1,2)</span><br><span class="line">print(atuple)</span><br></pre></td></tr></table></figure><p>需要主要的是：写了一堆没有任何括号的值并把它们赋给一个变量，最终还是会得到一个元组！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">btuple=3,4</span><br><span class="line">print(btuple)</span><br></pre></td></tr></table></figure><p>结果为：<br><code>(3, 4)</code><br><em>注意：虽然元组不可变，但可以更改元组中包含的不可变对象list的值。</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atuple=(1,2,[23,32])</span><br><span class="line">atuple[-1].append(99)</span><br><span class="line">print(atuple)</span><br></pre></td></tr></table></figure><p>结果为：<br><code>(1, 2, [23, 32, 99])</code><br><strong>元组赋值</strong><br>元组打包和解包是一些有用的操作，你可以执行这些操作来将值赋给单行中另一个元组。<br>当我们制造元组时，我们已经看到了元组的打包。元组解包与打包相反。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">atuple=(1,2,3)  #打包</span><br><span class="line">a,b,c=atuple  #解包</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>更改元组值</strong><br>元组实际上可以通过使用list（）将其转换为列表来对其进行更改。完成更改后，可以再次使用tuple（）将其转换回元组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">atuple=(1,2,3)</span><br><span class="line">blist=list(atuple)</span><br><span class="line">blist.pop()</span><br><span class="line">atuple=tuple(blist)</span><br><span class="line">print(atuple)</span><br></pre></td></tr></table></figure><p>结果为：<br><code>(1, 2)</code></p><h3 id="8-3-字典-Dict"><a href="#8-3-字典-Dict" class="headerlink" title="8.3.字典(Dict)"></a>8.3.字典(Dict)</h3><p>Dictionary是另一种Python数据结构，用于存储不可变但无序的异构对象。<br>这意味着当你试图访问这些元素时，它们的顺序可能与你插入它们的顺序不完全相同。<br>但是，使词典与列表区别开来的是元素在其中的存储方式。<br>字典中的元素是通过它们的键值而不是它们的索引来访问的，正如我们在列表中所做的那样。<br>所以字典包含键值对，而不仅仅是单个元素。<br><em>所以，字典对于快速访问项非常有用，因为与列表和元组不同，字典不必遍历所有找到值的项。字典使用哈希提高性能。</em><br><strong>创建字典</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adict=&#123;&#x27;1&#x27;:&#x27;num&#x27;,&#x27;2&#x27;:&#x27;name&#x27;,&#x27;3&#x27;:&#x27;sex&#x27;&#125;</span><br><span class="line">print(adict)</span><br><span class="line">print(adict[&#x27;1&#x27;])</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;1&#x27;: &#x27;num&#x27;, &#x27;2&#x27;: &#x27;name&#x27;, &#x27;3&#x27;: &#x27;sex&#x27;&#125;</span><br><span class="line">num</span><br></pre></td></tr></table></figure><p>注意:字典中有多个项具有相同的键，项的值为最后一个键关联的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adict=&#123;&#x27;1&#x27;:&#x27;num&#x27;,&#x27;2&#x27;:&#x27;name&#x27;,&#x27;3&#x27;:&#x27;sex&#x27;,&#x27;2&#x27;:&#x27;grade&#x27;&#125;</span><br><span class="line">print(adict[&#x27;2&#x27;])</span><br></pre></td></tr></table></figure><p>结果为：<br><code>grade</code><br><strong>访问键和值</strong></p><ul><li>可以使用 keys() 方法从字典访问键。</li><li>使用values()方法访问值。</li><li>可以使用list()将它们转换为列表。</li><li>可以使用items()方法同时访问这些值，该方法返回字典中每个元素的相应键值对。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adict=&#123;&#x27;1&#x27;:&#x27;num&#x27;,&#x27;2&#x27;:&#x27;name&#x27;,&#x27;3&#x27;:&#x27;sex&#x27;,&#x27;2&#x27;:&#x27;grade&#x27;&#125;</span><br><span class="line">print(adict.keys())  #取键</span><br><span class="line">print(adict.values())   #取值</span><br><span class="line">print(list(adict.values()))  #值转换为列表</span><br><span class="line">print(adict.items())  #访问键对</span><br></pre></td></tr></table></figure>结果为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict_keys([&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;])</span><br><span class="line">dict_values([&#x27;num&#x27;, &#x27;grade&#x27;, &#x27;sex&#x27;])</span><br><span class="line">[&#x27;num&#x27;, &#x27;grade&#x27;, &#x27;sex&#x27;]</span><br><span class="line">dict_items([(&#x27;1&#x27;, &#x27;num&#x27;), (&#x27;2&#x27;, &#x27;grade&#x27;), (&#x27;3&#x27;, &#x27;sex&#x27;)])</span><br></pre></td></tr></table></figure><h3 id="8-4-集合-Set"><a href="#8-4-集合-Set" class="headerlink" title="8.4.集合(Set)"></a>8.4.集合(Set)</h3>每一个集合中是的元素是无序的、不重复的任意对象(如果不希望在列表或元组中多次出现同一个元素。在这里，你可以使用集合数据结构。)<br>我们可以通过集合去判断数据的从属关系，有时还可以通过集合把数据结构中重复的元素减掉。<br>集合不能被切片也不能被索引，除了做集合运算之外，集合元素可以被添加还有删除：</li></ul><p><strong>集合的增删操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a_set = &#123;1,2,3,4&#125;</span><br><span class="line">print(a_set)</span><br><span class="line">a_set.add(5)  #add()方法允许添加除可变对象（例如list）以外的任何值</span><br><span class="line">print(a_set)</span><br><span class="line">a_set.discard(7)  #discard() 方法，它删除元素，但当元素不在集合中时不会出错</span><br><span class="line">print(a_set)</span><br><span class="line">a_set.remove(5)   #remove()方法，如果元素不在集合中，它会报错</span><br><span class="line">print(a_set)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;1, 2, 3, 4&#125;</span><br><span class="line">&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure><p><strong>集合操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a_set = &#123;1,2,3,4&#125;</span><br><span class="line">b_set=&#123;3,9&#125;</span><br><span class="line">print(a_set.union(b_set))   #并集</span><br><span class="line">print(a_set.intersection(b_set))   #交集</span><br><span class="line">print(a_set.difference(b_set))    #差集</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;1, 2, 3, 4, 9&#125;</span><br><span class="line">&#123;3&#125;</span><br><span class="line">&#123;1, 2, 4&#125;</span><br></pre></td></tr></table></figure><h2 id="9-面向对象"><a href="#9-面向对象" class="headerlink" title="9.面向对象"></a>9.面向对象</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>创建类和对象(创建对象就可以理解为将内容封装到对象中)</strong></p><p><em>ps：类中的函数第一个参数必须是self,self 是一个形式参数，当执行 obj1 = Foo(‘wupeiqi’, 18 ) 时，self 等于 obj1,当执行 obj2 = Foo(‘alex’, 78 ) 时，self 等于 obj2</em></p><p>1.通过对象直接调用被封装的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">obj1 = Foo(&#x27;wupeiqi&#x27;, 18)</span><br><span class="line">print(obj1.name)  # 直接调用obj1对象的name属性</span><br><span class="line">print(obj1.age)  # 直接调用obj1对象的age属性</span><br><span class="line"></span><br><span class="line">obj2 = Foo(&#x27;alex&#x27;, 73)</span><br><span class="line">print(obj2.name)  # 直接调用obj2对象的name属性</span><br><span class="line">print(obj2.age)  # 直接调用obj2对象的age属性</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wupeiqi</span><br><span class="line">18</span><br><span class="line">alex</span><br><span class="line">73</span><br></pre></td></tr></table></figure><p>2.通过self间接调用被封装的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    def detail(self):</span><br><span class="line">        print(self.name)</span><br><span class="line">        print(self.age)</span><br><span class="line"></span><br><span class="line">obj1 = Foo(&#x27;wupeiqi&#x27;, 18)</span><br><span class="line">obj1.detail()  # Python默认会将obj1传给self参数，即：obj1.detail(obj1)，所以，此时方法内部的 self ＝ obj1，即：self.name 是 wupeiqi ；self.age 是 18</span><br><span class="line"></span><br><span class="line">obj2 = Foo(&#x27;alex&#x27;, 73)</span><br><span class="line">obj2.detail()  # Python默认会将obj2传给self参数，即：obj1.detail(obj2)，所以，此时方法内部的 self ＝ obj2，即：self.name 是 alex ； self.age 是 78</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wupeiqi</span><br><span class="line">18</span><br><span class="line">alex</span><br><span class="line">73</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Animal:</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;%s 吃 &quot; % self.name)</span><br><span class="line">    def drink(self):</span><br><span class="line">        print(&quot;%s 喝 &quot; % self.name)</span><br><span class="line">    def shit(self):</span><br><span class="line">        print(&quot;%s 拉 &quot; % self.name)</span><br><span class="line">    def pee(self):</span><br><span class="line">        print(&quot;%s 撒 &quot; % self.name)</span><br><span class="line">class Cat(Animal):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.breed=&#x27;猫&#x27;</span><br><span class="line">    def cry(self):</span><br><span class="line">        print(&#x27;喵喵~&#x27;)</span><br><span class="line">class Dog(Animal):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.breed = &#x27;狗&#x27;</span><br><span class="line">    def cry(self):</span><br><span class="line">        print(&#x27;汪汪~&#x27;)</span><br><span class="line">c1 = Cat(&#x27;小黑猫&#x27;)</span><br><span class="line">c1.eat()</span><br><span class="line">c2 = Cat(&#x27;小白猫&#x27;)</span><br><span class="line">c2.drink()</span><br><span class="line">d1 = Dog(&#x27;小瘦狗&#x27;)</span><br><span class="line">d1.eat()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果为·：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小黑猫 吃 </span><br><span class="line">小白猫 喝 </span><br><span class="line">小瘦狗 吃 </span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h2 id="10-文件读取"><a href="#10-文件读取" class="headerlink" title="10.文件读取"></a>10.文件读取</h2><p><strong>写文件</strong></p><p>注意：如果你打开的文件不存在，那么open()函数会自动帮你创建一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file2 = open(&#x27;e:\\杂\\pass.txt&#x27;,&#x27;w&#x27;,encoding=&#x27;UTF-8&#x27;)</span><br><span class="line">file2.write(&quot;小白\n&quot;)</span><br><span class="line">file2.close()</span><br></pre></td></tr></table></figure><p>注意：使用with…as file,不用再主动close()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;e:\\杂\\pass.txt&#x27;,&#x27;a&#x27;) as file1:</span><br><span class="line">    file1.write(&quot;-------------&quot;)</span><br></pre></td></tr></table></figure><p><strong>读文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file1 = open(&#x27;e:\\杂\\pass.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;UTF-8&#x27;)</span><br><span class="line">filecontent = file1.read()  </span><br><span class="line">print(filecontent)</span><br><span class="line">file1.close()</span><br></pre></td></tr></table></figure><p>tell() 函数用于判断文件指针当前所处的位置</p><p> seek() 函数用于移动文件指针到文件的指定位置。</p><p>==文件打开模式描述==</p><ul><li><p>r：以只读模式打开文件，并将文件指针指向文件头；如果文件不存在会报错</p></li><li><p>w：以只写模式打开文件，并将文件指针指向文件头；如果文件存在则将其内容清空，如果文件不存在则创建</p></li><li><p>a：以只追加可写模式打开文件，并将文件指针指向文件尾部；如果文件不存在则创建</p></li><li><p>r+：在r的基础上增加了可写功能</p></li><li><p>w+：在w的基础上增加了可读功能</p></li><li><p>a+：在a的基础上增加了可读功能</p></li><li><p>b：读写二进制文件（默认是t，表示文本），需要与上面几种模式搭配使用，如ab，wb, ab, ab+（POSIX系统，包括Linux都会忽略该字符）</p></li></ul><h2 id="11-模块的使用"><a href="#11-模块的使用" class="headerlink" title="11.模块的使用"></a>11.模块的使用</h2><p>Python 很多功能需要模块来进行，模块分为系统内置、需要安装或者自己制作的。<br><strong>系统内置模块</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import random  #载入模块</span><br><span class="line">from sys import exit  #从sys载入模块exit</span><br></pre></td></tr></table></figure><p><strong>第三方模块（需要安装）</strong><br>首先需要通过 pip 安装</p><ol><li>win+R打开 cmd</li><li>以安装 pillow 模块作为例子</li><li>输入 pip install pillow , 按 enter</li><li>等待安装完成</li></ol><p><strong>自己制作的模块</strong><br>import 自己的文件.py<br>注意：自己制作的模块需要放在同一文件夹</p><h2 id="12-函数记录"><a href="#12-函数记录" class="headerlink" title="12.函数记录"></a>12.函数记录</h2><p>id()方法:检查对象的内存位置<br>type():返回数据类型</p><p>参考链接: <a href="https://panchuangai.blog.csdn.net/article/details/106805950">https://panchuangai.blog.csdn.net/article/details/106805950</a><br>          <a href="https://blog.csdn.net/alex27933/article/details/107519511?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162691072616780261986682%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162691072616780261986682&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-107519511.pc_search_result_before_js&amp;utm_term=python%E5%85%A5%E9%97%A8&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/alex27933/article/details/107519511?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162691072616780261986682%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162691072616780261986682&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-107519511.pc_search_result_before_js&amp;utm_term=python%E5%85%A5%E9%97%A8&amp;spm=1018.2226.3001.4187</a></p><p><a href="https://www.runoob.com/python/python-func-open.html">Python open() 函数 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://blog.csdn.net/weixin_34261739/article/details/85750146?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">(1条消息) Python 面向对象（初级篇）_weixin_34261739的博客-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;此博客为个人笔记，记录了个人认为常用的知识点&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/07/19/hello-world/"/>
    <id>http://example.com/2021/07/19/hello-world/</id>
    <published>2021-07-19T09:01:15.851Z</published>
    <updated>2021-07-19T09:01:15.851Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
