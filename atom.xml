<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-01-15T14:18:17.076Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件测试学习（四）——Fiddler应用分析具体的网络请求，得出BUG归属</title>
    <link href="http://example.com/2023/01/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94Fiddler%E5%BA%94%E7%94%A8/"/>
    <id>http://example.com/2023/01/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94Fiddler%E5%BA%94%E7%94%A8/</id>
    <published>2023-01-15T14:09:40.782Z</published>
    <updated>2023-01-15T14:18:17.076Z</updated>
    
    <content type="html"><![CDATA[<p>可用于分析具体的网络请求，得出BUG归属<br>1．客户端和服务器交互–接口协议，接口文档【规定发送请求的内容，响应数据内容】2，接口请求的地址、参数、方法是否正确?【请求不正确，客户端问题】<br>3．服务器端返回的数据没有按照接口文档来?【服务端问题】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可用于分析具体的网络请求，得出BUG归属&lt;br&gt;1．客户端和服务器交互–接口协议，接口文档【规定发送请求的内容，响应数据内容】2，接口请求的地址、参数、方法是否正确?【请求不正确，客户端问题】&lt;br&gt;3．服务器端返回的数据没有按照接口文档来?【服务端问题】&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件测试学习（三）——接口测试</title>
    <link href="http://example.com/2023/01/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    <id>http://example.com/2023/01/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</id>
    <published>2023-01-15T12:35:54.975Z</published>
    <updated>2023-01-15T13:52:13.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口：服务提供方开放的入口和桥梁</p><p>网络接口–调用/连接的方式为网络</p><p>Http接口 –基于tcp/ip网络，采取Ht tp作为具体的应用层协议，传输特定格式的数据。</p><h1 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h1><p>接口测试主要用于检测外部系统与系统之间，以及内部各个子系统之间的交互点。接口测试的重点包括交互的数据、过程以及背后的业务逻辑。</p><h1 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h1><p>1．拿到接口的url地址</p><p>2．查看接口是用什么方法发送(get/post/put…)</p><p>3．添加请求头，请求参数</p><p>4．发送查看返回结果，校验返回结果是否正确</p><h1 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h1><h2 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h2><p>可以用于Rest 接口测试的测试工具非常多，常见的有 soapUI、Jmeter、fiddler等都经常用来做接口测试。<br>但是目前在接口测试人员中最流行，最常见是Postman。</p><p><strong>变量</strong></p><p>Postman提供了丰富的变量支持，在Postman 中定义了5种不同作用范围的变量类型。</p><p>使用：</p><ol><li>Global变量即全局变量，是作用范围最大的一种变量类型,<br>可以在Postman工具中所有可以使用变量的地方生效。</li><li>Collection变量就是作用域在Collection 上的变量类型.<br>这种变量只会在设置变量的Collection 上生效。</li><li>Environment变量，区分不同的环境</li><li>data变量只能在Postman Runner 中使用。<br>也就是会在Runner运行时才生效</li><li>Local变量在Postman官方文档中并没有给出明确的定义。<br>一般可以理解成Postman脚本中支持的JS变量，它的作用域只会在脚本中生效。</li></ol><p><strong>数据校验</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerlink&quot; title=&quot;接口&quot;&gt;&lt;/a&gt;接口&lt;/h1&gt;&lt;p&gt;接口：服务提供方开放的入口和桥梁&lt;/p&gt;
&lt;p&gt;网络接口–调用/连接的方式为网络&lt;/p&gt;
&lt;p&gt;Http接口 –基于tcp/ip网络，采取H</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件测试学习（二）——自动化测试</title>
    <link href="http://example.com/2023/01/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>http://example.com/2023/01/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</id>
    <published>2023-01-15T09:52:18.509Z</published>
    <updated>2023-01-15T09:52:18.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自动化测试是什么"><a href="#自动化测试是什么" class="headerlink" title="自动化测试是什么"></a>自动化测试是什么</h1><h1 id="自动化测试流程"><a href="#自动化测试流程" class="headerlink" title="自动化测试流程"></a>自动化测试流程</h1><p>和手工测试差不多，但自动化主要集中在用例执行方面，有的测试报告也可以自动生成</p><h1 id="编写自动化脚本"><a href="#编写自动化脚本" class="headerlink" title="编写自动化脚本"></a>编写自动化脚本</h1><h2 id="借助于软件"><a href="#借助于软件" class="headerlink" title="借助于软件"></a>借助于软件</h2><h3 id="3-web-UI自动化测试工具——Selenium-IDE"><a href="#3-web-UI自动化测试工具——Selenium-IDE" class="headerlink" title="3.web UI自动化测试工具——Selenium IDE"></a>3.web UI自动化测试工具——Selenium IDE</h3><p>火狐谷歌插件，通过模拟人工操作来实现自动化</p><p>1.Cteate  a new projiect</p><p>2.输入url ,录制一遍自己的操作</p><p>3.根据需求自己写代码</p><p>4.添加测试用例</p><p>5.执行所以测试用例</p><h2 id="根据需求自己编写代码"><a href="#根据需求自己编写代码" class="headerlink" title="根据需求自己编写代码"></a>根据需求自己编写代码</h2><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>即让程序去判断一个系统功能是否正常</p><h1 id="报告"><a href="#报告" class="headerlink" title="报告"></a>报告</h1><h2 id="selenium-side-runner"><a href="#selenium-side-runner" class="headerlink" title="selenium-side-runner"></a>selenium-side-runner</h2><p><strong>需提前安装nodejs再安装selenium-side-runner</strong></p><p><strong>用法：</strong></p><ul><li><p>1.Selenium IDE保存结果文件</p></li><li><p> 2.selenium-side-runner + Selenium IDE输出结果文件  –output-format jest –output-directory aaatony</p></li></ul><p>e.g.selenium-side-runner test.side  –output-format jest –output-directory aaatony</p><ul><li><p> 3.自动生成测试报告 文本形式，生成文件在aaatony里面</p></li><li><p>4.文本形式转换为html+图表形式</p></li></ul><p>j2h -f 文件</p><p>e.g j2h -f test.json</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自动化测试是什么&quot;&gt;&lt;a href=&quot;#自动化测试是什么&quot; class=&quot;headerlink&quot; title=&quot;自动化测试是什么&quot;&gt;&lt;/a&gt;自动化测试是什么&lt;/h1&gt;&lt;h1 id=&quot;自动化测试流程&quot;&gt;&lt;a href=&quot;#自动化测试流程&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>shell脚本语言学习</title>
    <link href="http://example.com/2022/12/31/shell%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/12/31/shell%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-12-31T12:49:15.506Z</published>
    <updated>2023-02-06T11:51:20.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell脚本语言学习"><a href="#Shell脚本语言学习" class="headerlink" title="Shell脚本语言学习"></a>Shell脚本语言学习</h1><h2 id="Shell是什么"><a href="#Shell是什么" class="headerlink" title="Shell是什么"></a>Shell是什么</h2><p> Shell是一个命令行解释器，它接收应用程序/用户命令，然后调用操作系统内核。 Shell还是一个功能相当强大的编程语言，易编写、易调试、灵活性强。  </p><p><strong><img src="/%5Cimages%5C1672485339590.png" alt="1672485339590"></strong></p><h2 id="Shell脚本语言"><a href="#Shell脚本语言" class="headerlink" title="Shell脚本语言"></a>Shell脚本语言</h2><ol><li> <strong>创建脚本</strong> ：.sh后缀的文件，例如helloworld.sh</li><li><strong>脚本格式</strong></li></ol><p>脚本以 <code>#!/bin/bash</code> 开头（指定解析器），然后就可以写入shell命令</p><ol start="2"><li><strong>脚本执行方式：</strong> </li></ol><p> <strong>方式1⃣️.</strong> 采用bash或sh+脚本的相对路径/绝对路径（不用赋予脚本+x权限） </p><p> <strong>方式2⃣️.</strong> 采用输入脚本的绝对路径/相对路径执行脚本（<code>必须具有可执行权限+x</code>） </p><p> a. 首先赋予helloworld.sh 脚本的+x权限</p><p> b. 执行脚本</p><p> 方式1⃣️ ，本质是解析器帮助执行脚本，所以脚本本身不需哟啊执行权限；方式2⃣️ ，本质是脚本需要自己执行，所以需要➕x权限。 </p><h3 id="shell中的变量"><a href="#shell中的变量" class="headerlink" title="shell中的变量"></a>shell中的变量</h3><ol><li><strong>常用系统变量</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME、$PWD、$SHELL、$USER等；</span><br></pre></td></tr></table></figure><p>  <strong>2.自定义变量</strong></p><p> 1). 定义变量：变量=值 ，a=1</p><p> 2). 撤销变量：unset 变量 ,unset a</p><p>只读 不可以使用unset </p><p> 3). 声明静态变量：readonly 变量，   readonly b=2 </p><p>规则</p><p>1). 变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名最好大写！</p><p>2). 等号两侧不能有空格；</p><p>3). 在bash中，变量默认类型都是字符串类型，无法直接进行数值运算；</p><p> 4). 变量的值如果有空格，需要使用双引号 “ “ / ’ ’ 括起来。 </p><p> <strong>tips:</strong><br>使用“ export 变量名 ” 可以将变量提升为全局环境变量，供其他Shell程序使用。 </p><p><strong>3.特殊变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$n （功能描述：n为数字，$0代表该脚本名称，$1-$9代表第一到第九个参数，🔟以上的参数需要用大括号 &#123; &#125;包含，如$&#123;10&#125;）</span><br><span class="line">$# (功能描述：获取所有输入参数个数，常用于循环)。</span><br><span class="line">$* (功能描述：此变量代表命令行中所有的参数，$* 把所有的参数看成一个整体)；</span><br><span class="line">$@ (功能描述：此变量也代表命令行中所有参数，不过$@把每个参数区分对待)。</span><br><span class="line">$?(功能描述：最后一次执行的命令的返回状态。如果此变量值为0，证明上一个命令正确执行；如果此变量值为非0，则证明上一个命令执行错误)。</span><br></pre></td></tr></table></figure><h3 id="运算法"><a href="#运算法" class="headerlink" title="运算法"></a>运算法</h3><ol><li>基本语法</li></ol><p>1). <code>&quot; $((运算式))&quot; / &quot;$[运算式]&quot;</code>,e.g  s=$[(10+5)*4] </p><p>2). <code>expr + - \* / %</code> 加减乘除取余，e.g  expr 10 + 5 </p><p><strong>tips:</strong><br>expr运算符间需➕空格</p><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>[ condition ] (tips：condition前后有空格)</p><p>注：条件非空即为true，[ balabala ] 返回true， []返回false。</p><p>注意： 多条件判断（&amp;&amp; 表示上一条命令执行成功时，才执行后一条命令， || 表示上一条命令执行失败后，才执行下一条命令） </p><p>1). 两个整数之间比较</p><p>= 字符串比较<br>-lt 小于 (less than)<br>-le 小于等于(less equal)<br>-eq 等于(equal)<br>-gt 大于(greater than)<br>-ge 大于等于(greater equal)<br>-ne 不等于(not equal)</p><p>2). 按照文件权限进行判断</p><p>-r有读的权限(read)<br>-w 有写的权限(write)<br>-x 有执行的权限(execute)</p><p>3).按照文件类型进行判断<br>-f 文件存在且是一个常规的文件(file)<br>-e 文件存在(existence)<br>-d 文件存在且是一个目录(directory)</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p><strong>1.if</strong></p><p> if [ 条件判断式 ] </p><p>then <em>#        程序</em> </p><p>fi </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ $1 -eq 1 ]</span><br><span class="line">then</span><br><span class="line">        echo &quot;the number is one&quot;</span><br><span class="line">elif [ $1 -eq 2 ]</span><br><span class="line">then</span><br><span class="line">        echo &quot;the number is two&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>2.case</strong></p><p> case $变量名 in </p><p>“值1”) </p><p>​    <em>#    如果变量的值等于值1，则执行程序1</em></p><p> ;;</p><p> “值2”) </p><p><em>#    如果变量的值等于值1，则执行程序1</em> </p><p>;; </p><p> *) </p><p><em>#    若变量的值与以上都不符，则执行此default程序</em></p><p> ;; </p><p>esac </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case $1 in</span><br><span class="line">1)</span><br><span class="line">        echo &quot; the number is one&quot;</span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">2)</span><br><span class="line">        echo &quot; the number is two&quot;</span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">*)</span><br><span class="line">        echo &quot;the other number except the two choice&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3.for</strong></p><ol start="3"><li><p>1</p><p>for(( 初始值; 循环控制条件；变量变化 )) </p></li></ol><p>​       do </p><p>​            程序 </p><p>​       done </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(( i=1;i&lt;=100;i++ ))</span><br><span class="line">do</span><br><span class="line">        s=$[$s+$i]</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>3.2</p><p> for 变量  in 值1 值2 值3… </p><p>​      do  </p><p>​          程序 </p><p>​     done </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in $*</span><br><span class="line">do</span><br><span class="line">        echo &quot;the parameter you entered is $i&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>4.while</strong></p><p> while [ 条件判断式 ] </p><p>​         do </p><p>​              <em>#    程序</em> </p><p>​        done </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while [ $i -le 100 ]</span><br><span class="line">do</span><br><span class="line">        s=$[$s + $i]</span><br><span class="line">        i=$[$i + 1]</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a>read读取控制台输入</h3><p>read(选项)(参数)</p><p>选项：<br>-p：指定读取值时的提示符；<br>-t：指定读取值时等待的时间（秒）。</p><p>参数：<br>变量：指定读取值的变量名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read -t 7 -p &quot;please input your name&quot; NAME</span><br><span class="line"></span><br><span class="line">echo $NAME</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol><li><strong>basename</strong>  </li></ol><p>basename [string / pathname] [suffix]</p><p>功能描述：若加了后缀suffix，则basename命令会删掉所有的后缀包括最后一个( ’ / ‘) 字符，然后显示出字符串。</p><p>选项：<br>suffix为后缀，为可选项，如果suffix被指定了，basename会将pathname或string中的suffix去掉。</p><p><strong>2.dirname</strong> </p><p>dirname 文件绝对路径；</p><p>功能描述：从给定的包含绝对路径的文件名中去除文件名(非目录)，然后返回目录。</p><p><strong>3.自定义函数</strong></p><p>[ function ] funname[()]<br>{<br>    Action;<br>    [return int;]<br>}<br>funname</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum()</span><br><span class="line">&#123;</span><br><span class="line">        s=0;</span><br><span class="line">        s=$[$1+$2]</span><br><span class="line">        echo $s</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Shell-工具"><a href="#Shell-工具" class="headerlink" title="Shell 工具"></a>Shell 工具</h3><p><strong>1.cut</strong></p><p> 负责剪切数据；cut命令从文件的每一行剪切字节、字符和字段并输出。 </p><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-f</td><td><code>列号，</code>按列号提取</td></tr><tr><td>-d</td><td><code>分隔符</code>，按照指定分隔符分割列</td></tr></tbody></table><p><strong>2.sed</strong></p><p> sed是一种流编辑器，一次处理一行内容。处理时把当前处理的行存储在临时缓冲区中，称为“模式空间”，接着用sed命令处理缓冲区中的内容并将其输出屏幕。不断重复直至文件末尾。 </p><ol><li>基本语法</li></ol><p>sed [选项参数] ‘command’ filename</p><ol><li>选项参数说明</li></ol><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-e</td><td>直接在指令列模式上进行sed的动作编辑</td></tr></tbody></table><ol><li>常用命令功能描述</li></ol><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>a</td><td>新增，a后面可接字符串，在下一行出现</td></tr><tr><td>d</td><td>删除</td></tr><tr><td>s</td><td>查找并替换</td></tr></tbody></table><p><strong>3.awk</strong></p><p>awk是一个强大的文本分析工具，将文件逐行读入，以空格为默认分隔符将行切片，对切开的部分再进行分析处理。</p><p>基本语法<br>awk [] ‘pattern1{action1} pattern2{action2} … ’ filename<br>pattern: 表示awk在数据中查找的内容，就是匹配模式；<br>action: 在找到匹配内容时所执行的一系列命令</p><p>常用选项参数说明</p><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-F</td><td>指定输入文件分隔符</td></tr><tr><td>-v</td><td>赋值一个用户定义变量</td></tr></tbody></table><p>awk 的内置变量</p><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>FILENAME</td><td>文件名</td></tr><tr><td>NR</td><td>已读的记录数</td></tr><tr><td>NF</td><td>浏览记录的域的个数（<code>切割后列的个数</code>）</td></tr></tbody></table><p><strong>4.sort</strong></p><p>sort命令在Linux中非常有用，它将文件进行排序，并将排序结果标准输出。</p><ol><li>基本语法</li></ol><p>sort(选项)(参数)</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>按照数值的大小排序</td></tr><tr><td>-r</td><td>以相反的顺序来排序</td></tr><tr><td>-t</td><td>设置排序时所用的分割字符</td></tr><tr><td>-k</td><td>指定需要排序的列</td></tr></tbody></table><p>参数：指定待排序的文件列表。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shell脚本语言学习&quot;&gt;&lt;a href=&quot;#Shell脚本语言学习&quot; class=&quot;headerlink&quot; title=&quot;Shell脚本语言学习&quot;&gt;&lt;/a&gt;Shell脚本语言学习&lt;/h1&gt;&lt;h2 id=&quot;Shell是什么&quot;&gt;&lt;a href=&quot;#Shell是什么&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>接口测试</title>
    <link href="http://example.com/2022/12/30/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    <id>http://example.com/2022/12/30/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</id>
    <published>2022-12-30T13:38:45.932Z</published>
    <updated>2023-02-06T11:59:55.397Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>等保学习</title>
    <link href="http://example.com/2022/12/30/%E7%AD%89%E4%BF%9D%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/12/30/%E7%AD%89%E4%BF%9D%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-12-30T11:11:51.684Z</published>
    <updated>2023-02-09T19:01:49.153Z</updated>
    
    <content type="html"><![CDATA[<p>GB/T22239-2019 信息安全技术 网络安全等级保护基本要求</p><h2 id="等保定义"><a href="#等保定义" class="headerlink" title="等保定义"></a>等保定义</h2><p>根据信息、信息系统在国家安全、经济建设、社会生活中的重要程度;<br>遭受破坏后对国家安全、社会秩序、公共利益以及公民、法人和其他组织的合法权益的危害程度;<br>将信息系统划分为不同的安全保护等级并对其实施不同的保护和监管。</p><h2 id="等级划分"><a href="#等级划分" class="headerlink" title="等级划分"></a>等级划分</h2><p>1.第一级为自主保护级，适用于一般的信息和信息系统，其受到破坏后，会对公民、法人和其他组织的权益有一定影响，但不危害国家安全、社会秩序、经济建设和公共利益。<br>⒉第二级为指导保护级，适用于一定程度上涉及国家安全、社会秩序、经济建设和公共利益的一般信息和信息系统，其受到破坏后，会对国家安全、社会秩序、经济建设和公共利益造成一定损害。<br>3.第三级为监督保护级，适用于涉及国家安全、社会秩序、经济建设和公共利益的信息和信息系统，其受到破坏后，会对国家安全、社会秩序、经济建设和公共利益造成较大损害。<br>4.第四级为强制保护级，适用于涉及国家安全、社会秩序、经济建设和公共利益的重要信息和信息系统,其受到破坏后，会对国家安全、社会秩序、经济建设和公共利益造成严重损害。<br>5.第五级为专控保护级，适用于涉及国家安全、社会秩序、经济建设和公共利益的重要信息和信息系统的核心子系统，其受到破坏后，会对国家安全、社会秩序、经济建设和公共利益造成特别严重损害。</p><p>【等保一级】<br>　　 　　等保一级为“用户自主保护级”，是等保中最低的级别，该级别无需测评，提交相关申请资料，公安部门审核通过即可。</p><p>【等保二级】<br>　　 　　等保二级为“系统审计保护级”，是目前使用最多的等保方案，所有“信息系统受到破坏后，会对公民、法人和其他组织的合法权益产生严重损害，或者对社会秩序和公共利益造成损害，但不损害国家安全。”范围内网站均可适用，可支持到地级市各机关、事业单位及各类企业的系统应用，比如：网上各类服务的平台（尤其是涉及到个人信息认证的平台），市级地方机关、政府网站等等。</p><p>【等保三级】<br>　　 　　等保三级等为“安全标记保护级”，级别更高，支持“信息系统受到破坏后，会对社会秩序和公共利益造成严重损害，或者对国家安全造成损害。”范围，适用于“地级市以上的国家机关、企业、事业单位的内部重要信息系统”，比如省级政府官网、银行官网等等。三级等保也是我们能制作的最高级别等保网站。</p><p>【等保四级】<br>　　 　　等保四级等保适用于国家重要领域、涉及国家安全、国计民生的核心系统，比如中国人民银行就是目前唯一四级等保的中国央行门户集群。</p><p>【等保五级】<br>　　 　　等保五级等保是目前我国最高级别，一般应用于国家的机密部门</p><h2 id="等保1-0与等保2-0区别"><a href="#等保1-0与等保2-0区别" class="headerlink" title="等保1.0与等保2.0区别"></a>等保1.0与等保2.0区别</h2><p>等保2.0提出新的技术要求和管理要求，强调“一个中心，三重防护”，关键点包括可信技术、安全管理中心，以及云计算、物联网等新兴领域的安全扩展要求。对应地，企业在安全防护体系建设、风险评估和管理上需要更加全面，并需关注所在行业的安全要求和定级标准。</p><p>1.安全要求，增加了扩展要求</p><p>原来:安全要求<br>改为:安全通用要求和安全扩展要求<br>安全通用要求是不管等级保护对象形态如何必须满足的要求，针对于计算、移动互联、物联网和工业控制系统提出了特殊要求，称为安全扩展要求。</p><p>2.备案的变化</p><p>等保1.0《信息安全等级保护管理办法》(公通字[2007]43号) 第十五条已运营(运行)的第级以上信息系;<br>统，应当在安全保护等级确定后30日内，由其运营、使用单位到所在地设区的市级以上公安机关办理备案手续。<br>等保2.0《网络安全等级保护条例(征求意见稿)》第十八条[定级备案]第二级以上网络运营者应当在网络的安全保护等级确定后10个工作日内，到县级以上公安机关备案。</p><p>3.等保测评的变化</p><p>《信息安全等级保护管理办法》(等保1.0)<br>第三级:每年一次<br>第四级:每半年一次<br>第五级:依据特殊安全需求</p><p>《网络安全等级保护条例(征求意见稿)》(等保2.0)<br>第三级以上网络的运营者<br>每年开展一次</p><p>4.等保测评结论的变化</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/202302100256826.png" alt="1672399950819"></p><p>5.定级流程的变化</p><p>**<img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/202302100258132.png" alt="1672400108377"></p><h2 id="工作的5个环节"><a href="#工作的5个环节" class="headerlink" title="工作的5个环节"></a>工作的5个环节</h2><p>等保包括五个阶段：1、定级、2、备案、3、建设整改、4、等级测评、5、监督检查。定级对象（即需要过等保的对象）建设整改后，需要选择符合国家要求的测评机构，按《网络安全等级保护基本要求》等技术标准进行等级测评，之后向监管单位提交测评报告。</p><p>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GB/T22239-2019 信息安全技术 网络安全等级保护基本要求&lt;/p&gt;
&lt;h2 id=&quot;等保定义&quot;&gt;&lt;a href=&quot;#等保定义&quot; class=&quot;headerlink&quot; title=&quot;等保定义&quot;&gt;&lt;/a&gt;等保定义&lt;/h2&gt;&lt;p&gt;根据信息、信息系统在国家安全、经济建设、</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网络嗅探器的实现</title>
    <link href="http://example.com/2022/12/29/%E7%BD%91%E7%BB%9C%E5%97%85%E6%8E%A2%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/12/29/%E7%BD%91%E7%BB%9C%E5%97%85%E6%8E%A2%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-12-29T06:29:40.136Z</published>
    <updated>2023-02-09T20:16:41.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络嗅探器的实现"><a href="#网络嗅探器的实现" class="headerlink" title="网络嗅探器的实现"></a>网络嗅探器的实现</h1><p>网络监控软件能够检测网络流量，发现网络中异常的数据流，有效地发现和防御网络攻击，是保证网络安全的重要工具和手段之一，也是网络安全技术人员必须掌握的重要技能之一。</p><h2 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h2><p>希望能实现对常用的数据报类型的捕获，例如：ICMP,OSPF,HTTP,HTTPS,SMTP,FTP,TCP,UDP，</p><p>能够显示各个数据包的数据包序号 ，数据包大小，源IP地址，源端口，目地ip地址，目的端口 ，</p><p> IP头部大小，TCP头部大小，数据长度，数据包内容（解码后的内容）。并且能够实现选择具体协议类型的数据包进行抓包，以一个对用户友好的界面将抓取后的数据包信息及内容解码后展示出来。</p><h2 id="功能图"><a href="#功能图" class="headerlink" title="功能图"></a>功能图</h2><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps62.png" alt="wps62"></p><h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>由于我们捕获的东西必须是要物理信号能收到的报文信息。显然只要通知网卡接收其收到的所有包，即网卡采用杂收模式（指网络上的所有设备都对总线上传送的数据进行侦听，并不仅仅是它们自己的数据）。在HUB下就能接收到这个网段的所有包，但是交换机下就只能是自己的包加上广播包。</p><p>要想在交换机下接收别人的包，那就要让其发往自己的机器所在口。交换机记住一个口的MAC是通过接收来自这个口的数据后并记住其源MAC，就像一个机器的IP与MAC对应的ARP列表，交换机维护一个物理口与MAC的表，所以可以欺骗交换机的。可以发一个包设置源MAC是自己想接收的机器的MAC，那么交换机就把机器的网线插的物理口与那个MAC对应起来了，以后发给那个MAC的包就发往自己的网线插口了，也就是我们的网卡可以Sniffer到了。注意这物理口与MAC的表与机器的ARP表一样是动态刷新的，那机器发包后交换HUB就又记住他的口了，所以实际上是两个在争，这只能应用在只要收听少量包就可以的场合。</p><p>内部网基于IP的通信可以用ARP欺骗别人机器让其发送给自己的机器，如果要想不影响原来两方的通信，可以欺骗两方，让其都发给自己的机器再由自己的机器转发，相当于做中间人，这用ARP加上编程很容易实现。并且现在很多设备支持远程管理，有很多交换机可以设置一个口监听别的口，不过这就要管理权限了。</p><p>利用这一点，可以将一台计算机的网络连接设置为接受所有以太网总线上的数据，从而实现Sniffer。</p><p>因为我们主要是希望能分析网络层，传输层，应用层的报文，因此需要对各层协议有一定理解。</p><table><thead><tr><th>层</th><th>主要协议</th><th>主要功能</th></tr></thead><tbody><tr><td>应用层</td><td>Http、Telnet、FTP、E-mail等</td><td>负责把数据传输到传输层或者接收从传输层返回的数据;</td></tr><tr><td>传输层</td><td>TCP、UDP</td><td>TCP为两台主机上的应用程序提供高可靠的端到端的数据通信，包括把应用程序交给它的数据分成数据块交给网络层、确认接收到的分组等;UDP则为应用层提供不可靠的数据通信，它只是把数据包的分组从一台主机发送到另一台主机，不保证数据能到达另一端;</td></tr><tr><td>网络层</td><td>ICMP、IP、IGMP</td><td>主要为数据包选择路由，其中IP是TCP/IP协议族中最为核心的协议，所有的TCP、UDP、ICMP、IGMP数据都以IP数据包格式传输;</td></tr></tbody></table><p>各层数据包由如下格式进行封装，捕获数据包后将头部信息进行解析，就可以获取源IP，目的IP，端口号，数据包大小等基本信息，进而可以分析数据包的来源及目的地；分析应用层数据就可以查看其想要传输的具体内容。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps63-1672295099181.jpg" alt="wps63-1672295099181"></p><h3 id="设计主要模块"><a href="#设计主要模块" class="headerlink" title="设计主要模块"></a>设计主要模块</h3><p>1） 包捕获机制</p><p>不同的操作系统实现的底层包捕获机制可能是不一样的，但从形式上看大同小异。数据包常规的传输路径依次为网卡、设备驱动层、数据链路层、IP层、传输层、最后到达应用程序。而包捕获机制是在数据链路层增加一个旁路处理，对发送和接收到的数据包做过滤/缓冲等相关处理，最后直接传递到应用程序。</p><p>常用的以太网卡支持以下工作模式：广播模式、多播模式、直接模式和混杂模式。</p><p>混杂模式:工作在混杂模式下的网卡接收所有的流过网卡的帧，信包捕获程序就是在这种模式下运行的。网卡的缺省工作模式包含广播模式和直接模式，即它只接收广播帧和发给自己的帧。如果采用混杂模式，网卡将接受同一网络内所有主机发送的数据包。</p><p>利用网卡混杂模式的特性，就可以到达对于网络信息监听捕获的目的。</p><p>2）解码机制</p><p>能对接受到的数据包进行解码，即将数字转换为ASCLL码，输出对用户友善的信息，以便用户查看部分数据包传输的具体内容；</p><p>3） 包过滤机制</p><p>包过滤机制是对所捕获到的数据包根据用户的要求进行筛选，最终只把满足过滤条件的数据包传递给用户程序。</p><p>4） 用户程序的接口</p><p>对用户程序而言，包捕获机制提供了一个统一的接口，使用户程序只需要简单的调用若干函数就能获得所期望的数据包。这样一来，针对特定操作系统的捕获机制对用户透明。</p><h3 id="文字介绍实现的方法"><a href="#文字介绍实现的方法" class="headerlink" title="文字介绍实现的方法"></a>文字介绍实现的方法</h3><p>设置网卡为混杂模式，建立socket实体，并用bind()函数将其绑定在主机IP上，调用recv()函数，返回捕获的数据包，完成包捕获机制；通过建立IP头部，TCP头部，UDP头部结构体，建立结构体类型的指针，指针指向数据包的第一个数组存储的地址，再计算头部长度，通过地址加上头部长度，就指向数据包具体内容存储的地址，从而就可以输出数据包内容；设置输出格式为%c(即以字符的形式输出)，并将一些控制字符以特定的形式输出，从而避免输出乱码，实现报文的解码；通过判断IP头部的Protocol信息，确定传输的是TCP报文还是UDP报文，对于应用层报文，例如TCP以上的报文，可以通过端口号实现报文的判断，例如80号端口是TCP，443端口对应的是HTTPS，25号端口对应的是SMTP，20和21端口对应的是FTP，从而实现了对数据包的辨别。</p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps64.png" alt="wps64"></p><h3 id="关键技术及代码"><a href="#关键技术及代码" class="headerlink" title="关键技术及代码"></a>关键技术及代码</h3><p>1） <strong>socket创建与数据包的接收，是网络嗅探器的基础</strong></p><p>SOCKET sock;</p><p>if ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_IP)) == SOCKET_ERROR)</p><p>​    {</p><p>​        exit(-1);</p><p>​    }</p><p>sockaddr_in sa;</p><p>sa.sin_family = AF_INET;</p><p>sa.sin_port = htons(6000);</p><p>sa.sin_addr.S_un.S_addr = inet_addr(“172.19.204.232”);</p><p>bind(sock, (SOCKADDR*)&amp;sa, sizeof(sa));//将socket与主机IP绑定</p><p>WSAIoctl(sock, SIO_RCVALL, &amp;optval, sizeof(optval), NULL, 0, &amp;dwBytesRet, NULL, NULL);  //设置网卡为混杂模式，接受所有的接收所有的流过网卡的帧</p><p>recv(sock, recvBuff, sizeof(recvBuff), 0); /<em>接收数据包</em>/</p><p>2） <strong>数据包过滤器的实现</strong></p><p>主要分为两部分：捕获的包通过解析IP头得出Protocol，通过判断Protocol的值确定传输层的数据包类型（例如ICMP的Protocol是1，TCP的Protocol是6），通过判断TCP头部的端口信息确定应用层的数据包类型（例如HTTP的端口是80，SMTP的端口是25，FTP的端口是20或21）。</p><p>if (pIpheader-&gt;Protocol == 1) {</p><p>​            if (myICMP == 0) continue;</p><p>​            printf(“———————ICMP———————\n”);</p><p>​            …….此部分为待打印的数据包信息……………        }</p><p>  if (pIpheader-&gt;Protocol == 89) {</p><p>​              if (myOSPF == 0) continue;</p><p>​              printf(“———————OSPF———————\n”);</p><p>…….此部分为待打印的数据包信息……………    }</p><p>if (pIpheader-&gt;Protocol == 6)  /<em>使用的是TCP协议</em>/</p><p>​           {if (dataLen == 0) break;</p><p>​             if (ntohs(pTcpheader-&gt;DestinationPort) == 80) {</p><p>​                  if (myHTTP == 0) continue;</p><p>​                  printf(“———————————-协议：HTTP；\n”);}</p><p>​             else if (ntohs(pTcpheader-&gt;DestinationPort) == 443) {</p><p>​                  if (myHTTPS == 0) continue;</p><p>​                  printf(“———————————-协议：HTTPS；\n”);}</p><p>​             else if (ntohs(pTcpheader-&gt;DestinationPort) == 25) {</p><p>​                  if (mySMTP == 0) continue;</p><p>​                  printf(“———————————-协议：SMTP；\n”);}</p><p>​             else if (ntohs(pTcpheader-&gt;DestinationPort) == 20 || ntohs(pTcpheader-&gt;DestinationPort) == 21)       </p><p>{</p><p>​                  if (myFTP == 0) continue;</p><p>​                  printf(“———————————-协议：FTP；\n”);}</p><p>​             else</p><p>​               {if (myTCP == 0) continue;</p><p>​                  printf(“———————————-协议：TCP；\n”);}    </p><p>…….此部分为待打印的数据包信息……………}</p><p>其他的数据包类型辨别诸如此类。</p><h2 id="实现结果"><a href="#实现结果" class="headerlink" title="实现结果"></a>实现结果</h2><h3 id="ICMP报文捕获"><a href="#ICMP报文捕获" class="headerlink" title="ICMP报文捕获"></a>ICMP报文捕获</h3><p>以下是一些基本的数据包信息。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps65-1672295099182.jpg" alt="wps65-1672295099182"></p><h3 id="HTTP报文捕获"><a href="#HTTP报文捕获" class="headerlink" title="HTTP报文捕获"></a>HTTP报文捕获</h3><p>很明显，我们能从数据包解码后的信息里看到以下信息：</p><p><strong>User-Agent：</strong>生成请求的浏览器类型</p><p><strong>Accept：</strong>客户端可识别的响应内容类型列表；星号* 用于按范围将类型分组。*/*表示可接受全部类型，type/*表示可接受type类型的所有子类型。</p><p><strong>Accept-Language:</strong> 客户端可接受的自然语言</p><p><strong>Accept-Encoding:</strong> 客户端可接受的编码压缩格式</p><p><strong>Accept-Charset：</strong> 可接受的字符集</p><p><strong>Host:</strong> 请求的主机名，允许多个域名绑定同一IP地址</p><p><strong>connection：</strong>连接方式（close或keeplive）</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps66-1672295099182.jpg" alt="wps66-1672295099182"></p><h3 id="HTTPS报文捕获"><a href="#HTTPS报文捕获" class="headerlink" title="HTTPS报文捕获"></a>HTTPS报文捕获</h3><p>我们可以看出报文内容是<strong>无意义的语句</strong>，原因在于HTTPS本身是一种<strong>加密传输</strong>，因此获取的报文是无意义的，但是我们可以通过IP头部得出该数据包的一些基础信息，例如源IP，目的IP等。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps67-1672295099183.jpg" alt="wps67-1672295099183"></p><h3 id="SMTP报文的捕获"><a href="#SMTP报文的捕获" class="headerlink" title="SMTP报文的捕获"></a>SMTP报文的捕获</h3><p>我们可以通过数据包内容看出该邮件的发送方，接收方，邮件内容，使用的软件（火狐），版本号等信息。</p><p>以下是我通过火狐邮件发送的邮件信息：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps68-1672295099183.jpg" alt="wps68-1672295099183"></p><p>这是抓包的结果，可以看出邮件的发送方，接收方，邮件具体内容，使用的软件及版本号都和上面对应的邮件信息相同；</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps69-1672295099183.jpg" alt="wps69-1672295099183"></p><h3 id="TCP报文捕获"><a href="#TCP报文捕获" class="headerlink" title="TCP报文捕获"></a>TCP报文捕获</h3><p>例如抓取的这个端口号是1231的TCP包，我们可以从数据包内容的分析可知<strong>唯一设备识别符</strong>，<strong>接口参数</strong>等信息。</p><p><img src="/%5Cimages%5Cwps70-1672295099183.jpg" alt="img"> </p><h3 id="UDP报文捕获"><a href="#UDP报文捕获" class="headerlink" title="UDP报文捕获"></a>UDP报文捕获</h3><p>可以通过报文信息看到一些具体的参数信息，具体的内容如下：</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps70-1672295099183.jpg" alt="wps70-1672295099183"></p><h3 id="FTP报文捕获"><a href="#FTP报文捕获" class="headerlink" title="FTP报文捕获"></a>FTP报文捕获</h3><p>可以通过报文解析查看用户名和密码。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps72-1672295099183.jpg" alt="wps72-1672295099183"></p><p><img src="/E:/git-blog\source\images\wps73-1672295099183.jpg" alt="wps73-1672295099183"></p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps74-1672295099183.jpg" alt="wps74-1672295099183"></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>1.问题：出现了以一种访问权限不允许的方式做了一个访问套接字的尝试。</p><p>解决方法：以管理员身份运行程序可以解决，注意：一定要关闭火绒软件，否则程序会被识别为木马；</p><p>2.问题：无法捕获到TCP</p><p>解决办法：主要是网卡的选择问题，使用gethostname(hostName, MAX_HOSTNAME_LEN)获取主机名称，通过他建立关于本机信息的一个hostent结构体;网卡选择hostent结构体的h_addr_list的第2个IP，就可以捕捉到TCP以及其他报文。</p><p>3.问题：捕获不到SMTP报文</p><p>解决办法：将Foxmail取消SSL加密传输</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps75-1672295099183.jpg" alt="wps75-1672295099183"></p><p>4.问题：对报文进行解码后出现许多乱码，无法有效的查看数据包信息</p><p>解决办法：事实上， ascll码仅有32到126是对于解码有意义的，其他的大部分都是操作符，或者是一些意义不大的字符，如果在解码过程中以字符的形式控制输出（即printf(“ %c”, *(recvBuff + i));），这一部分就会出现乱码，因此在执行解码的时候，我们可以做一个过滤机制，只将32到126以字符的形式进行解码，其他的以统一的格式输出即可，这样便于对数据包内容进行分析。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络嗅探器的实现&quot;&gt;&lt;a href=&quot;#网络嗅探器的实现&quot; class=&quot;headerlink&quot; title=&quot;网络嗅探器的实现&quot;&gt;&lt;/a&gt;网络嗅探器的实现&lt;/h1&gt;&lt;p&gt;网络监控软件能够检测网络流量，发现网络中异常的数据流，有效地发现和防御网络攻击，是保证网络安</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用UltraEdi猜测文件格式</title>
    <link href="http://example.com/2022/12/29/%E4%BD%BF%E7%94%A8UltraEdi%E7%8C%9C%E6%B5%8B%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <id>http://example.com/2022/12/29/%E4%BD%BF%E7%94%A8UltraEdi%E7%8C%9C%E6%B5%8B%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</id>
    <published>2022-12-29T06:21:58.508Z</published>
    <updated>2023-02-09T20:01:21.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用UltraEdi猜测文件格式"><a href="#使用UltraEdi猜测文件格式" class="headerlink" title="使用UltraEdi猜测文件格式"></a>使用UltraEdi猜测文件格式</h2><p>1.用UltraEdit工具查看doc和gif文件类型</p><p>在文件后缀未知的时候，我们可以通过该文件的十六进制的文件头来辨别文件类型。例如JPEG (jpg)，文件头：FFD8FF；PNG (png)，文件头：89504E47；GIF (gif)，文件头：47494638；TIFF (tif)，文件头：49492A00</p><p>以十六进制的格式打开一个doc文件，观察其文件头为D0CF11E0A1B11AE1，通过查阅文件头对应的文件类型可知该文件是一个doc文件。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps7-1672293826739.jpg" alt="wps7-1672293826739"></p><p>以十六进制的格式打开一个gif文件，观察其文件头为47494638，通过查阅文件头对应的文件类型可知该文件是一个gif文件。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps8-1672293826741.jpg" alt="wps8-1672293826741"></p><p>步骤2：用UltraEdit工具查看rar和zip压缩包及其包含文件的文件类型</p><p>新建一个用于测试的文件夹E，包含2个txt文件</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps9-1672293826741.jpg" alt="wps9-1672293826741"></p><p>分析可以找到其文件属性为20000000，即为txt文件</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps10-1672293826741.jpg" alt="wps10-1672293826741"></p><p>以下是zip文件的十六进制。20 00 00 00表示文件属性这里是txt文件。</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps11-1672293826741.jpg" alt="wps11-1672293826741"></p><p>步骤3：用UltraEdit工具查看未知文件类型的文件，猜测文件类型</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps12-1672293826742.jpg" alt="wps12-1672293826742"></p><p>分析以上文件的十六进制内容，可以发现其文件头为 D0CF11E0A1B11AE1，因此它是一个doc文件。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps13-1672293826742.jpg" alt="wps13-1672293826742"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用UltraEdi猜测文件格式&quot;&gt;&lt;a href=&quot;#使用UltraEdi猜测文件格式&quot; class=&quot;headerlink&quot; title=&quot;使用UltraEdi猜测文件格式&quot;&gt;&lt;/a&gt;使用UltraEdi猜测文件格式&lt;/h2&gt;&lt;p&gt;1.用UltraEdit工具</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>文件恢复</title>
    <link href="http://example.com/2022/12/29/%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D/"/>
    <id>http://example.com/2022/12/29/%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D/</id>
    <published>2022-12-29T06:20:33.046Z</published>
    <updated>2023-02-09T20:23:11.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件恢复"><a href="#文件恢复" class="headerlink" title="文件恢复"></a>文件恢复</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>文件在磁盘上的存储就像是一个链表，表头是文件的起始地址，整个文件并不一定是连续的，而是一个节点一个节点的连接起来的。要访问某个文件时，只要找到表头就行了。删除文件时，其实只是把表头删除了，后面的数据并没有删除，直到下一次进行写磁盘操作需要占用节点所在位置时，才会把相应的数据覆盖掉。数据恢复软件正是利用了这一点。</p><p>人们平常所做的删除，只是让系统修改了文件分配表中的前两个代码（相当于作了“已删除”标记），同时将文件所占簇号在文件分配表中的记录清零，以释放该文件 所占空间。因此，文件被删除后硬盘剩余空间就增加了；而文件的真实内容仍保存在数据区，它须等写入新数据时才被新内容覆盖，在覆盖之前原数据是不会消失的。恢复工具（如FinalData等）就是利用这个特性来实现对已删除文件的恢复，以下将使用恢复软件Disk Drill来实践文件恢复过程。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-对于近期删除可以直接在回收箱找到的文件"><a href="#1-对于近期删除可以直接在回收箱找到的文件" class="headerlink" title="1.对于近期删除可以直接在回收箱找到的文件"></a>1.对于近期删除可以直接在回收箱找到的文件</h3><p>1.1建立一个文件并删除。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps51-1672294733894.jpg" alt="wps51-1672294733894"></p><p>1.2.一般近期删除的文件都可以在回收箱找到文件并恢复（原理：回收站是一个特殊的文件夹，默认在每个硬盘分区根目录下的RECYCLER文件夹中，而且是隐藏的。当我们将文件删除并移到回收站后，实质上就是把它放到了这个文件夹，仍然占用磁盘的空间。只有在回收站里删除它或清空回收站才能使文件真正地删除，为电脑获得更多的磁盘空间。）</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps52-1672294733895.jpg" alt="wps52-1672294733895"></p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps53-1672294733896.jpg" alt="wps53-1672294733896"></p><p>1.3.然后再点开文件夹，可以发现文件已恢复。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps54-1672294733896.jpg" alt="wps54-1672294733896"></p><h3 id="2-对于回收箱已删除的文件，我们可以通过Disk-Drill软件实现文件恢复"><a href="#2-对于回收箱已删除的文件，我们可以通过Disk-Drill软件实现文件恢复" class="headerlink" title="2.对于回收箱已删除的文件，我们可以通过Disk Drill软件实现文件恢复"></a>2.对于回收箱已删除的文件，我们可以通过Disk Drill软件实现文件恢复</h3><p>2.1.建立一个测试文件并删除，同时将回收箱的文件也删除。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps55.jpg" alt="wps55"></p><p>2.2打开Disk Drill软件，搜索存于E盘且删除时间的1天的文件，并点击恢复。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps56-1672294733896.jpg" alt="wps56-1672294733896"></p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps57-1672294733897.jpg" alt="wps57-1672294733897"></p><p>以下可以选择恢复路径。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps58-1672294733897.jpg" alt="wps58-1672294733897"></p><p>2.3.重新进入E盘的软件安全文件夹中查找已恢复的文件</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps59-1672294733897.jpg" alt="wps59-1672294733897"></p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps60-1672294733897.jpg" alt="wps60-1672294733897"></p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps61-1672294733898.jpg" alt="wps61-1672294733898"></p><p><strong>注意：在回收箱删除文件后，尽量不要进行其他的写入操作，否则可能</strong><em><strong>*占用节点所在位置时，*</strong></em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件恢复&quot;&gt;&lt;a href=&quot;#文件恢复&quot; class=&quot;headerlink&quot; title=&quot;文件恢复&quot;&gt;&lt;/a&gt;文件恢复&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>熟悉使用静态漏洞挖掘工具：cppCheck和动态漏洞挖掘工具： Boofuzz</title>
    <link href="http://example.com/2022/12/29/%E7%86%9F%E6%82%89%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%B7%A5%E5%85%B7%EF%BC%9AcppCheck%E5%92%8C%E5%8A%A8%E6%80%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%B7%A5%E5%85%B7%EF%BC%9A%20Boofuzz/"/>
    <id>http://example.com/2022/12/29/%E7%86%9F%E6%82%89%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%B7%A5%E5%85%B7%EF%BC%9AcppCheck%E5%92%8C%E5%8A%A8%E6%80%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%B7%A5%E5%85%B7%EF%BC%9A%20Boofuzz/</id>
    <published>2022-12-29T06:17:36.570Z</published>
    <updated>2023-02-09T20:11:37.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="熟悉使用静态漏洞挖掘工具：cppCheck和动态漏洞挖掘工具：-Boofuzz"><a href="#熟悉使用静态漏洞挖掘工具：cppCheck和动态漏洞挖掘工具：-Boofuzz" class="headerlink" title="熟悉使用静态漏洞挖掘工具：cppCheck和动态漏洞挖掘工具： Boofuzz"></a>熟悉使用静态漏洞挖掘工具：cppCheck和动态漏洞挖掘工具： Boofuzz</h2><p>利用cppcheck静态漏洞挖掘工具分析源代码，写出详细的代码模块分析和使用报告，并使用若干案例进行验证。</p><h4 id="cppCheck"><a href="#cppCheck" class="headerlink" title="cppCheck"></a>cppCheck</h4><p>\1. 下载分析源代码及各模块功能</p><p>1.1. ****cppcheck****<strong>检查点</strong></p><p> <strong>1</strong>、自动变量检查：返回自动变量（局部变量）指针；</p><p> <strong>2</strong>、越界检查： 数组越界返回自动变量（局部变量）指针；</p><p> <strong>3</strong>、类检查： 构造函数初始化；</p><p> <strong>4</strong>、内存泄露检查；</p><p> <strong>5</strong>、空指针检查；</p><p> <strong>6</strong>、废弃函数检查；</p><p>  <strong>7.</strong> 自己定制项目中对应的规则；</p><p> <strong>8</strong>、其他。</p><p>1.2. <strong>Cppcheck总过程：</strong></p><p><strong>预处理</strong>：由<strong>Preprocessor</strong>类实现<strong>**，*<em><strong>执行</strong>Class Preprocessor::preprocess()*<em><strong>，该</strong>阶段主要处理：去多余空格，删除汇编代码，处理</em>*#Include</em>*及嵌套，统一预处理语句（例：</strong>#if define=&gt; #ifdef<strong>），提取预处理配置设置（</strong>configuration**），替换宏定义。</p><p><strong>Tokenize：</strong>解析代码成符号（**+-*/;…**等，变量名，函数名），由 <strong>class Tokenizer</strong>实现， 实现接口 <strong>class Tokenizer::tokenize()。</strong></p><p><strong>Simplify：</strong>简化复杂代码，统一化，由 <strong>class Tokenizer</strong>实现， 实现接口 <strong>class Tokenizer::simplifyTokenList()。</strong></p><p><strong>分析代码，报告错误。</strong></p><p>1.3. <strong>cppcheck总体流程图</strong>如下：</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps26.png" alt="wps26"></p><p>开发中使用主要的类有：</p><p>Tokenizer类： 代码token化， 计划代码</p><p>SymbolDatabase类：符号数据库，生成和存储各种符号：scope,function, variable等</p><p>Scope类： 各种代码block。最常用的有functionScopes， classAndStructScopes等</p><p>Token类： 里面有str(), next(), previous(), tokAt(), link(),Match()等常用函数</p><p>Variable类：getTypeString() –C++相关的代码经常需要</p><p>Function类：可以找到实现的scope</p><p>Value类： token可以通过getValue()得到可能的值</p><p><strong>参数分析部分（****内部抽象classSetings</strong>）：**</p><p>class Settings</p><p>{</p><p> …</p><p> std::string _append;</p><p> std::string userDefines;</p><p> std::list<a href="std::string">std::string</a> _includePaths;</p><p> std::list<Rule> rules;</Rule></p><p> …</p><p>}</p><p><em><strong>*核心函数check()*</strong></em></p><p>　　处理入口，在此函数对输入代码进行初步分析处理，最后将代码传递给 CheckFile()。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps27-1672294253195.jpg" alt="wps27-1672294253195"></p><p><em><strong>*核心函数CheckFile()*</strong></em></p><p>　　函数功能是分析一个代码文件， CheckFile()会将代码流做进一步的分析，做tokenize,simplify，处理后分析代码，报告错误。</p><p>  <strong>1.3.代码流分析</strong></p><p>举例代码：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps28-1672294253195.jpg" alt="wps28-1672294253195"></p><p>执行路径1：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps29.jpg" alt="wps29"></p><p>执行路径2：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps30-1672294253195.jpg" alt="wps30-1672294253195"></p><p>保留条件信息：</p><p><img src="/E:/git-blog\source\images\wps31.jpg" alt="wps31"></p><p>最后执行if for while等复杂语句的等价替换</p><p>例如</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps32-1672294253196.png" alt="wps32-1672294253196"></p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps33.png" alt="wps33"></p><p>\2. <strong>使用若干案例进行验证</strong></p><p>2.1. 当数组下标越界</p><p>  <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps34.jpg" alt="wps34"></p><p> 2.2.当函数参数被指派为一个地址</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps35.jpg" alt="wps35"></p><p>2.3.当内存泄漏</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps36-1672294253196.jpg" alt="wps36-1672294253196"></p><p>2.4．当使用迭代器到本地容器可能是无效的。  </p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps37-1672294253197.jpg" alt="wps37-1672294253197"></p><p>2.5.越界问题</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps38-1672294253197.jpg" alt="wps38-1672294253197"></p><h4 id="Boofuzz"><a href="#Boofuzz" class="headerlink" title="Boofuzz"></a><strong>Boofuzz</strong></h4><p><strong>1.下载安装boofuzz</strong></p><p><em><strong>*2.BooFuzz框架*</strong></em></p><p>四大组件：</p><p>a) Data Generation 数据生成, 基于generation-based的方式, 需要对协议或者文件进行建模.</p><p>b) Session 会话管理, 根据已经构建好的Request，利用 Pgraph 绘制， Pgraph 可以创建、修改和渲染图</p><p>c) Agents代理</p><p>d) Utilities独立单元工具</p><p><strong>3.总流程</strong></p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps39.png" alt="wps39"></p><p>**4.**<strong>Session对象</strong></p><p>即Fuzz测试的核心，当你创建Session的时候，你会传递一个Target对象，该对象本身接收一个Connection对象。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps40-1672294253197.jpg" alt="wps40-1672294253197"></p><p>准备好会话对象后，接下来需要在协议中定义消息。每一条消息均以一个s_initialize函数开头，比如这是fuzz FTP协议中的几个消息定义：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps41-1672294253198.jpg" alt="wps41-1672294253198"></p><p>定义消息后，将使用刚刚创建的Session对象将它们连接到图中：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps42-1672294253198.jpg" alt="wps42-1672294253198"></p><p>之后，就可以进行fuzz测试session.fuzz()</p><p>每次运行的日志数据将保存到当前工作目录下boofuzz-results目录中的SQLite数据库中。</p><p><strong>5.</strong> <strong>对路由器的登录接口进行fuzz测试</strong></p><p>5.1.使用Burpsuite设置代理</p><p>5.2. Burpsuite抓包，结果如下：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps43-1672294253198.jpg" alt="wps43-1672294253198"></p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps44.png" alt="wps44"></p><p>5.3.然后根据报文，利用boofuzz框架提供的原语对http请求进行定义</p><p><img src="/E:/git-blog\source\images\wps45-1672294253198.jpg" alt="wps45-1672294253198"></p><p>5.4. 设置会话信息，包括设备的IP地址以及端口</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps46-1672294253198.jpg" alt="wps46-1672294253198"></p><p>注意：如果需要fuzz多个请求，比如说，还要继续fuzz登录后的一些接口，还需要将之前定义的请求按照一定的先后顺序连接，比如说：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps47-1672294253198.jpg" alt="wps47-1672294253198"></p><p>5.5.添加监视器</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps48-1672294253199.jpg" alt="wps48-1672294253199"></p><p>5.6．调用session.fuzz()，运行编写好的脚本，每次运行的日志数据将保存到当前工作目录下boofuzz-results目录中的SQLite数据库中，运行boo open &lt;run-*.db&gt;，会在26000端口开启一个Web服务器，控制和查看测试进度。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps49-1672294253199.jpg" alt="wps49-1672294253199"></p><p>上图表明，第238个用例测试结果出现了异常。在打开数据库监控状态的时候，如果提示26000端口已经占用，可以使用netstat -anp | grep 26000找到进程，并杀死即可。</p><p>5.7. 打开 boofuzz-results 目录下的相关文件可查看fuzz的日志</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps50-1672294253199.jpg" alt="wps50-1672294253199"></p><p>从中可以看出的确是按照代码，对相关字段进行分析，从而达到fuzz的效果。进一步观察238个用例的前一个用例，找到发送的内容，重新发送，观察设备状态，看问题是否能够复现，最终确定漏洞是否存在。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;熟悉使用静态漏洞挖掘工具：cppCheck和动态漏洞挖掘工具：-Boofuzz&quot;&gt;&lt;a href=&quot;#熟悉使用静态漏洞挖掘工具：cppCheck和动态漏洞挖掘工具：-Boofuzz&quot; class=&quot;headerlink&quot; title=&quot;熟悉使用静态漏洞挖掘工具：c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>文本相似度的计算</title>
    <link href="http://example.com/2022/12/29/%E6%96%87%E6%9C%AC%E7%9B%B8%E4%BC%BC%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
    <id>http://example.com/2022/12/29/%E6%96%87%E6%9C%AC%E7%9B%B8%E4%BC%BC%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97/</id>
    <published>2022-12-29T05:56:57.868Z</published>
    <updated>2023-02-09T20:19:12.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文本相似度的计算"><a href="#文本相似度的计算" class="headerlink" title="文本相似度的计算"></a>文本相似度的计算</h1><p>输入：两个向量</p><p>输出：两个向量的余弦相似度</p><p>思路：将输入框获取到的字符串以“，”分割获取各个向量存于list内，这里可以用Split(‘,’)来实现，再将list里面的元素由string转换成double类型，便于后面计算，然后判断量向量分量数是否相等，如不相等，则弹窗提示；如果相等，则system.math计算以下公式：</p><p><img src="/%5Cimages%5Cwps3.png" alt="img"> </p><p>最后输出结果即可。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps4.png" alt="wps4"></p><h2 id="重要源码"><a href="#重要源码" class="headerlink" title="重要源码"></a>重要源码</h2><p>using System;</p><p>using System.Collections.Generic;</p><p>using System.ComponentModel;</p><p>using System.Data;</p><p>using System.Drawing;</p><p>using System.Linq;</p><p>using System.Text;</p><p>using System.Threading.Tasks;</p><p>using System.Windows.Forms;</p><p>namespace WindowsFormsApp1</p><p>{</p><p>  public partial class Form1 : Form</p><p>  {</p><p>​    public Form1()</p><p>​    {</p><p>​      InitializeComponent();</p><p>​    }</p><p>​    private void richTextBox1_TextChanged(object sender, EventArgs e)</p><p>​    {</p><p>​    }</p><p>​    private void textBox2_TextChanged(object sender, EventArgs e)</p><p>​    {</p><p>​    }</p><p>​    private void textBox1_TextChanged(object sender, EventArgs e)</p><p>​    {</p><p>​    }</p><p>​    private void button1_Click(object sender, EventArgs e)</p><p>​    {</p><p>​      richTextBox1.Clear();</p><p>​      string str1 = textBox1.Text;</p><p>​      string str2 = textBox2.Text;</p><p>​      if (string.IsNullOrEmpty(str1) || string.IsNullOrEmpty(str2))  //判断输入是否为空</p><p>​        MessageBox.Show(“向量不能为空”);</p><p>​      List<string> list1 = new List<string>(str1.Split(‘,’));  //以”,”分割，将分割后的字符串存于list里面</string></string></p><p>​     List<string> list2 = new List<string>(str2.Split(‘,’));</string></string></p><p>​      List<double> double1 = new List<double>();  </double></double></p><p>​      List<double> double2 = new List<double>();</double></double></p><p>​      //将list里面的内容有string转换为double类型，便于后面进行计算</p><p>​      foreach (var item in list1)  </p><p>​      {</p><p>​        double a = Double.Parse(item);</p><p>​        double1.Add(a);</p><p>​      }</p><p>​      foreach (var item in list2)</p><p>​      {</p><p>​        double a = Double.Parse(item);</p><p>​        double2.Add(a);</p><p>​      }</p><p>​      if (double1.Count() != double2.Count())  //判断两个分量是否相等</p><p>​        MessageBox.Show(“请输入两个分量数相等的向量！”);</p><p>​      //求余弦相似度</p><p>​      else</p><p>​      {</p><p>​        double s = 0;</p><p>​        double den1 = 0;</p><p>​        double den2 = 0;</p><p>​        for (int i = 0; i &lt; double1.Count(); i++)</p><p>​        {</p><p>​          //求分子</p><p>​          s += double1[i] * double2[i];</p><p>​          //求分母（1）</p><p>​          den1 += Math.Pow(double1[i], 2);</p><p>​          //求分母（2）</p><p>​          den2 += Math.Pow(double2[i], 2);</p><p>​        }</p><p>​        string h = Convert.ToString(s / (Math.Sqrt(den1) * Math.Sqrt(den2)));//将最后结果转换为string类型再输出</p><p>​        // richTextBox1.AppendText(s+ “\n”);</p><p>​        // richTextBox1.AppendText(den1+ “\n”);</p><p>​        //  richTextBox1.AppendText(den2 + “\n”);</p><p>​        richTextBox1.AppendText(h + “\n”);</p><p>​      }</p><p>​    }</p><p>  }</p><p>}</p><h2 id="输出界面"><a href="#输出界面" class="headerlink" title="输出界面"></a>输出界面</h2><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps5-1672292663237.jpg" alt="wps5-1672292663237"></p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps6-1672292663238.jpg" alt="img"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文本相似度的计算&quot;&gt;&lt;a href=&quot;#文本相似度的计算&quot; class=&quot;headerlink&quot; title=&quot;文本相似度的计算&quot;&gt;&lt;/a&gt;文本相似度的计算&lt;/h1&gt;&lt;p&gt;输入：两个向量&lt;/p&gt;
&lt;p&gt;输出：两个向量的余弦相似度&lt;/p&gt;
&lt;p&gt;思路：将输入框获取到</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>获取与解析网页数据实践</title>
    <link href="http://example.com/2022/12/29/%E8%8E%B7%E5%8F%96%E4%B8%8E%E8%A7%A3%E6%9E%90%E7%BD%91%E9%A1%B5%E6%95%B0%E6%8D%AE%E5%AE%9E%E8%B7%B5/"/>
    <id>http://example.com/2022/12/29/%E8%8E%B7%E5%8F%96%E4%B8%8E%E8%A7%A3%E6%9E%90%E7%BD%91%E9%A1%B5%E6%95%B0%E6%8D%AE%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-12-29T05:42:34.500Z</published>
    <updated>2023-02-09T19:12:42.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="获取与解析网页数据实践"><a href="#获取与解析网页数据实践" class="headerlink" title="获取与解析网页数据实践"></a>获取与解析网页数据实践</h1><p>输入URL,获取HTML源码，解析并显示其中的文字。(以腾讯新闻或特定页面为例)</p><p>输入：url</p><p>输出：页面源代码，页面的文本内容</p><p>过程：利用webclient获取指定页面的源代码，在使用正则表达式过滤出需要的内容，一般标题存在<title></title>标签里面，文章是存在</p><p></p>标签里面,，利用类似于&lt;p.<em>&gt;(.</em>)<p></p>，&lt;title.<em>&gt;(.</em>)这样的正则表达式匹配即可。<p></p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps1-1672292440966.png" alt="wps1-1672292440966"></p><h2 id="重要源码"><a href="#重要源码" class="headerlink" title="重要源码"></a>重要源码</h2><p>using System;</p><p>using System.Collections.Generic;</p><p>using System.ComponentModel;</p><p>using System.Data;</p><p>using System.Drawing;</p><p>using System.Linq;</p><p>using System.Text;</p><p>using System.Threading.Tasks;</p><p>using System.Windows.Forms;</p><p>using System.Net;</p><p>using System.IO;</p><p>using System.Net.Http;</p><p>using System.Text.RegularExpressions;</p><p>namespace WindowsFormsApp1</p><p>{</p><p>  public partial class Form1 : Form</p><p>  {</p><p>​    public Form1()</p><p>​    {</p><p>​      InitializeComponent();</p><p>​    }</p><p>​    private void label1_Click(object sender, EventArgs e)</p><p>​    {</p><p>​      </p><p>​    }</p><p>​    private void textBox1_TextChanged(object sender, EventArgs e)</p><p>​    {</p><p>​    }</p><p>​    private void richTextBox1_TextChanged(object sender, EventArgs e)</p><p>​    {</p><p>​    }</p><p>​    private void button1_Click(object sender, EventArgs e)</p><p>​    {</p><p>​      try</p><p>​      {</p><p>​        richTextBox1.Clear();</p><p>​        richTextBox2.Clear();</p><p>​        // Download the data to a buffer.</p><p>​        WebClient client = new WebClient();</p><p>​        string url = textBox1.Text;  //获取目标页面的url</p><p>​        Byte[] pageData = client.DownloadData(url);  //获取目标页面源码</p><p>​        string pageHtml = client.Encoding.GetString(pageData);     </p><p>​        richTextBox1.AppendText(pageHtml);</p><p>​        MatchCollection matches = Regex.Matches(pageHtml, “&lt;p.<em>&gt;(.</em>)</p>“);<p></p><p>​        //依次取得匹配到段落里的数据</p><p>​        MatchCollection title = Regex.Matches(pageHtml, “&lt;title.<em>&gt;(.</em>)“);</p><p>​        //依次取得匹配到标题里的数据</p><p>​        foreach (Match item in title)</p><p>​        {</p><p>​         </p><p>​          richTextBox2.AppendText(item.Groups[1].Value + “\n”);</p><p>​        }</p><p>​        foreach (Match item in matches)</p><p>​        {</p><p>​         </p><p>​          richTextBox2.AppendText(item.Groups[1].Value + “\n”);</p><p>​         </p><p>​        }</p><p>​        </p><p>​        // Download the data to a file.</p><p>​        // client.DownloadFile(“<a href="http://www.contoso.com&quot;/">http://www.contoso.com&quot;</a>, “page.htm”);</p><p>​        // Upload some form post values.</p><p>​        // NameValueCollection form = new NameValueCollection();</p><p>​        // form.Add(“MyName”, “MyValue”);</p><p>​        // Byte[] responseData = client.UploadValues(“<a href="http://www.contoso.com/form.aspx&quot;">http://www.contoso.com/form.aspx&quot;</a>, form);</p><p>​      }</p><p>​      catch (WebException webEx)</p><p>​      {</p><p>​        Console.WriteLine(webEx.ToString());</p><p>​        if (webEx.Status == WebExceptionStatus.ConnectFailure)</p><p>​        {</p><p>​          Console.WriteLine(“Are you behind a firewall?  If so, go through the proxy server.”);</p><p>​        }</p><p>​      }</p><p>​    }</p><p>​    private void richTextBox2_TextChanged(object sender, EventArgs e)</p><p>​    {</p><p>​    }</p><p>  }</p><p>}</p><h2 id="输出界面"><a href="#输出界面" class="headerlink" title="输出界面"></a>输出界面</h2><p>解析的文本内容有标题和段落两部分，如下：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps2-1672292440969.jpg" alt="wps2-1672292440969"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;获取与解析网页数据实践&quot;&gt;&lt;a href=&quot;#获取与解析网页数据实践&quot; class=&quot;headerlink&quot; title=&quot;获取与解析网页数据实践&quot;&gt;&lt;/a&gt;获取与解析网页数据实践&lt;/h1&gt;&lt;p&gt;输入URL,获取HTML源码，解析并显示其中的文字。(以腾讯新闻或特</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ARP欺骗实战</title>
    <link href="http://example.com/2022/12/29/ARP%E6%AC%BA%E9%AA%97%E5%AE%9E%E6%88%98/"/>
    <id>http://example.com/2022/12/29/ARP%E6%AC%BA%E9%AA%97%E5%AE%9E%E6%88%98/</id>
    <published>2022-12-29T05:12:54.043Z</published>
    <updated>2023-02-09T20:40:28.090Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ARP欺骗实战"><a href="#ARP欺骗实战" class="headerlink" title="ARP欺骗实战"></a>ARP欺骗实战</h1><p>​       ARP请求为广播形式发送的，网络上的主机可以自主发送 ARP应答消息，并且当其他主机收到应答报文时不会检测该报文的真实性就将其记录在本地的MAC地址转换表，这样攻击者就可以向目标主机发送伪ARP应答报文，从而篡改本地的MAC地址表。ARP欺骗可以导致目标计算机与网关通信失败，更会导致通信重定向，所有的数据都会通过攻击者的机器。攻击者再对目标和网关之间的数据进行转发，则可作为一个“中间人”，实现监听目标却又不影响目标正常上网的目的。因此，我们可以利用操作机修改目标机arp缓存表中的网关物理地址，修改为操作机自己的物理地址。</p><p>操作机：Kali</p><p>目标机：centos7</p><p><strong>实验步骤：</strong></p><p>1.在kali上查看ARP缓存表，可以看到网关为192.168.158.2及其mac地址；还可以看到目标机ip为192.168.159.132及其mac地址</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps1.jpg" alt="wps1"></p><p>2.在centos7中查看网关ip及其物理地址；</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps2.jpg" alt="wps2"></p><p>\3. nmap扫描目标IP与本机IP</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps3-1672290670159.jpg" alt="wps3-1672290670159"></p><p>\4. 在进行ARP欺骗之前必须开启IP转发，否则当欺骗成功之后，目标机会断网，这样会被对方察觉</p><p>注意：执行该命令前需要root权限，sudo su</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps4-1672290670159.jpg" alt="wps4-1672290670159"></p><p>\5. 安装 “dsniff” 依赖包</p><p>注意：需要先进入sources.list文件更换源地址</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps5-1672290670159.jpg" alt="wps5-1672290670159"></p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps6-1672290670159.jpg" alt="wps6-1672290670159"></p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps7-1672290670159.jpg" alt="wps7-1672290670159"></p><p>输入arpspoof检查依赖包是否安装成功</p><p><img src="/E:/git-blog\source\images\wps8-1672290670159.jpg" alt="wps8-1672290670159"></p><p>\6. 开启IP转发</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps9-1672290670159.jpg" alt="wps9-1672290670159"></p><p>7.在centos7查看网关的物理地址，如下图，可以看出物理地址由00：50：56：F9：F5：D5变成了00：0C:29:B7:0B:59（即操作机的物理地址），ARP缓存已经发生了变化， 一次简单的ARP欺骗成功了。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps10-1672290670160.jpg" alt="wps10-1672290670160"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;ARP欺骗实战&quot;&gt;&lt;a href=&quot;#ARP欺骗实战&quot; class=&quot;headerlink&quot; title=&quot;ARP欺骗实战&quot;&gt;&lt;/a&gt;ARP欺骗实战&lt;/h1&gt;&lt;p&gt;​       ARP请求为广播形式发送的，网络上的主机可以自主发送 AR</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>入侵检测系统构建</title>
    <link href="http://example.com/2022/12/29/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/"/>
    <id>http://example.com/2022/12/29/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/</id>
    <published>2022-12-29T05:06:51.832Z</published>
    <updated>2023-02-09T19:56:27.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="入侵检测系统构建"><a href="#入侵检测系统构建" class="headerlink" title="入侵检测系统构建"></a>入侵检测系统构建</h1><h2 id="一．实验介绍"><a href="#一．实验介绍" class="headerlink" title="一．实验介绍"></a>一．实验介绍</h2><p>构建一个实用的入侵检测系统，保证网络安全，并在实现网络环境中进行测试。选用开源的入侵检测框架Snort实现。</p><h2 id="二．实验要求"><a href="#二．实验要求" class="headerlink" title="二．实验要求"></a>二．实验要求</h2><p>采用文本界面或图形界面下进行交互的工作方式，完成如下功能：</p><p>（1） 界面方面：可配置、可显示系统运行结果。</p><p>（2） 软件安装：完成 Snort、Apache、Mysql、base 等相关软件。</p><p>（3） 文件配置：</p><p>l 配置数据库输出插件。</p><p>l 制订入侵防范策略。</p><p>（4） 规则配置：</p><p>l 下载 Snort 检测规则，用于入侵检测。</p><p>l 自己完成至少一条规则的编写，并进行正确性测试。</p><p>l 完成对检测规则的压力测试。</p><p>（5） 日志方面：记录日志，分析，并将运行结果存入数据库。</p><p>（6） 代码部分：程序源程序要有相应注释，每个函数要写明作用、入口参数含义、返回值含义，程序代码的关键部分添加注释。</p><p>（7） 相关文档：</p><p>l 功能目标分解表。</p><h2 id="三．实验原理"><a href="#三．实验原理" class="headerlink" title="三．实验原理"></a>三．实验原理</h2><p>IDS（intrusion detection system）入侵检测系统是一种对网络传输进行即时监视，在发现可疑传输时发出警报或者采取主动反应措施的网络安全设备。它与其他网络安全设备的不同之处便在于，IDS是一种积极主动的安全防护技术。 </p><p>专业上讲IDS就是依照一定的安全策略，对网络、系统的运行状况进行监视，尽可能发现各种攻击企图、攻击行为或者攻击结果，以保证网络系统资源的机密性、完整性和可用性。与防火墙不同的是，IDS入侵检测系统是一个旁路监听设备，没有也不需要跨接在任何链路上，无须网络流量流经它便可以工作。因此，对IDS的部署的唯一要求就是：IDS应当挂接（并行接入）在所有所关注流量都必须流经的链路上。</p><h3 id="3-1入侵检测系统功能"><a href="#3-1入侵检测系统功能" class="headerlink" title="3.1入侵检测系统功能"></a>3.1入侵检测系统功能</h3><p>a.监测并分析用户和系统的活动</p><p>b.核查系统配置和漏洞</p><p>c.对操作系统进行日志管理，并识别违反安全策略的用户活动</p><p>d.针对已发现的攻击行为作出适当的反应，如告警、中止进程等</p><h3 id="3-2-IDS工作过程"><a href="#3-2-IDS工作过程" class="headerlink" title="3.2.IDS工作过程"></a>3.2.IDS工作过程</h3><h4 id="3-1-1-信息收集"><a href="#3-1-1-信息收集" class="headerlink" title="3.1.1.信息收集"></a>3.1.1.信息收集</h4><p> 收集的内容包括系统、网络、数据及用户活动的状态和行为。入侵检测利用的信息一般来自以下四个方面：</p><p> <strong>a.系统日志</strong>：黑客经常在系统日志中留下他们的踪迹，因此，充分利用系统日志是非常重要的</p><p><strong>b.目录以及文件的异常改变</strong>：网络环境中的文件系统包含很多软件和数据文件，包含重要信息的文 件和私有数据文件经常是黑客修改或破坏的目标</p><p><strong>c.程序执行中的异常行为</strong> 网络系统上的程序执行一般包括操作系统、网络服务、用户启动的程 序和特定目的的应用，例如数据库服务器。每个在系统上执行的程序由一 到多个进程来实现。每个进程执行在具有不同权限的环境中，这种环境控 制着进程可访问的系统资源、程序和数据文件等。一个进程出现了不期望 的行为可能表明黑客正在入侵你的系统。黑客可能会将程序或服务的运行 分解，从而导致运行失败，或者是以非用户或非管理员意图的方式操作</p><p><strong>d.物理形式的入侵信息</strong> 这包括两个方面的内容，一是未授权的对网络硬件连接；二是对物理 资源的未授权访问</p><h4 id="3-1-2-数据分析"><a href="#3-1-2-数据分析" class="headerlink" title="3.1.2.数据分析"></a>3.1.2.数据分析</h4><p>一般通过三种技术手段进行分析： 模式匹配， 统计分析和完整性分析。 其中前两种方法用于实时的入侵检测，而完整性分析则用于事后分析。</p><p><strong>a.模式匹配</strong>：模式匹配就是将收集到的信息与已知的网络入侵和系统误用模式数据 库进行比较，从而发现违背安全策略的行为</p><p><strong>b.统计分析：</strong>统计分析方法首先给系统对象（如用户、文件、目录和设备等）创建 一个统计描述，统计正常使用时的一些测量属性（如访问次数、操作失败 次数和延时等）。测量属性的平均值将被用来与网络、系统的行为进行比 较，任何观察值如果超过了正常值范围，就认为有入侵发生。其优点是可 检测到未知的入侵和更为复杂的入侵，缺点是误报、漏报率高，且不适应 用户正常行为的突然改变</p><p><strong>c.完整性分析:</strong> 完整性分析主要关注某个文件或对象是否被更改，这经常包括文件和 目录的内容及属性，它在发现被修改成类似特洛伊木马的应用程序方面特 别有效。其优点是不管模式匹配方法和统计分析方法能否发现入侵，只要 是有入侵行为导致了文件或其他对象的任何改变，它都能够发现。缺点是 一般以批处理方式实现，不用于实时响应</p><p>其分析引擎有：</p><p>1、<strong>误用检测技术</strong> 基于模式匹配原理。收集非正常操作的行为特征，建立相关的特征库，当监测的用户或系统行为与库中的记录相匹配时，系统就认为这种行为是入侵。 </p><p>2、<strong>异常检测技术</strong>基于统计分析原理。首先总结正常操作应该具有的特征（用户轮廓），试图用定量的方式加以描述，当用户活动与正常行为有重大偏离时即被认为是入侵。 </p><h4 id="3-1-3-入侵响应"><a href="#3-1-3-入侵响应" class="headerlink" title="3.1.3.入侵响应"></a>3.1.3.入侵响应</h4><p>a.主动响应：入侵检测系统在检测到入侵后能够阻断攻击、影响进而改变攻击的进程。 </p><p>b.被动响应：入侵检测系统仅仅简单地报告和记录所检测出的问题。 </p><h3 id="3-3-IDS架构"><a href="#3-3-IDS架构" class="headerlink" title="3.3.IDS架构"></a>3.3.IDS架构</h3><p>事件产生器：它的目的是从整个计算环境中获得事件，并向系统的其他部分提供此事件。</p><p>事件分析器：分析数据，发现危险、异常事件，通知响应单元</p><p>响应单元：对分析结果作出反应</p><p>事件数据库：存放各种中间和最终数据</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml24796\wps29.png" alt="img"> </p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps30.jpg" alt="wps30"></p><h3 id="3-4-关于snort"><a href="#3-4-关于snort" class="headerlink" title="3.4.关于snort"></a>3.4.关于snort</h3><p> Snort是一个跨平台、轻量级的网络入侵检测工具，从入侵检测的分类上看，Snort应当属于基于网络的误用检测。针对每一种入侵行为，都提炼出它的特征并按照规范写成规则，从而形成一个规则库，将捕获的数据包对照规则库逐一匹配，若匹配成功，则认为该入侵行为成立。此外，Snort是开源的入侵检测系统，并具有很好的扩展性和可移植性。</p><p>Snort拥有三大基本功能：嗅探器、数据包记录器和入侵检测。嗅探器模式仅从网络上读取数据包并作为连续不断的流显示在终端上，常用命令snort-dev。数据包记录器模式是把数据包记录到硬盘上，常用命令snort-b。网络入侵检测模式是最复杂的，而且是可配置的。我们可以让Snort分析网络数据流以匹配用户定义的一些规则，并根据检测结果采取一定的动作。</p><h4 id="3-4-1-snort的体系结构"><a href="#3-4-1-snort的体系结构" class="headerlink" title="3.4.1.snort的体系结构"></a>3.4.1.snort的体系结构</h4><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps31.png" alt="wps31"></p><h4 id="3-4-1-snort规则"><a href="#3-4-1-snort规则" class="headerlink" title="3.4.1.snort规则"></a>3.4.1.snort规则</h4><p>Snort的每条规则都可以分成逻辑上的两个部分：规则头和规则体。</p><p>规则体的作用是在规则头信息的基础上进一步分析，有了它才能确认复杂的攻击(Snort的规则定义中可以没有规则体)。规则体由若干个被分别隔开的片断组成，每个片断定义了一个选项和相应的选项值。一部分选项是对各种协议的详细说明，包括IP、ICMP和TCP协议，其余的选项是：规则触发时提供给管理员的参考信息，被搜索的关键字，Snort规则的标识和大小写不敏感选项。</p><p><img src="/E:/git-blog\source\images\wps32.png" alt="img"> <img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml24796\wps33.jpg" alt="img"></p><h2 id="四．入侵检测系统功能模块介绍"><a href="#四．入侵检测系统功能模块介绍" class="headerlink" title="四．入侵检测系统功能模块介绍"></a><strong>四．</strong>入侵检测系统功能模块介绍</h2><p><strong>入侵检测模块：</strong></p><p><strong>功能：</strong>检测对计算机系统的非授权访问；对系统的运行状态进行监视，发现各种攻击企图、攻击行为或攻击结果，以保证系统资源的保密性、完整性和可用性；识别针对计算机系统和网络系统或广义上的信息系统的非法攻击，包括检测外部非法入侵者的恶意攻击或探测，以及内部合法用户越权使用系统资源的非法行为。</p><p><strong>所需软件：</strong>snort</p><p><strong>搭建该模块步骤：</strong>见方案搭建过程</p><p><strong>数据库存取模块：</strong></p><p>   <strong>功能：</strong>存取snort产生的相关日志信息及配置信息</p><p><strong>所需软件：</strong>mysql（存放数据）,banyard2（读取sonrt产生的数据并存储到数据库中）</p><p><strong>搭建该模块步骤：</strong>见方案搭建过程</p><p><strong>前端可视化展示模块：</strong></p><p><strong>功能：</strong></p><p>1.查询构建器和搜索界面，用于查找与警报元信息（例如签名、检测时间）以及底层网络证据（例如源/目标地址、端口、有效负载或标志）匹配的警报。</p><p>2.数据包查看器（解码器）将以图形方式显示记录的警报的第 3 层和第 4 层数据包信息。</p><p>3.警报管理，方法是提供构造以逻辑方式对警报进行分组以创建事件（警报组）、删除已处理的警报或误报、导出到电子邮件以进行协作或存档警报以在警报数据库之间传输警报。</p><p>4.根据时间、传感器、特征码、协议、IP 地址、TCP/UDP 端口或分类生成图表和统计信息。</p><p>5.能够分析各种事件，这些事件被后处理到其数据库中。</p><p><strong>所需软件：</strong>base</p><p><strong>搭建该模块步骤：</strong>见方案搭建过程</p><h2 id="五．数据流图"><a href="#五．数据流图" class="headerlink" title="五．数据流图"></a>五．数据流图</h2><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps34.png" alt="wps34"></p><h2 id="六．方案搭建过程"><a href="#六．方案搭建过程" class="headerlink" title="六．方案搭建过程"></a>六．方案搭建过程</h2><h3 id="6-1安装snort"><a href="#6-1安装snort" class="headerlink" title="6.1安装snort"></a>6.1安装snort</h3><p>6.1.1.首先，新建一个文件夹来保存需要的tar包的文件夹</p><p>#mkdir ~/snort_src</p><p>#cd ~/snort_src</p><p>6.1.2安装必备的组件</p><p>#sudo apt-get install -y build-essential libpcap-dev libpcre3-dev libdumbnet-dev bison flex zlib1g-dev liblzma-dev openssl libssl-dev</p><p><img src="/E:/git-blog\source\images\wps35.png" alt="img">以下是组件解释：</p><p>build-essential：提供用于编译软件的构建工具（GCC等）。</p><p>bison，flex：DAQ所需的解析器（DAQ将在下面安装）。</p><p>libpcap-dev：Snort所需的网络流量捕获库。</p><p>libpcre3-dev：支持Snort所需正则表达式的函数库。</p><p>libdumbnet-dev：libdnet库为几个低层网络例程提供了一个简化的可移植接口。许多安装Snort的指南都是从源代码安装此库的，尽管这不是必需的。</p><p>zlib1g-dev：Snort所需的压缩库。</p><p>liblzma-dev：提供对swf文件的解压缩（adobe flash）</p><p>openssl和libssl-dev：提供SHA和MD5文件签名</p><p>6.1.3.安装Nghttp2的开发库</p><p>#sudo apt-get install -y libnghttp2-dev</p><p>6.1.4.在snort官网下载数据采集器（DAQ）来抽象对数据包捕获库的调用</p><p>#cd ~/snort_src</p><p>#wget <a href="https://snort.org/downloads/snort/daq-2.0.7.tar.gz">https://snort.org/downloads/snort/daq-2.0.7.tar.gz</a>  </p><p>#tar -xvzf daq-2.0.7.tar.gz</p><p>#cd daq-2.0.7</p><p>#./configure</p><p>#make  #编译</p><p>#sudo make install #安装</p><p>6.1.5.源码安装snort</p><p>#cd ~/snort_src</p><p>#wget <a href="https://snort.org/downloads/snort/snort-2.9.20.tar.gz">https://snort.org/downloads/snort/snort-2.9.20.tar.gz</a></p><p>#tar -xvzf snort-2.9.20.tar.gz</p><p>#cd snort-2.9.20</p><p>#./configure –enable-sourcefire  </p><p>enable-sourcefire应该被添加到混合中，因为它也设置了一个标志用于条件编译。</p><p>#make</p><p>#sudo make install</p><p>6.1.6.更新共享库</p><p>#sudo ldconfig</p><p>6.1.7.Snort安装会将Snort二进制文件放在/ usr / local / bin / snort，因此，创建到/ usr / sbin / snort的符号链接</p><p>#sudo ln -s /usr/local/bin/snort /usr/sbin/snort </p><p>6.1.8安装后输入snort –V看到以下内容，安装snort完成</p><p><img src="/%5Cimages%5Cwps36.jpg" alt="img"> </p><h3 id="6-2将snort配置位NIDS"><a href="#6-2将snort配置位NIDS" class="headerlink" title="6.2将snort配置位NIDS"></a>6.2将snort配置位NIDS</h3><p>6.2.1. 基本配置：出于安全原因， Snort应该以非特权用户身份运行，创建一个****snort****用户和组</p><p>#sudo groupadd snort</p><p>#sudo useradd snort -r -s /sbin/nologin -c SNORT_IDS -g snort</p><p>6.2.2. 创建snort需要的文件和文件夹</p><p># 创建Snort目录:</p><p>#sudo mkdir /etc/snort</p><p>#sudo mkdir /etc/snort/rules</p><p>#sudo mkdir /etc/snort/rules/iplists</p><p>#sudo mkdir /etc/snort/preproc_rules</p><p>#sudo mkdir /usr/local/lib/snort_dynamicrules</p><p>#sudo mkdir /etc/snort/so_rules</p><p># 创建一些存储规则和ip列表的文件</p><p>#sudo touch /etc/snort/rules/iplists/black_list.rules</p><p>#sudo touch /etc/snort/rules/iplists/white_list.rules</p><p>#sudo touch /etc/snort/rules/local.rules</p><p>#sudo touch /etc/snort/sid-msg.map</p><p># 创建日志文件</p><p>#sudo mkdir /var/log/snort</p><p>#sudo mkdir /var/log/snort/archived_logs</p><p># 调整权限，对目前目录下的所有文件与子目录进行相同的权限变更，即以递归的方式逐个变更，使得此程序具有 root 的权限；拥有者有读取，写入，执行权限；组用户有读取，写入，执行权限；其他用户有 读取，执行权限</p><p>#sudo chmod -R 5775 /etc/snort</p><p>#sudo chmod -R 5775 /var/log/snort</p><p>#sudo chmod -R 5775 /var/log/snort/archived_logs</p><p>#sudo chmod -R 5775 /etc/snort/so_rules</p><p>#sudo chmod -R 5775 /usr/local/lib/snort_dynamicrules</p><p># 改变文件夹的所有权为snort组的snort用户，以便snort程序能够写入日志等数据</p><p>#sudo chown -R snort:snort /etc/snort</p><p>#sudo chown -R snort:snort /var/log/snort</p><p>#sudo chown -R snort:snort /usr/local/lib/snort_dynamicrules</p><p>6.2.3. 将解压后snort中的文件复制到我们新建的文件夹中</p><p>  #cd ~/snort_src/snort-2.9.20/etc/</p><p>#sudo cp <em>.conf</em> /etc/snort</p><p>#sudo cp *.map /etc/snort</p><p>#sudo cp *.dtd /etc/snort</p><p>  #cd ~/snort_src/snort-2.9.9.0/src/dynamic-#preprocessors/build/usr/local/lib/snort_dynamicpreprocessor/</p><p>#sudo cp * /usr/local/lib/snort_dynamicpreprocessor/</p><p>完成以上操作后/etc/snort/文件结构如下：</p><p><img src="/%5Cimages%5Cwps37.jpg" alt="img"> </p><p>6.2.4. 编辑snort配置文件</p><p>注释掉Snort导入默认规则文件集的行，因为我们暂时还没有引入相关规则，如果不注释掉的话就会报错</p><p>#sudo sed -i ‘s/include $RULE_PATH/include $RULE_PATH/‘ /etc/snort/snort.conf</p><p>修改snort.conf文件，如下</p><p> #配置网络信息，这里的IP是192.168.159.138，所以ip如下</p><p>ipvar HOME_NET 192.168.159.0/24</p><p><img src="/%5Cimages%5Cwps38.jpg" alt="img"> </p><p>我们需要告诉Snort我们之前创建的所有文件夹的位置。这些设置也是****snort.conf****文件的一部分</p><p><img src="/%5Cimages%5Cwps39.jpg" alt="img"> </p><p>#启用本地规则文件</p><p><img src="/%5Cimages%5Cwps40.jpg" alt="img"> </p><p>6.2.5测试snort</p><p>root@hui-virtual-machine:/etc/snort/rules# sudo snort -T -c /etc/snort/snort.conf -i ens33</p><p><img src="/%5Cimages%5Cwps41.jpg" alt="img"> </p><p>6.2.6.编辑规则文件，编写两条基本的规则如下：</p><p><img src="/%5Cimages%5Cwps42.jpg" alt="img"> </p><p>6.2.7.开始测试刚刚编写的规则</p><p>hui@hui-virtual-machine:/etc/snort/rules$ sudo snort -T -c /etc/snort/snort.conf                                            -i ens33</p><p><img src="/%5Cimages%5Cwps43.jpg" alt="img"> </p><p>开始检验，用一台别的主机ping snort的主机</p><p>#sudo /usr/local/bin/snort -A console -q -u snort -g snort -c /etc/snort/snort.conf -i ens33</p><p>可以看到如下结果，即警告信息如下：</p><p><img src="/%5Cimages%5Cwps44.jpg" alt="img"> </p><p>在规则中，没有关于ARP欺骗检测规则定义，但是可以通过snort的内置模块进行检测。具体配置如下：</p><p>在snort.conf文件中配置如下：</p><p><img src="/%5Cimages%5Cwps45.jpg" alt="img"> </p><p><img src="/%5Cimages%5Cwps46.jpg" alt="img"> </p><p>完成后使用kali进行ARP欺骗攻击</p><p><img src="/%5Cimages%5Cwps47.jpg" alt="img"> </p><p>再次回到被攻击机，发现攻击成功</p><p><img src="/%5Cimages%5Cwps48.jpg" alt="img"> </p><p>同时，我们也可以在这里发现ARP攻击警告信息如下：</p><p><img src="/%5Cimages%5Cwps49.jpg" alt="img"> </p><p>6.2.8.安装官方snort规则，添加其他的安全规则，这里使用snort官网上下载的community.rules，将下载来的community.rules复制到/etc/snort/rules目录下，如下：</p><p><img src="/%5Cimages%5Cwps50.jpg" alt="img"> </p><p>修改snort.conf，添加community.rules规则集，如下：</p><p><img src="/%5Cimages%5Cwps51.jpg" alt="img"> </p><p>查看规则集内容如下，可以看到所有的规则都被注释掉了，因此这里我们可以选择需要的规则取消注释</p><p><img src="/%5Cimages%5Cwps52.jpg" alt="img"> </p><h3 id="6-3-安装Barnyard2和配置Mysql"><a href="#6-3-安装Barnyard2和配置Mysql" class="headerlink" title="6.3.安装Barnyard2和配置Mysql"></a>6.3.安装Barnyard2和配置Mysql</h3><p>Barnyard2的作用是读取Snort产生的二进制事件文件(/var/log/snort/snort.log.XXXXXXXXXX)并存储到MySQL中。Snort的配置文件自身含有插件，它允许将Snort报警记录到MySQL中，但这样一来，系统数据会激增。当IDS系统检测到入侵行为时，它会用INSERT语句向数据库中写入数据，导致更新非常慢。所以如果直接将Snort输出到数据库，在数据量增大时这种方案的效率并不高，故使用外部代理将报警输出到Barnyard2。下一步，安装Barnyard2，这是一个专用的后台处理程序，将有助于减少Snort服务器上的负载</p><p>6.3.1安装一些必备组件</p><p>#sudo apt-get install -y mysql-server libmysqlclient-dev mysql-client autoconf libtool</p><p>6.3.2编辑snort.conf文件</p><p>#sudo vi /etc/snort/snort.conf</p><p>#添加一行以告诉Snort以二进制形式输出事件。即添加以下行并保存文件：output unified2: filename snort.u2, limit 128</p><p><img src="/%5Cimages%5Cwps53.jpg" alt="img"> </p><p>6.3.3接下来，安装Barnyard2</p><p>#cd ~/snort_src</p><p>#wget <a href="https://github.com/firnsy/barnyard2/archive/master.tar.gz">https://github.com/firnsy/barnyard2/archive/master.tar.gz</a> -O barnyard2-Master.tar.gz</p><p>#tar zxvf barnyard2-Master.tar.gz</p><p>#cd barnyard2-master</p><p>使用autoreconf来更新配置文件</p><p>#autoreconf -fvi -I ./m4 </p><p>Barnyard2需要访问****dnet.h****库，该库是我们先前与Ubuntu libdumbnet软件包一起安装的，创建一个链接</p><p>#sudo ln -s /usr/include/dumbnet.h /usr/include/dnet.h</p><p>#sudo ldconfig</p><p>根据系统结构，运行Barnyard2在MySQL的库（这里时64位的）</p><p>  #./configure –with-mysql –with-mysql-libraries=/usr/lib/x86_64-linux-gnu</p><p>   #make</p><p>#sudo make install</p><p>   测试barnyard2是否安装成功</p><p>   #barnyard2 –V</p><p><img src="/%5Cimages%5Cwps54.jpg" alt="img"> </p><p>为Snort配置为使用Barnyard2，从源程序包中复制一些文件</p><p>#sudo cp ~/snort_src/barnyard2-master/etc/barnyard2.conf /etc/snort/</p><p>#sudo mkdir /var/log/barnyard2</p><p>#sudo chown snort.snort /var/log/barnyard 赋予snort组snort用户操作该文件的权限</p><p>#sudo touch /var/log/snort/barnyard2.waldo</p><p>指定文件的拥有者改为指定的用户snort 组snort</p><p>#sudo chown snort.snort /var/log/snort/barnyard2.waldo </p><p>6.3.4. 创建数据库</p><p>#sudo mysql 进入数据库</p><p>mysql&gt; create database snort;</p><p>mysql&gt; use snort;</p><p>#导入barnyard2的数据库</p><p>mysql&gt; source ~/snort_src/barnyard2-master/schemas/create_mysql</p><p>mysql&gt; CREATE USER ‘snort‘@’localhost’ IDENTIFIED BY ‘123’;</p><p>#赋予数据库的部分操作权限给snort‘@’localhost</p><p>mysql&gt; grant create, insert, select, delete, update on snort.* to ‘snort‘@’localhost’; </p><p>mysql&gt; exit</p><p>6.3.5.创建数据库后，要将信息告诉Barnyard2，编辑barnyard2.conf文件</p><p>#sudo gedit /etc/snort/barnyard2.conf</p><p>在文件的末尾添加</p><p>output database: log, mysql, user=snort password=123 dbname=snort host=localhost sensor name=sensor01</p><p>然后运行如下命令：</p><p>sudo barnyard2 -c /etc/snort/barnyard2.conf -d /var/log/snort -f snort.log -w /var/log/snort/barnyard2.waldo -g snort -u snort</p><p>运行结果如图，等待数据传入</p><p><img src="/%5Cimages%5Cwps56.jpg" alt="img"> </p><p>再次ping 192.168.159.137,出现如下结果，可知数据已存入数据库：</p><p><img src="/%5Cimages%5Cwps57.jpg" alt="img"> </p><h3 id="6-4-安装base"><a href="#6-4-安装base" class="headerlink" title="6.4.安装base"></a>6.4.安装base</h3><p>创建可视化界面，这里使用的是base，base需要php5 </p><p>6.4.1.安装php5软件包</p><p>#sudo add-apt-repository ppa:ondrej/php</p><p>#sudo apt-get update</p><p>#sudo apt-get install -y apache2 libapache2-mod-php5.6 php5.6-mysql php5.6-cli php5.6 php5.6-common php5.6-gd php5.6-cli php-pear php5.6-xml</p><p>6.4.2.安装pear图像图</p><p>#sudo pear install -f –alldeps Image_Graph</p><p>6.4.3.下载安装adodb</p><p>#cd ~/snort_src</p><p>#wget <a href="https://sourceforge.net/projects/adodb/files/adodb-php5-only/adodb-520-for-#php5/adodb-5.20.8.tar.gz">https://sourceforge.net/projects/adodb/files/adodb-php5-only/adodb-520-for-#php5/adodb-5.20.8.tar.gz</a></p><p>#tar -xvzf adodb-5.20.8.tar.gz</p><p>#sudo mv adodb5 /var/adodb</p><p>#sudo chmod -R 755 /var/adodb</p><p>6.4.4.下载base并复制到apache2目录下</p><p>#cd ~/snort_src</p><p>#wget <a href="http://sourceforge.net/projects/secureideas/files/BASE/base-1.4.5/base-1.4.5.tar.gz">http://sourceforge.net/projects/secureideas/files/BASE/base-1.4.5/base-1.4.5.tar.gz</a></p><p>#tar xzvf base-1.4.5.tar.gz</p><p>#sudo mv base-1.4.5 /var/www/html/base/</p><p>6.4.5.创建和配置base文件</p><p>#cd /var/www/html/base</p><p>#sudo cp base_conf.php.dist base_conf.php</p><p>#sudo vi /var/www/html/base/base_conf.php</p><p>文件配置如下</p><p>$BASE_urlpath = ‘/base’;    </p><p>$DBlib_path = ‘/var/adodb/‘;  </p><p>$alert_dbname  = ‘snort’;   </p><p>$alert_host   = ‘localhost’;</p><p>$alert_port   = ‘’;</p><p>$alert_user   = ‘snort’;</p><p>$alert_password  = ‘123’;   </p><p><img src="/%5Cimages%5Cwps58.jpg" alt="img"> </p><p><img src="/%5Cimages%5Cwps59.jpg" alt="img"> </p><p><img src="/%5Cimages%5Cwps60.jpg" alt="img"> </p><p>修改base文件权限</p><p>#sudo chown -R www-data:www-data /var/www/html/base</p><p>#sudo chmod o-r /var/www/html/base/base_conf.php</p><p><img src="/%5Cimages%5Cwps61.jpg" alt="img"> </p><p>这里也可以不配置base文件，可以在<a href="http://localhost/base%E4%B8%AD%E8%AE%BE%E7%BD%AE">http://localhost/base中设置</a></p><p>6.4.6.重启apache</p><p>#sudo service apache2 restart</p><p>6.4.7浏览器打开 http：//localhost/base/index.php，可以看到如下结果:</p><p><img src="/%5Cimages%5Cwps62.jpg" alt="img"> </p><h2 id="七．测试编写的攻击检测规则"><a href="#七．测试编写的攻击检测规则" class="headerlink" title="七．测试编写的攻击检测规则"></a>七．测试编写的攻击检测规则</h2><p><img src="/%5Cimages%5Cwps63.jpg" alt="img"> </p><p>第一条规则：除192.168.159.10以外的主机网页访问本机都弹出警告；</p><p>第二条规则：当SYN包10秒出现1200个就弹出警告；</p><p>第三条规则：当ICMP包大于100就弹出警告；</p><p>第四条规则：当尝试获取主机的shell时，弹出警告；</p><p>第五条规则：当发生FIN扫描时弹出警告。</p><p>检验如下：</p><p>7.1.首先，验证第一条规则</p><p>alert tcp !192.168.159.10 any -&gt; $HOME_NET 80 (msg: “other want to get HTTP!!!”; classtype: attempted-user; sid: 1000002; rev: 1; priority: 1)</p><p>即除192.168.159.10以外的主机网页访问ubuntu</p><p><img src="/images%5Cwps64.jpg" alt="img"> </p><p>回到虚拟机，可以看到终端已弹出警告</p><p><img src="/%5Cimages%5Cwps65.jpg" alt="img"> </p><p>Web端也已经有记录</p><p><img src="/%5Cimages%5Cwps66.jpg" alt="img"> </p><p>7.2.现在验证第二条规则，alert tcp any any -&gt; $HOME_NET any (msg: “SYN flood!!!”; flags: S; threshold: type threshold,track by_dst,count 1200,seconds 10; classtype: attempted-dos ; sid: 1000006; rev: 1; priority: 2)</p><p>我们根据SYN泛洪攻击的特征，即短时间内发出大量的SYN包，造成资源的大量消耗而不能向正常的请求提供服务，那么我们可以在规则里写入10秒钟内包的数目达到了1200就弹出警告.</p><p>我们在攻击机kali运行hping3 -q -n -a 2.2.2.2 -S -s 53 –keep -p 631 –flood 192.168.159.138</p><p>查看到ubuntu已弹出警告</p><p><img src="/%5Cimages%5Cwps67.jpg" alt="img"> </p><p>7.3.现在验证第三条规则：alert icmp any any -&gt; $HOME_NET any (msg: “ICMP so big!!!”; classtype: icmp-event ; dsize: &gt;100; sid: 10000004; rev: 1)</p><p>通过查询资料我们发现对于一般的PING包来说，windows的ping包大小为32bit，Linux的ping包大小一般为64Bit，因此我们可以设定ping包的大小如果超过100bit的话，就弹出警示。</p><p>当ICMP包大于100就弹出警告；</p><p>用主机发送一个超过101大小的包</p><p><img src="/%5Cimages%5Cwps68.jpg" alt="img"> </p><p>查看ubuntu最近的15条记录，可以看到已经弹出了警告</p><p><img src="/%5Cimages%5Cwps69.jpg" alt="img"> </p><p>7.4.现在检验第四条规则，alert tcp any any -&gt; $HOME_NET 22 (msg: “other want to get SSL/SHELL!!!”; classtype: attempted-user ;threshold: type threshold,track by_dst,count 5,seconds 1; sid: 1000007; rev: 1;)</p><p>通过端口号来判断是否有SSH协议，但是如果只通过这个来判断是否有人连接了SSH又会产生误报，比如端口扫描也会扫描到22端口，经过抓包分析发现，完成一次SSH连接需要15到20个包，因此我们还要在规则里面写入当1秒钟收到5个SSH协议包的话就弹出警示，这样可以降低误报率。</p><p>连接ubuntu的shell,如下：</p><p><img src="/%5Cimages%5Cwps70.jpg" alt="img"> </p><p>查看警告信息，能查看到关于该规则的警告</p><p><img src="/%5Cimages%5Cwps71.jpg" alt="img"> </p><p>7.5.现在检验低五条规则，alert tcp any any -&gt; $HOME_NET any (msg: “namp FIN scan!!!”; flags: F;  threshold: type threshold,track by_dst,count 500,seconds 2;classtype: network-scan ; sid: 1000008; rev: 1; )，经过测试可以发现FIN扫描基本上在2分钟之内完成，扫描一般有1000多个端口，因此规则里面设置的频率为2分钟500个FIN包，则弹出警示。</p><p>用kali的nmap去扫描ubuntu的端口，如下：</p><p><img src="/%5Cimages%5Cwps72.jpg" alt="img"> </p><p>回到ubuntu就可以查看到该条规则的警告，如下：</p><p><img src="/%5Cimages%5Cwps73.jpg" alt="img"> </p><h2 id="八．遇到的问题"><a href="#八．遇到的问题" class="headerlink" title="八．遇到的问题"></a>八．遇到的问题</h2><p>5.1.在解包时出现如下错误，查到是dpkg的问题，需要更新软件，但是我的apt-get install命令出现了问题，最后发现是ubuntu 14.04版本过低，因此我重新安装了ubuntu18.04,就没有这个错误。</p><p><img src="/%5Cimages%5Cwps74.jpg" alt="img"> </p><p>5.2. 安装Barnyard2时，编译软件时报错, 详细的错误信息如下：</p><p><img src="/%5Cimages%5Cwps75.jpg" alt="img"> </p><p>解决办法：从错误信息看，是在处理configure.ac文件时出错了，认为AC_PROG_LIBTOOL是未定义的宏，使得执行autoconf失败，安装libtool包得以解决：sudo apt-get install libtool</p><p>5.3.数据库无法传入数据，即警告信息没有存入snort数据库的event里面，具体情况如下：</p><p><img src="/%5Cimages%5Cwps76.jpg" alt="img"> </p><p><img src="/%5Cimages%5Cwps77.jpg" alt="img"> </p><p>解决办法：进入barnyard2.conf文件做如下修改：</p><p><img src="/%5Cimages%5Cwps78.jpg" alt="img"> </p><p><img src="/%5Cimages%5Cwps79.jpg" alt="img"> </p><p>然后启动Snort和Barnyard2进行联合测试</p><p>执行sudo snort -q -u snort -g snort -c /etc/snort/snort.conf -i ens33 –D（“-D”参数表示以后台进程运行）</p><p>如果出现以下内容，则成功启动snort了：</p><p><img src="/%5Cimages%5Cwps80.jpg" alt="img"> </p><p>然后再重新执行的这条命令用于测试Barnyard2程序是否能正常执行：</p><p>sudo barnyard2 -c /etc/snort/barnyard2.conf -d /var/log/snort/ -f snort.log -w /var/log/snort/barnyard2.waldo -g snort -u snort -T</p><p>如出现以下结果，说明程序可以正常运行。</p><p><img src="/%5Cimages%5Cwps81.jpg" alt="img"> </p><p>然后运行如下命令：</p><p>sudo barnyard2 -c /etc/snort/barnyard2.conf -d /var/log/snort -f snort.log -w /var/log/snort/barnyard2.waldo -g snort -u snort</p><p>完成上述步骤后再执行传入警告信息的命令，就会是成功的。</p><p>5.4.安装pear图像图时，报错如下：php拓展没找到</p><p><img src="/%5Cimages%5Cwps82.jpg" alt="img"> </p><p>解决办法：查看ubuntu的默认php版本，发现和我们下载使用的版本不一样，因此找不到php拓展</p><p><img src="/%5Cimages%5Cwps83.jpg" alt="img"> </p><p>尝试重新设置默认php版本，步骤如下：</p><p>启用PHP5.6模块：$ sudo a2enmod php5.6</p><p>设置PHP5.6为默认版本：$ sudo update-alternatives –set php /usr/bin/php5.6</p><p>由于安装了其他PHP扩展，将它们设置为默认值：$ sudo update-alternatives –set phar /usr/bin/phar5.6</p><p>最后，重新启动Apache web服务器：$ sudo systemctl restart apache2</p><p>现在，检查PHP5.6是否为默认版本：$ php –v</p><p><img src="/%5Cimages%5Cwps84.jpg" alt="img"> </p><p>问题得以解决！！！</p><p>​    </p><p>5.5. 浏览器打开 http：//localhost/base/index.php，无法访问</p><p><img src="/%5Cimages%5Cwps85.jpg" alt="img"> </p><p>解决办法：检查设置本机的hosts为 127.0.0.1 localhost</p><p><img src="/%5Cimages%5Cwps86.jpg" alt="img"> </p><p>参考文献：</p><p><a href="http://www.kaiyuanba.cn/content/network/snort/Snortman.htm">Snort 中文手册 (kaiyuanba.cn)</a><img src></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;入侵检测系统构建&quot;&gt;&lt;a href=&quot;#入侵检测系统构建&quot; class=&quot;headerlink&quot; title=&quot;入侵检测系统构建&quot;&gt;&lt;/a&gt;入侵检测系统构建&lt;/h1&gt;&lt;h2 id=&quot;一．实验介绍&quot;&gt;&lt;a href=&quot;#一．实验介绍&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>流量分析与路由探测</title>
    <link href="http://example.com/2022/12/29/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E8%B7%AF%E7%94%B1%E6%8E%A2%E6%B5%8B/"/>
    <id>http://example.com/2022/12/29/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E8%B7%AF%E7%94%B1%E6%8E%A2%E6%B5%8B/</id>
    <published>2022-12-29T04:57:18.839Z</published>
    <updated>2023-02-09T19:52:13.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流量分析与路由探测"><a href="#流量分析与路由探测" class="headerlink" title="流量分析与路由探测"></a>流量分析与路由探测</h1><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理:"></a>实验原理:</h2><ol><li><strong>三次握手</strong></li></ol><p>主要是为了对每次发送的数据量进行跟踪与协商，确保数据段的发送和接收同步，根据所接收到的数据量而确认数据发送、接收完毕后何时撤消联系，并建立虚连接。</p><p><strong>第一次握手：</strong>建立连接时，客户端发送syn包（seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 </p><p><strong>第二次握手：</strong>服务器收到syn包，必须确认客户端的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。 </p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps1.png" alt="wps1"></p><p><strong>第三次握手：</strong>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功)状态，完成三次握手。 </p><p>完成三次握手，客户端与服务器开始传送数据</p><p>\2. <strong>四次挥手</strong></p><p>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。</p><p>由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p><p><strong>第一次挥手：</strong> TCP客户端发送一个FIN报文，用来关闭客户到服务器的数据传送。</p><p><strong>第二次挥手：</strong> 服务器收到这个FIN报文，它发回一个ACK报文，确认序号为收到的序号加1。和SYN一样，一个FIN报文将占用一个序号。</p><p><strong>第三次挥手：</strong>服务器关闭客户端的连接，发送一个FIN给客户端。</p><p><strong>第四次挥手</strong>： 客户端发回ACK报文确认，并将确认序号设置为收到序号加1。</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps2.png" alt="wps2"></p><p>\3. <strong>SSL协议握手</strong></p><p><strong>第一阶段：建立安全能力</strong></p><p>　　SSL握手的第一阶段启动逻辑连接，建立这个连接的安全能力。首先客户机向服务器发出client hello消息并等待服务器响应，随后服务器向客户机返回server hello消息，对client hello消息中的信息进行确认。Client hello消息包括Version，Random，Session id，Cipher suite，Compression method等信息。</p><p><strong>第二阶段：服务器鉴别与密钥交换</strong></p><p>　　服务器启动SSL握手第2阶段，是本阶段所有消息的唯一发送方，客户机是所有消息的唯一接收方。该阶段分为4步：</p><p>　　（a）证书：服务器将数字证书和到根CA整个链发给客户端，使客户端能用服务器证书中的服务器公钥认证服务器。</p><p>　　（b）服务器密钥交换（可选）：这里视密钥交换算法而定</p><p>　　（c）证书请求：服务端可能会要求客户自身进行验证。</p><p>　　（d）服务器握手完成：第二阶段的结束，第三阶段开始的信号</p><p><strong>第三阶段：客户机鉴别与密钥交换</strong>：</p><p> 客户机启动SSL握手第3阶段，是本阶段所有消息的唯一发送方，服务器是所有消息的唯一接收方。该阶段分为3步：</p><p>　　（a）证书（可选）：为了对服务器证明自身，客户要发送一个证书信息，这是可选的，在IIS中可以配置强制客户端证书认证。</p><p>　　（b）客户机密钥交换（Pre-master-secret）：这里客户端将预备主密钥发送给服务端，注意这里会使用服务端的公钥进行加密。</p><p>（c）证书验证（可选），对预备秘密和随机数进行签名，证明拥有（a）证书的公钥。</p><p>第四阶段：</p><p>客户机启动SSL握手第4阶段，使服务器结束。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps3.jpg" alt="wps3"></p><p>\4. <strong>路由探测</strong></p><p>路由探测原理就是从发送TTL 值为1开始的数据包开始，每次增加1，直到该数据包能抵达目的IP地址。</p><p>未能抵达最终目的地址的数据包，当路由器将值减为0 时，会给源地址返回一个数据包告知源地址：因经过路由的数据过多，导致TTL耗尽。数据包无法到达最终目的地。工具根据中间路由节点这个数据包返回的时间戳和发出数据包时的时间戳相减，计算出中间经过的每个路由节点的耗时。并获取中间路由节点的IP地址。</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤:"></a>实验步骤:</h2><h3 id="TCP连接和断开三次握手"><a href="#TCP连接和断开三次握手" class="headerlink" title="TCP连接和断开三次握手"></a>TCP连接和断开三次握手</h3><ol><li>打开wireshark，开启流量分析，进行一次网站访问，如访问cclab.ujs.edu.cn</li></ol><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps4.jpg" alt="wps4"></p><p>第一次握手：seq=0</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps5.jpg" alt="wps5"> </p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps6.jpg" alt="wps6"></p><p>  第二次握手：seq=0,ack=1</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps7.jpg" alt="wps7"></p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps8.jpg" alt="wps8"></p><p>  第三次握手：seq=1,ack=1</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps9.jpg" alt="wps9"></p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps10.jpg" alt="wps10"></p><p>  连接已建立，后面就是开始交互</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps11.jpg" alt="wps11"></p><p>2.四次挥手：</p><p>第一次挥手 FIN=1，seq=3251</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps12.jpg" alt="wps12"></p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps13.jpg" alt="wps13"></p><p>第二次挥手 seq=613 ,ack=3252</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps14.jpg" alt="wps14"></p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps15.jpg" alt="wps15"></p><p>第三次挥手 seq=613 ack =3252</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps16.jpg" alt="wps16"></p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps17.jpg" alt="wps17"></p><p>第四次挥手 seq=3252 ack=614</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps18.jpg" alt="wps18"></p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps19.jpg" alt="wps19"></p><h3 id="wireshark分析SSL握手情况"><a href="#wireshark分析SSL握手情况" class="headerlink" title="wireshark分析SSL握手情况"></a>wireshark分析SSL握手情况</h3><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps20.jpg" alt="wps20"></p><p>1.客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息![img]</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps21.jpg" alt="wps21"></p><p>\2. 服务器回答给客户端以下信息</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps22.jpg" alt="wps22"></p><p>3.服务器发送给客户端</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps23.jpg" alt="wps23"></p><p>4.客户端发送给服务端</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps24.jpg" alt="wps24"></p><p>\5. 服务器端发送new session ticket消息。到这里握手结束。</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps25.jpg" alt="wps25"></p><h3 id="利用ping测试链路情况、利用tracert测试路由"><a href="#利用ping测试链路情况、利用tracert测试路由" class="headerlink" title="利用ping测试链路情况、利用tracert测试路由"></a>利用ping测试链路情况、利用tracert测试路由</h3><p>1.ping百度获取ip</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps26.jpg" alt="wps26"></p><p>2.打开WinMTR，输入百度ip,获取各个节点的响应时间及丢包率等信息。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps27.jpg" alt="wps27"></p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/wps28.jpg" alt="wps28"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;流量分析与路由探测&quot;&gt;&lt;a href=&quot;#流量分析与路由探测&quot; class=&quot;headerlink&quot; title=&quot;流量分析与路由探测&quot;&gt;&lt;/a&gt;流量分析与路由探测&lt;/h1&gt;&lt;h2 id=&quot;实验原理&quot;&gt;&lt;a href=&quot;#实验原理&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件测试学习（一）——基础</title>
    <link href="http://example.com/2022/12/29/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2022/12/29/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-12-29T04:49:51.514Z</published>
    <updated>2023-02-09T19:57:53.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件测试是什么"><a href="#软件测试是什么" class="headerlink" title="软件测试是什么"></a>软件测试是什么</h2><p> 描述一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。换句话说，软件测试是一种实际输出与预期输出之间的 审核或者比较<a href="https://baike.baidu.com/item/%E8%BF%87%E7%A8%8B/8386928?fromModule=lemma_inlink">过程</a>。软件测试的经典定义是：在规定的条件下对程序进行<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C/5797370?fromModule=lemma_inlink">操作</a>，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。 </p><p>全面的评价软件测试质量可以从以下几个方面：功能测试，性能测试，兼容性测试，安全测试，网络测试，稳定性测试</p><h2 id="测试的工作内容"><a href="#测试的工作内容" class="headerlink" title="测试的工作内容"></a>测试的工作内容</h2><p>1.寻找软件中的bug，并且越早发现越好</p><p>2.确认bug的可重复性以及bug产生的步骤</p><p>3.确认bug是否被解决</p><p>4.测试方法，测试计划，测试平台，测试代码，测试用例，测试文档，测试报告的确定、编写和执行。</p><h2 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h2><p>1.按开发阶段划分</p><p>单元测试，集成测试，确认测试，系统测试，验收测试</p><p>2.按测试技术划分</p><p>黑盒测试，白盒测试，灰盒测试</p><p>3.按代码运行划分</p><p>静态测试，动态测试</p><p>4.按软件特性划分</p><p>功能测试，性能测试，安全性测试</p><p>5.按测试运行主体</p><p>手工测试，自动化测试</p><p>6.其他测试</p><p>回归测试，冒烟测试，随机测试，猴子测试</p><h2 id="测试过程模型"><a href="#测试过程模型" class="headerlink" title="测试过程模型"></a>测试过程模型</h2><p>1、V模型<br>   ●揭示了开发过程与测试过程中各阶段的对应关系</p><p>   ●缺点与不足</p><pre><code>     （1）v模型仅仅把测试过程作为在需求分析、系统设计及编码之后的一个阶段，忽视了测试对需求分析、系统设计的验证；     （2）需求的满足情况一直拖到后期的验收测试才被验证；     （3）没有体现出“尽早地和不断地进行软件测试”的原则。</code></pre><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/20200918231357450.png" alt="img"> </p><p>​               </p><p>2、W模型<br>   ●由两个v字型模型组成，分别代表测试与开发过程，明确表示出了测试与开发的并行关系</p><p>   ●优点</p><pre><code>   （1）测试的活动与软件开发同步进行   （2）测试对象不仅仅是程序，包括需求和设计   （3）尽早发现软件缺陷可降低软件开发的成本</code></pre><p>   ●局限性</p><pre><code>     在w模型中，需求、设计、编码等活动被视为串行的，这样就无法支持灵活的迭代。</code></pre><p>​              <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/20190506180516154.png" alt="img"> </p><p>3、H模型<br>H模型中，软件的测试活动从开发中独立出来，形成一个独立的流程，贯穿整个软件周期。H模型中每个测试活动的主要流程如下：</p><p>随软件周期开始，进入测试准备阶段（用例、文档、代码等）。<br>软件开发活动持续为软件测试提供准备材料，直到达到测试就绪点。<br>测试执行。<br>             <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/aHR0cHM6Ly9jenBjYWxtLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS90eXBvcmEvMjAxOTExMjMwMDU2MDUtODUyNTk2LnBuZw.png" alt="img"> </p><p>4、X模型<br>X模型提出先对程序片段进行独立的测试和编码，再进行频繁的交换，通过集成形成可执行程序（左边部分）。集成的可执行程序进行集成测试，通过集成测试的程序可能成为更大范围集成的一部分，也可能（形成最终产品时）封版提交给客户（右上部分）。另外，可以对集成的程序进行测试计划外的探索性测试（右下部分）。</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS92Mi1hMDcxZGE0ZWJhNDJiZDQ0YWJkYjllYmI3ZmNjOTljY18xMjAweDUwMC5qcGc.png" alt="img"> </p><h2 id="测试的流程"><a href="#测试的流程" class="headerlink" title="测试的流程"></a>测试的流程</h2><p>需求分析，设计评审，制定测试策略，设计和执行测试用例，进行缺陷跟踪，质量风险分析</p><p>更细一点：需求测试-&gt;概要设计测试-&gt;详细设计测试-&gt;单元测试-&gt;集成测试-&gt;系统测试-&gt;验收测试</p><h3 id="分析测试需求"><a href="#分析测试需求" class="headerlink" title="分析测试需求"></a>分析测试需求</h3><h3 id="制定测试计划"><a href="#制定测试计划" class="headerlink" title="制定测试计划"></a>制定测试计划</h3><p>测试计划一般要做好以下工作安排。</p><p>①确定测试范围：明确哪些对象是需要测试的，哪些对象不是需要测试的。</p><p>② 制定测试策略：测试策略是测试计划中最重要的部分，它将要测试的内容划分出不同的优先级，并确定测试重点。根据测试模块的特点和测试类型（如功能测试、性能测试）选定测试环境和测试方法（如人工测试、自动化测试）。</p><p>③安排测试资源：通过对测试难度、时间、工作量等因素对测试资源合理安排，包括人员分配、工具配置等。</p><p>④安排测试进度：根据软件开发计划、产品的整体计划来安排测试工作的进度，同时还要考虑各部分工作的变化。在安排工作进度时，最好在各项测试工作之间预留一个缓冲时间以应对计划变更。</p><p>⑤预估测试风险：罗列出测试工作过程中可能会出现的不确定因素，并制定应对策略。</p><h4 id="1-编写目的"><a href="#1-编写目的" class="headerlink" title="1.编写目的"></a>1.编写目的</h4><p>此文档根据项目需求文档，制定测试策略、评估测试风险，确定所需的资源，并对测试的工作量进行估计，进行人员和进度安排，并且列出测试项目的可交付元素。</p><h4 id="2-参考文档"><a href="#2-参考文档" class="headerlink" title="2.参考文档"></a>2.参考文档</h4><p>详细设计文档，设计原型</p><h4 id="3-测试概要"><a href="#3-测试概要" class="headerlink" title="3.测试概要"></a>3.测试概要</h4><p>（1）测试目标<br>通过测试，达到以下目标：测试已实现的产品是否达到设计的要求，包括：各个功能点是否以实现，业务流程是否正确。产品规定的操作和系统运行稳定。Bug数和缺陷率控制在可接收的范围之内，遗留BUG一般不超过所有BUG的10%<br>（2）测试范围<br>列出测试最终需要交付的功能模块列表<br>（3）测试人力资源<br>（4）测试环境：服务器环境，终端环境，网络环境<br>（5）bug管理工具</p><h4 id="4-测试规范"><a href="#4-测试规范" class="headerlink" title="4.测试规范"></a>4.测试规范</h4><p>开始测试标准：代码编译通过，软件可以争取安装运行，实现功能与产品设计出人，冒烟测试通过<br>中断测试标准：安装无法正确完成，程序代码编译不通过，系统服务异常，发现阻塞功能的bug</p><h4 id="5-bug规范"><a href="#5-bug规范" class="headerlink" title="5.bug规范"></a>5.bug规范</h4><p>致命，严重，一般，建议</p><h4 id="6-测试策略"><a href="#6-测试策略" class="headerlink" title="6.测试策略"></a>6.测试策略</h4><p>冒烟测试-迭代测试（先功能后性能，回归测试）-发布测试</p><p><strong>冒烟测试：</strong>依据开发提测时间变动<br>第一轮功能测试：执行测试用例，包括边界值测试，兼容性测试，易用性测试，用户界面测试，安全性测试<br>第二轮功能测试：bug复测及功能验证<br><strong>回归测试：</strong>全面回归测试<br>性能测试：需确认具体性能测试方案和工具<br><strong>发布测试</strong></p><h4 id="7-测试风险"><a href="#7-测试风险" class="headerlink" title="7.测试风险"></a>7.测试风险</h4><p>测试本身（测试时间/测试技术/开发进度延误/难以修复缺陷/其它原因）</p><h4 id="8-测试输出文档"><a href="#8-测试输出文档" class="headerlink" title="8.测试输出文档"></a>8.测试输出文档</h4><p>测试计划<br>测试用例<br>测试bug单<br>测试报告</p><h3 id="编写测试用例"><a href="#编写测试用例" class="headerlink" title="编写测试用例"></a>编写测试用例</h3><p>①测试用例（Test Case）指的是一套详细的测试方案，包括测试环境、测试步骤、测试数据和预期结果。不同的公司会有不同的测试用例模板，虽然它们在风格和样式上有所不同，但本质上是一样的，都包括了测试用例的基本要素。</p><p>②测试用例编写的原则是尽量以最少的测试用例达到最大测试覆盖率。</p><h4 id="1-设计方法："><a href="#1-设计方法：" class="headerlink" title="1.设计方法："></a>1.设计方法：</h4><p><strong>等价类划分法</strong>（将测试的范围划分成几个互不相交的子集）：</p><p> 等价类划分是把所有可能的输入数据，即程序的输入域划分成若干部分（子集），然后从每一个子集中选取少数具有代表性的数据作为测试用例。测试某等价类的代表值就等于对这一类其它值的测试。因此，可以把全部输入数据合理划分为若干等价类，在每一个等价类中取一个数据作为测试的输入条件，就可以用少量代表性的测试数据，取得较好的测试结果。 </p><p><strong>边界值分析法</strong>（选出的测试用例，应选取正好等于、刚刚大于、刚刚小于边界的值）<br><strong>错误推测法</strong>（在测试程序时，人们可以根据经验或直觉推测程序中可能存在的各种错误）</p><p><strong>因果图法</strong></p><p><strong>判定表法</strong>（适合于逻辑判断复杂的场景，通过穷举条件获得结果，对结果再进行优化合并，会得到一个判断清晰的策略）<br><strong>正交实验法</strong>（在各因素互相独立的情况下，设计出一种特殊的表格，找出能以少数替代全面的测试用例）<br>还有其它场景法，功能图法和状态迁移法等</p><h4 id="2-测试用例八要素"><a href="#2-测试用例八要素" class="headerlink" title="2.测试用例八要素"></a>2.测试用例八要素</h4><p>（1） 用例编号（规则：由字符和数字组成的字符串，具有唯一性，易识别性）<br>（2） 测试项目（对应测试用例编号中的测试子项名 系统测试<br>（3） 测试标题（体现测试出发点关注点以及测试用例期盼的测试结果）<br>（4） 重要级别、优先级别（重要级别一般分为高中低 ）<br>（5） 预置条件：测试用例在执行时需要满足一些前提条件，环境的设置<br>（6） 测试输入（测试执行中需要加工的外部信息，避免用描述性语言，要具体，根据测试用例具体情况，有手工输入，文件，数据库记录）<br>（7） 操作步骤：执行当前用例需要经过的操作步骤，需要明确的给出每一个步骤的描述<br>（8） 预期输出：需要判断测试对象是否正常工作</p><h3 id="执行测试阶段"><a href="#执行测试阶段" class="headerlink" title="执行测试阶段"></a>执行测试阶段</h3><p>①测试执行就是按照测试用例执行测试的过程，这是测试人员最主要的活动阶段。</p><p>②在执行测试时要根据测试用例的优先级进行。</p><p>③在执行测试过程中，测试人员要密切跟踪测试过程，记录缺陷、形成报告等，这一阶段是测试人员最重要的工作阶段。</p><p>大部分的测试执行可以采用自动化的方式减少工作量</p><h4 id="1-测试环境搭建"><a href="#1-测试环境搭建" class="headerlink" title="1.测试环境搭建"></a>1.测试环境搭建</h4><p>测试环境分为硬件环境和软件环境<br><strong>硬件环境：</strong>测试必须的服务器，客户端，网络连接设备，以及打印机/扫描仪等辅助硬件设备构成的环境<br><strong>软件环境：</strong>被测软件运行的操作系统，数据库以及其它应用软件构成的环境<br>搭建测试环境的准备工作：<br>安装工具：虚拟机<br>虚拟机优点：运行在主机上 </p><h4 id="2-执行测试用例"><a href="#2-执行测试用例" class="headerlink" title="2.执行测试用例"></a>2.执行测试用例</h4><p>又分为web测试，app测试，接口测试</p><p>根据测试<strong>用例优先级</strong>来执行测试用例</p><ol><li><strong>根据UI效果图进行UI测试</strong></li></ol><p>（1）观察APP的用户界面(如菜单、对话框、窗口和其它可规控件)是否符合UI稿</p><p>（2）不同的连接页面之间导航链接是否有效，是否跳转是否正确</p><p>（3）旋转手机，确保程序不退出，页面排版无异常</p><p>（5）输入框说明文字的内容与产品需求一致</p><p>（6）某页无数据时、断网时、有网但接口异常时的状态页是否和UI一致</p><ol start="2"><li><p><strong>功能测试时主要依据编写的功能测试用例进行软件功能的测试</strong></p></li><li><p><strong>涉及的测试主要包括基本功能测试，逻辑测试，安装、卸载、运行测试，中断测试，异常处理（包括网络突然断开或者网速过慢、机器内存不足等异常情况的处理）测试</strong></p></li></ol><p>（1）App安装完成后是否能正常启动，且打开速度控制在预期时间内</p><p>（2）切换后台再切换前台的操作对当前状态如登陆、当前页、数据刷新的影响</p><p>（3）强制杀掉APP进程再启动对当前状态如登陆、当前页、数据刷新的影响</p><p>（4）登陆验证/免密登陆时的手势密码和指纹是否正常符合产品需求</p><p>（5）对于有数据交换的页面，每个页面都必需要进行前后台切换、锁屏解锁的测试，这种页面最容易出现崩溃</p><p>（6）同一用户在多个终端先后登陆时，APP是否有正常符合产品需求的处理</p><p>（7）App使用过程中有电话进来的中断测试，与文件下载、音乐播放、等应用的交叉情况测试</p><p>（8）很多应用会支持缓存数据，测试在断网启动或从有网到无网时是否可以浏览缓存数据</p><p>（9）软件在不同操作系统及版本（Android、iOS、）下安装是否正常</p><p>（10）软件安装后的是否能够正常运行，安装后的文件夹及文件是否写到了指定的目录里，安装后没有生成多余的目录结构和文件</p><p>（11）软件安装过程是否可以取消</p><p>（12）软件安装过程中意外情况的处理是否符合需求（如死机，重启，断电）</p><p>（13）安装空间不足时是否有相应提示</p><p>（14）对于需要通过网络验证之类的安装，在断网情况下尝试一下</p><p>（15）重复安装应该有提示iOS没有提示</p><p>（16）升级安装时，版本更新链接有效，比如后台设置的版本白名单</p><p>（17）使用各种方式卸载程序，如直接删除安装文件夹卸载是否有提示信息、长按图标卸载、手机设置里卸载、第三方应用卸载iOS卸载没有提示，Android安装时会闪退（偶现）</p><p>（18）测试卸载后文件是否全部删除所有的安装文件夹</p><p>（19）卸载过程中出现的意外情况的测试（如死机、断电、重启）</p><p>（20）卸载是否支持取消功能，单击取消后软件卸载的情况</p><ol start="4"><li><strong>兼容性及适配测试</strong></li></ol><p>（1）硬件的适配：不同手机厂商、硬件性能，不同屏幕大小的适配；</p><p>如：厂商：华为，型号：mate30Pro，Android版本：Android10，屏幕：6.0英寸，分辨率：2400x1176像素</p><p>厂商：苹果，型号：苹果XSmax,手机版本：iOS11，屏幕：6.0英寸，分辨率：2688x1224像素</p><p>（2） iOS版本的兼容：IOS 6版本以上；Andriod 5版本以上等</p><p>（3） 不同分辨率屏幕的适配：移动设备的分辨率多种多样，如果app没有做比较合适的处理就可能会显示不好，甚至影响功能的操作。</p><p>（4） 兼容性测试必须在一定数量的真机上进行，由于真机类型过多，尤其Android在做兼容性测试时，可以选取典型的几种运用较多的真机，进行兼容性测试</p><p>（5）与本机已经安装的App是否兼容</p><p>（6）在各种系统、系统版本的不同手机上测试登陆，卸载，注册，登陆，修改密码等功能</p><p>（7）UI层的兼容，界面的显示根据不同尺寸手机是否自适应</p><p>（8）在各种系统、系统版本的不同手机上进行全方面的功能测试，如：使用每一个iOS版本的iPhone上测试“我的银行卡”模块的提现功能</p><p>（9）基于开发环境和生产环境的不同，检验在各种网络连接下(WiFi、2G/3G/4G/5G等)，App的数据和运用是否正确</p><ol start="5"><li><p><strong>安全性测试</strong></p></li><li><p>软件权限 </p></li></ol><p>（1）扣费风险：包括短信、拨打电话、连接网络等</p><p>（2）限制/允许使用手机拍照或录音</p><p>（3）限制/允许使用手机读取用户数据，手机信息、联系人信息等</p><p>（4）限制/允许使用手机写入用户数据 </p><p>（5）没有用户的允许, 应用程序不能预先设定自动启动</p><p>（6）对App的输入有效性校验、认证、授权、数据加密等方面进行检测 </p><p>（7）没有用户的允许, 应用程序不能预先设定自动启动</p><p>（8）手机能控制该APP能否使用Wi-Fi和移动数据</p><p>​       2.数据安全性 </p><p>（1）如果数据库中重要的数据正要被重写，应及时告知用户 </p><p>（2）在数据删除之前，应用程序应当通知用户或者应用程序提供一个“取消”命令的操作。 </p><p>（3）对密码长度和复杂度的安全要求</p><p>（4）当将密码或其他的敏感数据输人到应用程序时, 其不会被储存在设备中, 同时密码也不会被解码</p><p>（5）当应用程序处理明细或其它的敏感数据时，不以明文形式将数据写到其他单独的文件或者临时文件中</p><ol start="6"><li><strong>接口测试</strong></li></ol><p>（1）测试api网关接口是否请求正常</p><p>（2）Get,post发送和返回是否请求正常</p><p>（3）查看请求参数和返回参数结果是否正常</p><p>（测试接口工具：APIpost jmeter）</p><ol start="7"><li><strong>性能测试</strong></li></ol><p>（1） 客户端性能测试重点关注：安装卸载时间、启动时间、页面加载时间、主要功能占用的CPU、内存、流量、耗电量等，以及与同类产品相比较是否有优势；</p><p>（2） 运行过程中主要功能占用的CPU、内存、流量等可以借助开源工具emmagee（适用于Android）获取到；</p><p>（4） 至于服务器端的性能，主要利用接口对服务器施加压力，重点关注响应时间、吞吐量、并发数、事物通过率等，可以用loadrunner、jmeter进行测试，也可以用fiddler Charles抓包来查看域名等是否正常。</p><ol start="8"><li><strong>核心链路</strong></li></ol><p>——-核心链路测试</p><h4 id="3-测试执行流程"><a href="#3-测试执行流程" class="headerlink" title="3.测试执行流程"></a>3.测试执行流程</h4><p>冒烟测试-迭代测试（先功能后性能，回归测试）-发布测试<br>注：对应测试产出对应测试报告和bug清单，可以把bug提到缺陷管理库（例如禅道）里</p><h3 id="编写测试报告"><a href="#编写测试报告" class="headerlink" title="编写测试报告"></a>编写测试报告</h3><p>一份完整的测试报告必须要包含以下几个要点。</p><p>① 引言：测试报告编写目的、报告中出现的专业术语解释及参考资料等。</p><p>②测试概要：介绍项目背景、测试时间、测试地点及测试人员等信息。</p><p>③ 测试内容及执行情况：描述本次测试模块的版本、测试类型，使用的测试用例设计方法及测试通过覆盖率，依据测试的通过情况提供对测试执行过程的评估结论，并给出测试执行活动的改进建议，以供后续测试执行活动借鉴参考。</p><p>④缺陷统计与分析：统计本次测试所发现的缺陷数目、类型等，分析缺陷产生的原因给出规避措施等建议，同时还要记录残留缺陷与未解决问题。</p><p>⑤ 测试结论与建议：从需求符合度、功能正确性、性能指标等多个维度对版本质量进行总体评价，给出具体明确的结论。</p><hr><p>参考资料：</p><p><a href="https://blog.csdn.net/weixin_49164248/article/details/121027120">https://blog.csdn.net/weixin_49164248/article/details/121027120</a></p><p><a href="https://blog.csdn.net/weixin_43750377/article/details/114066222?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167227571616782425679079%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167227571616782425679079&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-114066222-null-null.142%5Ev68%5Epc_rank_34_queryrelevant25,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_control2&amp;utm_term=%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95&amp;spm=1018.2226.3001.4">https://blog.csdn.net/weixin_43750377/article/details/114066222?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167227571616782425679079%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167227571616782425679079&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-114066222-null-null.142^v68^pc_rank_34_queryrelevant25,201^v4^add_ask,213^v2^t3_control2&amp;utm_term=%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95&amp;spm=1018.2226.3001.4</a></p><p> <a href="https://blog.csdn.net/jinglin1100/article/details/121610397?ops_request_misc=%7B%22request_id%22:%22167227611716800213057804%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167227611716800213057804&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-121610397-null-null.142%5Ev68%5Epc_rank_34_queryrelevant25,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_control2&utm_term=%E6%B5%8B%E8%AF%95&spm=1018.2226.3001.4187">史上最全测试流程详解—-超详细_你泡不上的大林的博客-CSDN博客_测试流程</a> </p><p><a href="https://blog.csdn.net/jinglin1100/article/details/121610397">https://blog.csdn.net/jinglin1100/article/details/121610397</a></p><p><a href="https://blog.csdn.net/qq_60168783/article/details/125003521">https://blog.csdn.net/qq_60168783/article/details/125003521</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;软件测试是什么&quot;&gt;&lt;a href=&quot;#软件测试是什么&quot; class=&quot;headerlink&quot; title=&quot;软件测试是什么&quot;&gt;&lt;/a&gt;软件测试是什么&lt;/h2&gt;&lt;p&gt; 描述一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。换句话说，软件测试是一种实际输出与预</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网站架构</title>
    <link href="http://example.com/2022/07/13/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"/>
    <id>http://example.com/2022/07/13/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/</id>
    <published>2022-07-13T13:29:28.230Z</published>
    <updated>2023-02-09T20:17:16.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网站架构"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构</h1><h2 id="中小型架构图"><a href="#中小型架构图" class="headerlink" title="中小型架构图"></a>中小型架构图</h2><h2 id="大型架构图"><a href="#大型架构图" class="headerlink" title="大型架构图"></a>大型架构图</h2><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/1657718083166.png" alt="1657718083166"></p><h2 id="模块解释"><a href="#模块解释" class="headerlink" title="模块解释"></a>模块解释</h2><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p> 国<a href="https://so.csdn.net/so/search?q=%E5%86%85%E7%BD%91&spm=1001.2101.3001.7020">内网</a>络分布主要南电信北联通，造成跨地区访问延迟大问题，对于有一定访问量网站来说，增加CDN（内容分发网络）层可有效改善此现象，也是网站加速的最好选择。CDN把网站页面缓存到全国分布的节点上，用户访问时从最近的机房获取数据，这样大大减少网络访问的路径。 </p><h3 id="反向代理（网页缓存）"><a href="#反向代理（网页缓存）" class="headerlink" title="反向代理（网页缓存）"></a>反向代理（网页缓存）</h3><p>如果<a href="https://so.csdn.net/so/search?q=CDN&spm=1001.2101.3001.7020">CDN</a>没有缓存要请求的数据则向这层发起请求，在代理服务器配置缓存功能（本地），代理服务器就查找本地缓存是否有CDN请求的数据，如果有就直接返回给CDN，如果没有则请求后端负载均衡器然后转发给WEB服务器返回数据给代理服务器，代理服务器再将结果给CDN。代理服务器一般缓存不经常变动的静态页面，如image、js、css、html等，主流的缓存软件有Squid、Varnish、Nginx。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>访问量较大的网站都会用到负载均衡，因为这是解决单台服务器性能瓶颈的最好办法。反向代理将请求转发给负载均衡器，负载均衡器根据算法（轮训、负载情况选择后端等）交给后端WEB服务处理，WEB服务处理完成后直接返回数据给反向代理服务器。负载均衡合理分配请求给后端多台WEB服务器，减轻单台服务器并发负载，并保证服务可用性。主流的负载均衡软件有LVS、HAProxy、Nginx。</p><p> 通过负载均衡调度服务器，可以将来自用户浏览器的访问请求分发到应用服务器集群中的任何一台服务器上，如果有更多用户，就在集群中加入更多的应用服务器，使应用服务器的压力不再成为整个网站的瓶颈。 </p><h3 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h3><p>大型网站为了应对日益复杂的业务场景，通过使用分而治之的手段将整个网站业务分成不同的产品线。如大型购物交易网站都会将首页、商铺、订单、买家、卖家等拆分成不同的产品线，分归不同的业务团队负责。</p><p>具体到技术上，也会根据产品线划分，将一个网站拆分成许多不同的应用，每个应用独立部署。应用之间可以通过一个超链接建立关系（在首页上的导航链接每个都指向不同的应用地址），也可以通过消息队列进行数据分发，当然最多的还是通过访问同一个数据存储系统来构成一个关联的完整系统</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p> 网站使用的缓存一般分为缓存到应用服务器或者缓存在专门的分布式缓存服务器。缓存到应用服务器自己的访问速度快很多，但是受自身内存限制，往往不太适用。远程分布式缓存使用一个集群专门负责缓存服务，当内存不够还可以轻松得动态扩容。 </p><h3 id="使用应用服务器集群改善网站的并发处理能力"><a href="#使用应用服务器集群改善网站的并发处理能力" class="headerlink" title="使用应用服务器集群改善网站的并发处理能力"></a>使用应用服务器集群改善网站的并发处理能力</h3><p> 使用缓存后，数据访问压力得到了缓解，但是单一应用服务器能够处理的请求连接有限，在网站访问高峰期，应用服务器就成了整个网站的效率瓶颈。使用分布式集群是网站解决高并发、海量数据问题的常用手段。当一台服务器的处理能力和存储空间不足时，不要尝试去更换更强大的服务器，对大型网站而言，多么强大的服务器，都满足不了网站持续增长的业务需求。这种情况下，更恰当的做法是增加一台服务器分担原有服务器的访问及存储压力。 对网站架构而言，只要能通过增加一台服务器的方式改善负载压力，就可以以同样的方式持续增加服务器不断改善系统性能，从而实现系统的可伸缩性。应用服务器实现集群是网站可伸缩架构设计中较为简单成熟的一种 </p><h3 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h3><p>网站在使用缓存后，使对大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作（缓存访问不命中、缓存过期）和全部的写操作都需要访问数据库，在网站的用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。 目前大部分的主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到另一台服务器上。网站利用数据库的这一功能，实现数据库读写分离，从而改善数据库负载压力。如下图所示：</p><p>应用服务器在写数据的时候，访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库，这样当应用服务器读数据的时候，就可以通过从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离对应用透明。</p><h3 id="分布式文件系统和分布式数据库系统"><a href="#分布式文件系统和分布式数据库系统" class="headerlink" title="分布式文件系统和分布式数据库系统"></a>分布式文件系统和分布式数据库系统</h3><p>数据库经过读写分离后，从一台服务器拆分成两台服务器，但是随着网站业务的发展依然不能满足需求，这时需要使用分布式数据库，文件系统也是一样，需要使用分布式文件系统。分布式数据库是网站数据库拆分的最后手段，只有在单表规模非常大的时候才用。不到不得已时，网站更常用的数据库拆分手段是业务分库，将不同业务的数据库部署在不同的物理服务器上。</p><h3 id="使用NoSQL和搜索引擎"><a href="#使用NoSQL和搜索引擎" class="headerlink" title="使用NoSQL和搜索引擎"></a>使用NoSQL和搜索引擎</h3><p>随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂，网站需要采用一些非关系数据库技术如NoSQL和非数据库查询技术如搜索引擎。</p><p>NoSQL的搜索引擎都是源自互联网的技术手段，对可伸缩的分布式特性具有更好的支持。应用服务器则通过一个统一的数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。</p><h3 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h3><p>随着业务拆分越来越小，存储系统越来越庞大，应用系统的整体复杂度呈指数级增加，部署维护越来越困难。由于所有应用要和所有数据库系统连接，在数万台服务器规模的网站中，这些连接的数目是服务器规模的平方，导致数据库连接资源不足，拒绝服务。</p><p>既然每一个应用系统都需要执行许多相同的业务操作，比如用户管理、商品管理等，那么可以将这些共用的业务提取出来，独立部署。由这些可复用的业务连接数据库，提供共用业务服务，而应用系统只需要管理用户界面，通过分布式服务调用共用业务服务完成具体业务操作。</p><h2 id="常用的web服务器"><a href="#常用的web服务器" class="headerlink" title="常用的web服务器"></a>常用的web服务器</h2><p>参考来源： <a href="https://blog.csdn.net/sin_geek/article/details/50036361?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-50036361-blog-84809050.pc_relevant_multi_platform_whitelistv1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-50036361-blog-84809050.pc_relevant_multi_platform_whitelistv1&utm_relevant_index=1">(85条消息) 中小型网站架构分析及优化_Sin_Geek的博客-CSDN博客</a> </p><p><a href="https://blog.csdn.net/apriaaaa/article/details/97780794">https://blog.csdn.net/apriaaaa/article/details/97780794</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网站架构&quot;&gt;&lt;a href=&quot;#网站架构&quot; class=&quot;headerlink&quot; title=&quot;网站架构&quot;&gt;&lt;/a&gt;网站架构&lt;/h1&gt;&lt;h2 id=&quot;中小型架构图&quot;&gt;&lt;a href=&quot;#中小型架构图&quot; class=&quot;headerlink&quot; title=&quot;中小型架构</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基于linux的snort部署搭建及搭建过程中遇到的问题</title>
    <link href="http://example.com/2022/07/13/%E5%9F%BA%E4%BA%8Elinux%E7%9A%84snort%E9%83%A8%E7%BD%B2%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/07/13/%E5%9F%BA%E4%BA%8Elinux%E7%9A%84snort%E9%83%A8%E7%BD%B2%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2022-07-13T09:24:37.941Z</published>
    <updated>2023-02-09T19:33:57.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h2><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image002.png" alt="clip_image002"></p><h2 id="方案搭建过程"><a href="#方案搭建过程" class="headerlink" title="方案搭建过程"></a>方案搭建过程</h2><h3 id="6-1安装snort"><a href="#6-1安装snort" class="headerlink" title="6.1安装snort"></a>6.1安装snort</h3><p>6.1.1.首先，新建一个文件夹来保存需要的tar包的文件夹</p><p>#mkdir ~/snort_src</p><p>#cd ~/snort_src</p><p>6.1.2安装必备的组件</p><p>#sudo apt-get install -y build-essential libpcap-dev libpcre3-dev libdumbnet-dev bison flex zlib1g-dev liblzma-dev openssl libssl-dev</p><p><img src="/E:/git-blog\source\images\clip_image003.png" alt="img">以下是组件解释：</p><p>build-essential：提供用于编译软件的构建工具（GCC等）。</p><p>bison，flex：DAQ所需的解析器（DAQ将在下面安装）。</p><p>libpcap-dev：Snort所需的网络流量捕获库。</p><p>libpcre3-dev：支持Snort所需正则表达式的函数库。</p><p>libdumbnet-dev：libdnet库为几个低层网络例程提供了一个简化的可移植接口。许多安装Snort的指南都是从源代码安装此库的，尽管这不是必需的。</p><p>zlib1g-dev：Snort所需的压缩库。</p><p>liblzma-dev：提供对swf文件的解压缩（adobe flash）</p><p>openssl和libssl-dev：提供SHA和MD5文件签名</p><p>6.1.3.安装Nghttp2的开发库</p><p>#sudo apt-get install -y libnghttp2-dev</p><p>6.1.4.在snort官网下载数据采集器（DAQ）来抽象对数据包捕获库的调用</p><p>#cd ~/snort_src</p><p>#wget <a href="https://snort.org/downloads/snort/daq-2.0.7.tar.gz">https://snort.org/downloads/snort/daq-2.0.7.tar.gz</a>  </p><p>#tar -xvzf daq-2.0.7.tar.gz</p><p>#cd daq-2.0.7</p><p>#./configure</p><p>#make  #编译</p><p>#sudo make install #安装</p><p>6.1.5.源码安装snort</p><p>#cd ~/snort_src</p><p>#wget <a href="https://snort.org/downloads/snort/snort-2.9.20.tar.gz">https://snort.org/downloads/snort/snort-2.9.20.tar.gz</a></p><p>#tar -xvzf snort-2.9.20.tar.gz</p><p>#cd snort-2.9.20</p><p>#./configure –enable-sourcefire  </p><p>enable-sourcefire应该被添加到混合中，因为它也设置了一个标志用于条件编译。</p><p>#make</p><p>#sudo make install</p><p>6.1.6.更新共享库</p><p>#sudo ldconfig</p><p>6.1.7.Snort安装会将Snort二进制文件放在/ usr / local / bin / snort，因此，创建到/ usr / sbin / snort的符号链接</p><p>#sudo ln -s /usr/local/bin/snort /usr/sbin/snort </p><p>6.1.8安装后输入snort –V看到以下内容，安装snort完成</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image005.jpg" alt="clip_image005"></p><h3 id="6-2将snort配置位NIDS"><a href="#6-2将snort配置位NIDS" class="headerlink" title="6.2将snort配置位NIDS"></a>6.2将snort配置位NIDS</h3><p>6.2.1. 基本配置：出于安全原因， Snort应该以非特权用户身份运行，创建一个<strong>snort</strong>用户和组</p><p>#sudo groupadd snort<br> #sudo useradd snort -r -s /sbin/nologin -c SNORT_IDS -g snort</p><p>6.2.2. 创建snort需要的文件和文件夹</p><p># 创建Snort目录:<br> #sudo mkdir /etc/snort<br> #sudo mkdir /etc/snort/rules<br> #sudo mkdir /etc/snort/rules/iplists<br> #sudo mkdir /etc/snort/preproc_rules<br> #sudo mkdir /usr/local/lib/snort_dynamicrules<br> #sudo mkdir /etc/snort/so_rules</p><p># 创建一些存储规则和ip列表的文件<br> #sudo touch /etc/snort/rules/iplists/black_list.rules<br> #sudo touch /etc/snort/rules/iplists/white_list.rules<br> #sudo touch /etc/snort/rules/local.rules<br> #sudo touch /etc/snort/sid-msg.map</p><p># 创建日志文件<br> #sudo mkdir /var/log/snort<br> #sudo mkdir /var/log/snort/archived_logs</p><p># 调整权限，对目前目录下的所有文件与子目录进行相同的权限变更，即以递归的方式逐个变更，使得此程序具有 root 的权限；拥有者有读取，写入，执行权限；组用户有读取，写入，执行权限；其他用户有 读取，执行权限<br> #sudo chmod -R 5775 /etc/snort<br> #sudo chmod -R 5775 /var/log/snort<br> #sudo chmod -R 5775 /var/log/snort/archived_logs<br> #sudo chmod -R 5775 /etc/snort/so_rules<br> #sudo chmod -R 5775 /usr/local/lib/snort_dynamicrules</p><p># 改变文件夹的所有权为snort组的snort用户，以便snort程序能够写入日志等数据<br> #sudo chown -R snort:snort /etc/snort<br> #sudo chown -R snort:snort /var/log/snort<br> #sudo chown -R snort:snort /usr/local/lib/snort_dynamicrules</p><p>6.2.3. 将解压后snort中的文件复制到我们新建的文件夹中</p><p>  #cd ~/snort_src/snort-2.9.20/etc/<br> #sudo cp <em>.conf</em> /etc/snort<br> #sudo cp *.map /etc/snort<br> #sudo cp *.dtd /etc/snort</p><p>  #cd ~/snort_src/snort-2.9.9.0/src/dynamic-#preprocessors/build/usr/local/lib/snort_dynamicpreprocessor/<br> #sudo cp * /usr/local/lib/snort_dynamicpreprocessor/</p><p>完成以上操作后/etc/snort/文件结构如下：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image006.png" alt="clip_image006"></p><p>6.2.4. 编辑snort配置文件</p><p>注释掉Snort导入默认规则文件集的行，因为我们暂时还没有引入相关规则，如果不注释掉的话就会报错</p><p>#sudo sed -i ‘s/include $RULE_PATH/include $RULE_PATH/‘ /etc/snort/snort.conf<br> 修改snort.conf文件，如下</p><p> #配置网络信息，这里的IP是192.168.159.138，所以ip如下</p><p>ipvar HOME_NET 192.168.159.0/24</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image008.jpg" alt="clip_image008"></p><p>我们需要告诉Snort我们之前创建的所有文件夹的位置。这些设置也是<strong>snort.conf</strong>文件的一部分</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image010.jpg" alt="clip_image010"></p><p>#启用本地规则文件</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image012.jpg" alt="clip_image012"></p><p>6.2.5测试snort</p><p>root@hui-virtual-machine:/etc/snort/rules# sudo snort -T -c /etc/snort/snort.conf -i ens33</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image014.jpg" alt="clip_image014"></p><p>6.2.6.编辑规则文件，编写两条基本的规则如下：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image016.jpg" alt="clip_image016"></p><p>6.2.7.开始测试刚刚编写的规则</p><p>hui@hui-virtual-machine:/etc/snort/rules$ sudo snort -T -c /etc/snort/snort.conf                                            -i ens33</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image018.jpg" alt="clip_image018"></p><p>开始检验，用一台别的主机ping snort的主机</p><p>#sudo /usr/local/bin/snort -A console -q -u snort -g snort -c /etc/snort/snort.conf -i ens33</p><p>可以看到如下结果，即警告信息如下：</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image020.jpg" alt="clip_image020"></p><p>在规则中，没有关于ARP欺骗检测规则定义，但是可以通过snort的内置模块进行检测。具体配置如下：</p><p>在snort.conf文件中配置如下：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image021.png" alt="clip_image021"></p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image023.jpg" alt="clip_image023"></p><p>完成后使用kali进行ARP欺骗攻击</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image025.jpg" alt="clip_image025"></p><p>再次回到被攻击机，发现攻击成功</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image027.jpg" alt="clip_image027"></p><p>同时，我们也可以在这里发现ARP攻击警告信息如下：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image029.jpg" alt="clip_image029"></p><p>6.2.8.安装官方snort规则，添加其他的安全规则，这里使用snort官网上下载的community.rules，将下载来的community.rules复制到/etc/snort/rules目录下，如下：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image030.png" alt="clip_image030"></p><p>修改snort.conf，添加community.rules规则集，如下：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image031.png" alt="clip_image031"></p><p>查看规则集内容如下，可以看到所有的规则都被注释掉了，因此这里我们可以选择需要的规则取消注释</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image033.jpg" alt="clip_image033"></p><h3 id="6-3-安装Barnyard2和配置Mysql"><a href="#6-3-安装Barnyard2和配置Mysql" class="headerlink" title="6.3.安装Barnyard2和配置Mysql"></a>6.3.安装Barnyard2和配置Mysql</h3><p>Barnyard2的作用是读取Snort产生的二进制事件文件(/var/log/snort/snort.log.XXXXXXXXXX)并存储到MySQL中。Snort的配置文件自身含有插件，它允许将Snort报警记录到MySQL中，但这样一来，系统数据会激增。当IDS系统检测到入侵行为时，它会用INSERT语句向数据库中写入数据，导致更新非常慢。所以如果直接将Snort输出到数据库，在数据量增大时这种方案的效率并不高，故使用外部代理将报警输出到Barnyard2。下一步，安装Barnyard2，这是一个专用的后台处理程序，将有助于减少Snort服务器上的负载</p><p>6.3.1安装一些必备组件</p><p>#sudo apt-get install -y mysql-server libmysqlclient-dev mysql-client autoconf libtool</p><p>6.3.2编辑snort.conf文件</p><p>#sudo vi /etc/snort/snort.conf</p><p>#添加一行以告诉Snort以二进制形式输出事件。即添加以下行并保存文件：output unified2: filename snort.u2, limit 128</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image035.jpg" alt="clip_image035"></p><p>6.3.3接下来，安装Barnyard2</p><p>#cd ~/snort_src</p><p>#wget <a href="https://github.com/firnsy/barnyard2/archive/master.tar.gz">https://github.com/firnsy/barnyard2/archive/master.tar.gz</a> -O barnyard2-Master.tar.gz</p><p>#tar zxvf barnyard2-Master.tar.gz</p><p>#cd barnyard2-master</p><p>使用autoreconf来更新配置文件</p><p>#autoreconf -fvi -I ./m4 </p><p>Barnyard2需要访问<strong>dnet.h</strong>库，该库是我们先前与Ubuntu libdumbnet软件包一起安装的，创建一个链接</p><p>#sudo ln -s /usr/include/dumbnet.h /usr/include/dnet.h<br> #sudo ldconfig</p><p>根据系统结构，运行Barnyard2在MySQL的库（这里时64位的）</p><p>  #./configure –with-mysql –with-mysql-libraries=/usr/lib/x86_64-linux-gnu</p><p>​    #make<br> #sudo make install</p><p>​    测试barnyard2是否安装成功</p><p>   #barnyard2 –V</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image037.jpg" alt="clip_image037"></p><p>为Snort配置为使用Barnyard2，从源程序包中复制一些文件</p><p>#sudo cp ~/snort_src/barnyard2-master/etc/barnyard2.conf /etc/snort/<br> #sudo mkdir /var/log/barnyard2<br> #sudo chown snort.snort /var/log/barnyard 赋予snort组snort用户操作该文件的权限</p><p>#sudo touch /var/log/snort/barnyard2.waldo</p><p>指定文件的拥有者改为指定的用户snort 组snort<br> #sudo chown snort.snort /var/log/snort/barnyard2.waldo </p><p>6.3.4. 创建数据库<br> #sudo mysql 进入数据库<br> mysql&gt; create database snort;<br> mysql&gt; use snort;</p><p>#导入barnyard2的数据库<br> mysql&gt; source ~/snort_src/barnyard2-master/schemas/create_mysql<br> mysql&gt; CREATE USER ‘snort‘@’localhost’ IDENTIFIED BY ‘123’;</p><p>#赋予数据库的部分操作权限给snort‘@’localhost<br> mysql&gt; grant create, insert, select, delete, update on snort.* to ‘snort‘@’localhost’; </p><p>mysql&gt; exit</p><p>6.3.5.创建数据库后，要将信息告诉Barnyard2，编辑barnyard2.conf文件</p><p>#sudo gedit /etc/snort/barnyard2.conf</p><p><img src="/E:/git-blog\source\images\clip_image038.png" alt="img">在文件的末尾添加</p><p>output database: log, mysql, user=snort password=123 dbname=snort host=localhost sensor name=sensor01</p><p>然后运行如下命令：</p><p>sudo barnyard2 -c /etc/snort/barnyard2.conf -d /var/log/snort -f snort.log -w /var/log/snort/barnyard2.waldo -g snort -u snort</p><p>运行结果如图，等待数据传入</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image040.jpg" alt="clip_image040"></p><p>再次ping 192.168.159.137,出现如下结果，可知数据已存入数据库：</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image042.jpg" alt="clip_image042"></p><h3 id="6-4-安装base"><a href="#6-4-安装base" class="headerlink" title="6.4.安装base"></a>6.4.安装base</h3><p>创建可视化界面，这里使用的是base，base需要php5 </p><p>6.4.1.安装php5软件包</p><p>#sudo add-apt-repository ppa:ondrej/php<br> #sudo apt-get update<br> #sudo apt-get install -y apache2 libapache2-mod-php5.6 php5.6-mysql php5.6-cli php5.6 php5.6-common php5.6-gd php5.6-cli php-pear php5.6-xml</p><p>6.4.2.安装pear图像图</p><p>#sudo pear install -f –alldeps Image_Graph</p><p>6.4.3.下载安装adodb</p><p>#cd ~/snort_src<br> #wget <a href="https://sourceforge.net/projects/adodb/files/adodb-php5-only/adodb-520-for-#php5/adodb-5.20.8.tar.gz">https://sourceforge.net/projects/adodb/files/adodb-php5-only/adodb-520-for-#php5/adodb-5.20.8.tar.gz</a><br> #tar -xvzf adodb-5.20.8.tar.gz<br> #sudo mv adodb5 /var/adodb<br> #sudo chmod -R 755 /var/adodb</p><p>6.4.4.下载base并复制到apache2目录下</p><p>#cd ~/snort_src<br> #wget <a href="http://sourceforge.net/projects/secureideas/files/BASE/base-1.4.5/base-1.4.5.tar.gz">http://sourceforge.net/projects/secureideas/files/BASE/base-1.4.5/base-1.4.5.tar.gz</a><br> #tar xzvf base-1.4.5.tar.gz<br> #sudo mv base-1.4.5 /var/www/html/base/</p><p>6.4.5.创建和配置base文件</p><p>#cd /var/www/html/base<br> #sudo cp base_conf.php.dist base_conf.php<br> #sudo vi /var/www/html/base/base_conf.php</p><p>文件配置如下</p><p>$BASE_urlpath = ‘/base’;<br> $DBlib_path = ‘/var/adodb/‘;<br> $alert_dbname  = ‘snort’;<br> $alert_host   = ‘localhost’;<br> $alert_port   = ‘’;<br> $alert_user   = ‘snort’;<br> $alert_password = ‘123’;   </p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image044.jpg" alt="clip_image044"></p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image046.jpg" alt="clip_image046"></p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image047.png" alt="clip_image047"></p><p>修改base文件权限</p><p>#sudo chown -R www-data:www-data /var/www/html/base<br> #sudo chmod o-r /var/www/html/base/base_conf.php</p><p><img src="/E:/git-blog\source\images\clip_image049.jpg" alt="clip_image049"></p><p>这里也可以不配置base文件，可以在<a href="http://localhost/base%E4%B8%AD%E8%AE%BE%E7%BD%AE">http://localhost/base中设置</a></p><p>6.4.6.重启apache</p><p>#sudo service apache2 restart</p><p>6.4.7浏览器打开 http：//localhost/base/index.php，可以看到如下结果:</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image051.jpg" alt="clip_image051"></p><h2 id="测试编写的攻击检测规则"><a href="#测试编写的攻击检测规则" class="headerlink" title="测试编写的攻击检测规则"></a>测试编写的攻击检测规则</h2><p><img src="/E:/git-blog\source\images\clip_image053.jpg" alt="clip_image053"></p><p>第一条规则：除192.168.159.10以外的主机网页访问本机都弹出警告；</p><p>第二条规则：当SYN包10秒出现1200个就弹出警告；</p><p>第三条规则：当ICMP包大于100就弹出警告；</p><p>第四条规则：当尝试获取主机的shell时，弹出警告；</p><p>第五条规则：当发生FIN扫描时弹出警告。</p><p>检验如下：</p><p>7.1.首先，验证第一条规则</p><p>alert tcp !192.168.159.10 any -&gt; $HOME_NET 80 (msg: “other want to get HTTP!!!”; classtype: attempted-user; sid: 1000002; rev: 1; priority: 1)</p><p>即除192.168.159.10以外的主机网页访问ubuntu</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image055.jpg" alt="clip_image055"></p><p>回到虚拟机，可以看到终端已弹出警告</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image057.jpg" alt="clip_image057"></p><p>Web端也已经有记录</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image059.jpg" alt="clip_image059"></p><p>7.2.现在验证第二条规则，alert tcp any any -&gt; $HOME_NET any (msg: “SYN flood!!!”; flags: S; threshold: type threshold,track by_dst,count 1200,seconds 10; classtype: attempted-dos ; sid: 1000006; rev: 1; priority: 2)</p><p>我们根据SYN泛洪攻击的特征，即短时间内发出大量的SYN包，造成资源的大量消耗而不能向正常的请求提供服务，那么我们可以在规则里写入10秒钟内包的数目达到了1200就弹出警告.</p><p>我们在攻击机kali运行hping3 -q -n -a 2.2.2.2 -S -s 53 –keep -p 631 –flood 192.168.159.138</p><p>查看到ubuntu已弹出警告</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image061.jpg" alt="clip_image061"></p><p>7.3.现在验证第三条规则：alert icmp any any -&gt; $HOME_NET any (msg: “ICMP so big!!!”; classtype: icmp-event ; dsize: &gt;100; sid: 10000004; rev: 1)</p><p>通过查询资料我们发现对于一般的PING包来说，windows的ping包大小为32bit，Linux的ping包大小一般为64Bit，因此我们可以设定ping包的大小如果超过100bit的话，就弹出警示。</p><p>当ICMP包大于100就弹出警告；</p><p>用主机发送一个超过101大小的包</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image063.jpg" alt="clip_image063"></p><p>查看ubuntu最近的15条记录，可以看到已经弹出了警告</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image065.jpg" alt="clip_image065"></p><p>7.4.现在检验第四条规则，alert tcp any any -&gt; $HOME_NET 22 (msg: “other want to get SSL/SHELL!!!”; classtype: attempted-user ;threshold: type threshold,track by_dst,count 5,seconds 1; sid: 1000007; rev: 1;)</p><p>通过端口号来判断是否有SSH协议，但是如果只通过这个来判断是否有人连接了SSH又会产生误报，比如端口扫描也会扫描到22端口，经过抓包分析发现，完成一次SSH连接需要15到20个包，因此我们还要在规则里面写入当1秒钟收到5个SSH协议包的话就弹出警示，这样可以降低误报率。</p><p>连接ubuntu的shell,如下：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image067.jpg" alt="clip_image067"></p><p>查看警告信息，能查看到关于该规则的警告</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image069.jpg" alt="clip_image069"></p><p>7.5.现在检验低五条规则，alert tcp any any -&gt; $HOME_NET any (msg: “namp FIN scan!!!”; flags: F; threshold: type threshold,track by_dst,count 500,seconds 2;classtype: network-scan ; sid: 1000008; rev: 1; )，经过测试可以发现FIN扫描基本上在2分钟之内完成，扫描一般有1000多个端口，因此规则里面设置的频率为2分钟500个FIN包，则弹出警示。</p><p>用kali的nmap去扫描ubuntu的端口，如下：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image071.jpg" alt="clip_image071"></p><p>回到ubuntu就可以查看到该条规则的警告，如下：</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image073.jpg" alt="clip_image073"></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>5.1.在解包时出现如下错误，查到是dpkg的问题，需要更新软件，但是我的apt-get install命令出现了问题，最后发现是ubuntu 14.04版本过低，因此我重新安装了ubuntu18.04,就没有这个错误。</p><p> <img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image075.jpg" alt="clip_image075"></p><p>5.2. 安装Barnyard2时，编译软件时报错, 详细的错误信息如下：</p><p><img src="/E:/git-blog\source\images\clip_image077.jpg" alt="clip_image077"></p><p>解决办法：从错误信息看，是在处理configure.ac文件时出错了，认为AC_PROG_LIBTOOL是未定义的宏，使得执行autoconf失败，安装libtool包得以解决：sudo apt-get install libtool</p><p>5.3.数据库无法传入数据，即警告信息没有存入snort数据库的event里面，具体情况如下：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image079.jpg" alt="clip_image079"></p><p> <img src="/E:/git-blog\source\images\clip_image080.png" alt="clip_image080"></p><p>解决办法：进入barnyard2.conf文件做如下修改：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image082.jpg" alt="clip_image082"></p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image084.jpg" alt="clip_image084"></p><p>然后启动Snort和Barnyard2进行联合测试</p><p>执行sudo snort -q -u snort -g snort -c /etc/snort/snort.conf -i ens33 –D（“-D”参数表示以后台进程运行）</p><p>如果出现以下内容，则成功启动snort了：</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image086.jpg" alt="clip_image086"></p><p>然后再重新执行的这条命令用于测试Barnyard2程序是否能正常执行：</p><p>sudo barnyard2 -c /etc/snort/barnyard2.conf -d /var/log/snort/ -f snort.log -w /var/log/snort/barnyard2.waldo -g snort -u snort -T</p><p>如出现以下结果，说明程序可以正常运行。</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image088.jpg" alt="clip_image088"></p><p>然后运行如下命令：</p><p>sudo barnyard2 -c /etc/snort/barnyard2.conf -d /var/log/snort -f snort.log -w /var/log/snort/barnyard2.waldo -g snort -u snort</p><p>完成上述步骤后再执行传入警告信息的命令，就会是成功的。</p><p>5.4.安装pear图像图时，报错如下：php拓展没找到</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image090.jpg" alt="clip_image090"></p><p>解决办法：查看ubuntu的默认php版本，发现和我们下载使用的版本不一样，因此找不到php拓展</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image092.jpg" alt="clip_image092"></p><p>尝试重新设置默认php版本，步骤如下：</p><p>启用PHP5.6模块：$ sudo a2enmod php5.6</p><p>设置PHP5.6为默认版本：$ sudo update-alternatives –set php /usr/bin/php5.6</p><p>由于安装了其他PHP扩展，将它们设置为默认值：$ sudo update-alternatives –set phar /usr/bin/phar5.6</p><p>最后，重新启动Apache web服务器：$ sudo systemctl restart apache2</p><p>现在，检查PHP5.6是否为默认版本：$ php –v</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image094.jpg" alt="clip_image094"></p><p>问题得以解决！！！</p><p>​                             </p><p>5.5. 浏览器打开 http：//localhost/base/index.php，无法访问</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image096.jpg" alt="clip_image096"></p><p>解决办法：检查设置本机的hosts为 127.0.0.1 localhost</p><p><img src="https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/clip_image098.jpg" alt="clip_image098"></p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据流图&quot;&gt;&lt;a href=&quot;#数据流图&quot; class=&quot;headerlink&quot; title=&quot;数据流图&quot;&gt;&lt;/a&gt;数据流图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://xiangmipic.oss-cn-hangzhou.aliyuncs.com/img/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>NTP</title>
    <link href="http://example.com/2022/07/02/NTP/"/>
    <id>http://example.com/2022/07/02/NTP/</id>
    <published>2022-07-02T03:00:42.428Z</published>
    <updated>2022-07-02T03:01:24.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NTP"><a href="#NTP" class="headerlink" title="NTP"></a>NTP</h1><p> 网络时间协议，英文名称：Network Time Protocol（NTP）是用来使计算机<a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5">时间同步</a>化的一种协议，它可以使<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>对其<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>或<a href="https://baike.baidu.com/item/%E6%97%B6%E9%92%9F%E6%BA%90/3219811">时钟源</a>（如石英钟，GPS等等)做同步化，它可以提供高精准度的时间校正（LAN上与标准间差小于1毫秒，WAN上几十毫秒），且可介由加密确认的方式来防止恶毒的<a href="https://baike.baidu.com/item/%E5%8D%8F%E8%AE%AE/670528">协议</a>攻击。NTP的目的是在无序的Internet环境中提供精确和健壮的时间服务。 </p><h2 id="NTP-Linux命令详解"><a href="#NTP-Linux命令详解" class="headerlink" title="NTP Linux命令详解"></a>NTP Linux命令详解</h2><p><strong>一般NTP常用的大概有如下命令族:</strong></p><p>1.ntpq  其功能是用于查询NTP时间服务器信息。 ( ntpq实用程序用于监视NTP守护进程ntpd操作和确定性能。 )</p><ul><li> ntpq –crv </li><li> ntpq –p   显示服务器同级设备的列表 </li><li></li></ul><p>2.ntpdate - set the date and time via NTP 通过NTP设置时间</p><ul><li><p>ntpdate –d 时钟IP地址        求和时钟服务器的偏差值 ( Offset值为偏差时间，本地时间+offset时间=服务器时间)</p></li><li><p>ntpdate –q 时钟IP地址         求和时钟服务器的偏差值 </p></li><li><p> ntpdate –u 时钟IP地址         强制同步时间服务器 </p></li><li><p>ntpdate 时钟IP地址                 强制同步时间服务器 </p></li></ul><ol start="3"><li>ntpdc是一个实用程序，用于查询 ntpd(8) 的当前状态，并请求改变其状态。 它使用源代码中描述的 NTP mode 7 控制消息格式。程序既可以在交互模式下运行，也可以使用命令行参数。 ( ntpdc用于查询ntpd守护进程对其当前状态和要求的变化。程序可以运行在交互模式下使用命令行参数或控制。 )</li></ol><ul><li><p>1、ntpdc –c monlist 检查有哪些客户端和时钟服务器有同步。</p><p>   ntpdc –c monlist 192.168.5.38看38上执行ntpdc –cmonlist的状态</p></li><li><p>2、其他一些参数</p><p>   Sysinfo参数</p><p> ntpdc -c loopinfo</p><p>   ntpdc -c sysstats</p><p>   ntpdc -c sysinfo</p></li></ul><p>4.ntpd实用程序是一个操作系统守护程序，它可以设置和维护系统的时间与互联网标准时间服务器同步。</p><ul><li>ntpd -a            对广播客户端、多播客户端和对称被动关联进行加密认证</li><li>ntpd -A            广播客户端、多播客户端和对称被动关联不需要加密认证 </li><li>ntpd  -b            启用客户端同步到广播服务器 </li><li>ntpd   -c conffile          指定配置文件的名称和路径，默认为/etc/ntp/ntp.conf </li><li>ntpd -L              指定配置文件的名称和路径，默认为/etc/ntp/ntp.conf </li><li>ntpd -d               使用调试模式 </li></ul><p> <a href="https://www.linuxcool.com/ntpdc">ntpdc命令 – 查询NTP守护进程 – Linux命令大全(手册) (linuxcool.com)</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NTP&quot;&gt;&lt;a href=&quot;#NTP&quot; class=&quot;headerlink&quot; title=&quot;NTP&quot;&gt;&lt;/a&gt;NTP&lt;/h1&gt;&lt;p&gt; 网络时间协议，英文名称：Network Time Protocol（NTP）是用来使计算机&lt;a href=&quot;https://bai</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>WAF -- Web应用防火墙</title>
    <link href="http://example.com/2022/06/06/WAF----Web%E5%BA%94%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <id>http://example.com/2022/06/06/WAF----Web%E5%BA%94%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99/</id>
    <published>2022-06-06T01:16:53.434Z</published>
    <updated>2022-06-06T01:33:29.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略还专门为Web应用提供保护的一款产品。与传统防火钱不同，WAF工作在应用层。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略还专门为Web应用提供保护的一款产品。与传统防火钱不同，WAF工作在应用层</summary>
      
    
    
    
    
  </entry>
  
</feed>
